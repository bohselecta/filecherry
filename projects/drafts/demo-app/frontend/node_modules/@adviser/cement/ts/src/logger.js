import { bin2string } from "./bin2text.js";
export const Level = {
    WARN: "warn",
    DEBUG: "debug",
    INFO: "info",
    ERROR: "error",
};
export class LogValue {
    constructor(fn) {
        this.fn = fn;
    }
    value() {
        try {
            return this.fn();
        }
        catch (e) {
            return `LogValue:${e.message}`;
        }
    }
    toJSON() {
        return this.value();
    }
}
export function asyncLogValue(val) {
    throw new Error("Not implemented");
}
export function logValue(val, ctx) {
    return logValueInternal(val, {
        ...ctx,
        state: ctx.state || new Set([Math.random()]),
    });
}
function logValueInternal(val, ctx) {
    var _a, _b;
    ctx = {
        ...ctx,
        state: ctx.state || new Set([Math.random()]),
    };
    switch (typeof val) {
        case "function":
            return new LogValue(val);
        case "string": {
            try {
                const ret = JSON.parse(val);
                if (typeof ret === "object" && ret !== null) {
                    return logValueInternal(ret, ctx);
                }
            }
            catch (e) {
                try {
                    const url = new URL(val);
                    return new LogValue(() => url.toString());
                }
                catch (e) {
                }
            }
            if (val.match(/[\n\r]/)) {
                const lines = val.split(/[\n\r]+/).map((v) => v.trim());
                return new LogValue(() => lines);
            }
            return new LogValue(() => val.toString());
        }
        case "number":
            return new LogValue(() => val);
        case "boolean":
            return new LogValue(() => val);
        case "object": {
            if (val === null) {
                return new LogValue(() => "null");
            }
            if (ArrayBuffer.isView(val)) {
                try {
                    const decoder = new TextDecoder();
                    const asStr = decoder.decode(val);
                    const obj = JSON.parse(asStr);
                    return logValueInternal(obj, ctx);
                }
                catch (e) {
                    return logValueInternal(bin2string(val, 512), ctx);
                }
            }
            if (Array.isArray(val)) {
                return new LogValue(() => val.map((v) => logValue(v, { ...ctx, state: undefined }).value()));
            }
            if (val instanceof Headers) {
                return new LogValue(() => Object.fromEntries(val.entries()));
            }
            if (val instanceof ReadableStream) {
                return new LogValue(() => ">Stream<");
            }
            if (val instanceof Promise) {
                return new LogValue(() => ">Promise<");
            }
            if ((_a = ctx.state) === null || _a === void 0 ? void 0 : _a.has(val)) {
                return new LogValue(() => "...");
            }
            (_b = ctx.state) === null || _b === void 0 ? void 0 : _b.add(val);
            if (typeof val.toJSON === "function") {
                return new LogValue(() => val.toJSON());
            }
            const res = {};
            const typedVal = val;
            for (const key in typedVal) {
                if (ctx.ignoreAttr.IsSome() && ctx.ignoreAttr.unwrap().test(key)) {
                    continue;
                }
                const element = typedVal[key];
                if (element instanceof LogValue) {
                    res[key] = element;
                }
                else {
                    if (typeof element !== "function") {
                        res[key] = logValueInternal(element, ctx);
                    }
                }
            }
            return new LogValue(() => res);
        }
        default:
            if (!val) {
                return new LogValue(() => "--Falsy--");
            }
            throw new Error(`Invalid type:${typeof val}`);
    }
}
export function IsLogger(obj) {
    return (typeof obj === "object" &&
        [
            "Module",
            "EnableLevel",
            "DisableLevel",
            "SetDebug",
            "Str",
            "Error",
            "Warn",
            "Debug",
            "Log",
            "WithLevel",
            "Err",
            "Info",
            "Timestamp",
            "Any",
            "Dur",
            "Uint64",
        ]
            .map((fn) => typeof obj[fn] === "function")
            .reduce((a, b) => a && b, true));
}
//# sourceMappingURL=logger.js.map