import { Future } from "./future.js";
import { LRUMap } from "./lru-map-set.js";
import { Result } from "./result.js";
export class ResolveSeq {
    constructor(ctx) {
        this._flushWaiting = [];
        this._seqFutures = [];
        this.ctx = ctx;
    }
    reset() {
    }
    flush() {
        var _a;
        if (this._seqFutures.length > 0) {
            const waitForFlush = new Future();
            (_a = this._flushWaiting) === null || _a === void 0 ? void 0 : _a.push(waitForFlush);
            return waitForFlush.asPromise();
        }
        return Promise.resolve();
    }
    _step(item) {
        var _a;
        if (!item) {
            this._flushWaiting.forEach((f) => f.resolve());
            (_a = this._flushWaiting) === null || _a === void 0 ? void 0 : _a.splice(0, this._flushWaiting.length);
            return Promise.resolve();
        }
        item
            .fn(this.ctx)
            .then((value) => item.future.resolve(value))
            .catch((e) => item.future.reject(e))
            .finally(() => {
            this._seqFutures.shift();
            void this._step(this._seqFutures[0]);
        });
        return Promise.resolve();
    }
    async add(fn, id) {
        const future = new Future();
        this._seqFutures.push({ future, fn, id });
        if (this._seqFutures.length === 1) {
            void this._step(this._seqFutures[0]);
        }
        return future.asPromise();
    }
}
export class ResolveOnce {
    constructor(ctx) {
        this._onceDone = false;
        this._onceFutures = [];
        this._onceOk = false;
        this._isPromise = false;
        this.ctx = ctx;
    }
    get ready() {
        return this._onceDone;
    }
    reset() {
        this._onceDone = false;
        this._onceOk = false;
        this._onceValue = undefined;
        this._onceError = undefined;
        if (this._inProgress) {
            const idx = this._onceFutures.findIndex((f) => f === this._inProgress);
            if (idx >= 0) {
                this._onceFutures.push(...this._onceFutures.splice(2).slice(1));
            }
        }
        else {
            this._onceFutures.length = 0;
        }
    }
    once(fn) {
        if (this._onceDone) {
            if (this._onceError) {
                if (this._isPromise) {
                    return Promise.reject(this._onceError);
                }
                else {
                    throw this._onceError;
                }
            }
            if (this._onceOk) {
                if (this._isPromise) {
                    return Promise.resolve(this._onceValue);
                }
                else {
                    return this._onceValue;
                }
            }
            throw new Error("ResolveOnce.once impossible");
        }
        const future = new Future();
        this._onceFutures.push(future);
        if (this._onceFutures.length === 1) {
            const okFn = (value) => {
                this._onceValue = value;
                this._onceOk = true;
                this._onceDone = true;
                if (this._isPromise) {
                    this._onceFutures.forEach((f) => f.resolve(this._onceValue));
                }
                this._onceFutures.length = 0;
            };
            const catchFn = (e) => {
                this._onceError = e;
                this._onceOk = false;
                this._onceValue = undefined;
                this._onceDone = true;
                if (this._isPromise) {
                    this._onceFutures.forEach((f) => f.reject(this._onceError));
                }
                this._onceFutures.length = 0;
            };
            this._inProgress = future;
            try {
                const ret = fn(this.ctx);
                if (typeof ret.then === "function") {
                    this._isPromise = true;
                    ret
                        .then(okFn)
                        .catch(catchFn)
                        .finally(() => {
                        this._inProgress = undefined;
                    });
                }
                else {
                    okFn(ret);
                }
            }
            catch (e) {
                catchFn(e);
            }
            if (!this._isPromise) {
                this._inProgress = undefined;
            }
        }
        if (this._isPromise) {
            return future.asPromise();
        }
        else {
            return this.once(fn);
        }
    }
}
export class Keyed {
    constructor(factory, params) {
        var _a;
        this.factory = factory;
        this._map = new LRUMap((_a = params === null || params === void 0 ? void 0 : params.lru) !== null && _a !== void 0 ? _a : { maxEntries: -1 });
    }
    setParam(params) {
        this._map.setParam(params.lru);
    }
    async asyncGet(key) {
        return this.get(await key());
    }
    get(key) {
        if (typeof key === "function") {
            key = key();
        }
        let keyed = this._map.get(key);
        if (!keyed) {
            keyed = this.factory(key);
            this._map.set(key, keyed);
        }
        return keyed;
    }
    unget(key) {
        const keyed = this._map.get(key);
        keyed === null || keyed === void 0 ? void 0 : keyed.reset();
        this._map.delete(key);
    }
    reset() {
        this._map.forEach((keyed) => keyed.reset());
        this._map.clear();
    }
}
export class KeyedResolvOnce extends Keyed {
    constructor(kp = {}) {
        super((key) => new ResolveOnce(key), kp);
    }
    values() {
        return (Array.from(this._map.entries())
            .filter(([_, v]) => v._onceDone)
            .map(([k, v]) => {
            if (v._onceDone) {
                if (v._onceError) {
                    return {
                        key: k,
                        value: Result.Err(v._onceError),
                    };
                }
                return {
                    key: k,
                    value: Result.Ok(v._onceValue),
                };
            }
            throw new Error("KeyedResolvOnce.values impossible");
        }));
    }
}
export class KeyedResolvSeq extends Keyed {
    constructor(kp = {}) {
        super((key) => new ResolveSeq(key), kp);
    }
}
//# sourceMappingURL=resolve-once.js.map