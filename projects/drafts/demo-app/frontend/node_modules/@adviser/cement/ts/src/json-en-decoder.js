import { exception2Result, Result } from "./result.js";
import { TxtEnDecoderSingleton as TxtEnDecoderSingleton } from "./txt-en-decoder.js";
class JSONOps {
    constructor(txtOps) {
        this.txtOps = txtOps;
    }
    async asyncStringify(input, replacer, space) {
        const resolved = await input;
        return this.stringify(resolved, replacer, space);
    }
    async asyncUint8ify(input, replacer, space) {
        const resolved = await input;
        return this.uint8ify(resolved, replacer, space);
    }
    async asyncParse(input, reviver) {
        return this.parse(await this.txtOps.asyncDecode(input), reviver);
    }
    stringify(input, replacer, space) {
        return JSON.stringify(Result.Is(input) ? input.unwrap() : input, replacer, space);
    }
    uint8ify(input, replacer, space) {
        return this.txtOps.encode(this.stringify(input, replacer, space));
    }
    parse(input, reviver) {
        return exception2Result(() => JSON.parse(this.txtOps.decode(input), reviver));
    }
}
let jsonEnDecoder;
export function JSONEnDecoderSingleton(txtEnde) {
    let needNew = false;
    if (txtEnde && txtEnde !== TxtEnDecoderSingleton()) {
        needNew = !!txtEnde;
        txtEnde = txtEnde !== null && txtEnde !== void 0 ? txtEnde : TxtEnDecoderSingleton();
    }
    if (needNew && txtEnde) {
        return new JSONOps(txtEnde);
    }
    jsonEnDecoder = jsonEnDecoder !== null && jsonEnDecoder !== void 0 ? jsonEnDecoder : new JSONOps(TxtEnDecoderSingleton());
    return jsonEnDecoder;
}
//# sourceMappingURL=json-en-decoder.js.map