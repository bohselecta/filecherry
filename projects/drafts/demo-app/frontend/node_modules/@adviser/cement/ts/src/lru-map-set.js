export class LRUSet {
    constructor(param = {}) {
        this._lruMap = new LRUMap(param);
    }
    setParam(param = {}) {
        this._lruMap.setParam(param);
    }
    get size() {
        return this._lruMap.size;
    }
    has(key) {
        return this._lruMap.has(key);
    }
    add(key) {
        this._lruMap.set(key, key);
    }
    delete(key) {
        this._lruMap.delete(key);
    }
    clear() {
        this._lruMap.clear();
    }
    forEach(callbackfn) {
        this._lruMap.forEach((value) => callbackfn(value, value));
    }
    entries() {
        return this._lruMap.entries();
    }
}
export class LRUMap {
    constructor(c = {}) {
        this._map = new Map();
        this.param = {
            maxEntries: c.maxEntries || 100,
            maxAge: c.maxAge || 0,
        };
    }
    touch(key) {
        if (!this._map.has(key)) {
            throw new Error(`key not found in cache: ${key}`);
        }
        const value = this._map.get(key);
        this._map.delete(key);
        this._map.set(key, value);
        return value;
    }
    setParam(param = {}) {
        if (typeof param.maxEntries === "number") {
            this.param.maxEntries = param.maxEntries;
            if (param.maxEntries > 0 && this._map.size > param.maxEntries) {
                const toDelete = [];
                let cacheSize = this._map.size;
                for (const key of this._map.keys()) {
                    if (cacheSize > param.maxEntries) {
                        toDelete.push(key);
                        cacheSize--;
                    }
                    else {
                        break;
                    }
                }
                for (const key of toDelete) {
                    this._map.delete(key);
                }
            }
        }
    }
    has(key) {
        return this._map.has(key);
    }
    get size() {
        return this._map.size;
    }
    async getSet(key, createFN) {
        const val = this.get(key);
        if (val) {
            return val;
        }
        else {
            const val = await createFN(key);
            this.set(key, val);
            return val;
        }
    }
    get(key) {
        if (this._map.has(key)) {
            return this.touch(key);
        }
        return this._map.get(key);
    }
    set(key, value) {
        this._map.delete(key);
        if (this.param.maxEntries > 0 && this._map.size >= this.param.maxEntries) {
            this._map.delete(this._map.keys().next().value);
            this._map.set(key, value);
        }
        else {
            this._map.set(key, value);
        }
    }
    delete(key) {
        this._map.delete(key);
    }
    clear() {
        this._map.clear();
    }
    forEach(callbackfn) {
        this._map.forEach(callbackfn);
    }
    entries() {
        return this._map.entries();
    }
}
//# sourceMappingURL=lru-map-set.js.map