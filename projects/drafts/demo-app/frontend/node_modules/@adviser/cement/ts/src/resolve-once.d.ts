import { Future } from "./future.js";
import { LRUMap, LRUParam } from "./lru-map-set.js";
import { Result } from "./result.js";
interface ResolveSeqItem<T, C> {
    readonly future: Future<T>;
    readonly fn: (c: C) => Promise<T>;
    readonly id?: number;
}
export declare class ResolveSeq<T, C = void> {
    readonly ctx: C;
    constructor(ctx?: C);
    reset(): void;
    readonly _flushWaiting: Future<void>[];
    flush(): Promise<void>;
    _step(item?: ResolveSeqItem<T, C>): Promise<void>;
    readonly _seqFutures: ResolveSeqItem<T, C>[];
    add(fn: (c: C) => Promise<T>, id?: number): Promise<T>;
}
export declare class ResolveOnce<T, CTX = void> {
    _onceDone: boolean;
    readonly _onceFutures: Future<T>[];
    _onceOk: boolean;
    _onceValue?: T;
    _onceError?: Error;
    _isPromise: boolean;
    _inProgress?: Future<T>;
    readonly ctx: CTX;
    constructor(ctx?: CTX);
    get ready(): boolean;
    reset(): void;
    once<R>(fn: (c: CTX) => R): R;
}
export interface KeyedParam {
    readonly lru: Partial<LRUParam>;
}
export declare class Keyed<T extends {
    reset: () => void;
}, K = string> {
    protected readonly _map: LRUMap<K, T>;
    readonly factory: (key: K) => T;
    constructor(factory: (key: K) => T, params: Partial<KeyedParam>);
    setParam(params: KeyedParam): void;
    asyncGet(key: () => Promise<K>): Promise<T>;
    get(key: K | (() => K)): T;
    unget(key: K): void;
    reset(): void;
}
export declare class KeyedResolvOnce<T, K = string> extends Keyed<ResolveOnce<T, K>, K> {
    constructor(kp?: Partial<KeyedParam>);
    values(): {
        key: K;
        value: Result<T>;
    }[];
}
export declare class KeyedResolvSeq<T, K = string> extends Keyed<ResolveSeq<T, K>, K> {
    constructor(kp?: Partial<KeyedParam>);
}
export {};
//# sourceMappingURL=resolve-once.d.ts.map