import { BaseSysAbstraction, WrapperSysAbstraction, } from "../base-sys-abstraction.js";
import { envFactory } from "../sys-env.js";
import { TxtEnDecoderSingleton } from "../txt-en-decoder.js";
import { DenoFileService } from "./deno-file-service.js";
const Deno = globalThis.Deno;
export class DenoExitServiceImpl {
    constructor() {
        this._exitHandlers = [];
        this.invoked = false;
        this._handleExit = async () => {
            if (this.invoked) {
                return;
            }
            this.invoked = true;
            for (const h of this._exitHandlers) {
                try {
                    const ret = h.hdl();
                    if (typeof ret.then === "function") {
                        await ret;
                    }
                }
                finally {
                }
            }
        };
        globalThis.addEventListener("unhandledrejection", (e) => {
            e.preventDefault();
            this.exit(19);
        });
        globalThis.addEventListener("error", () => {
            this.exit(19);
        });
        globalThis.addEventListener("uncaughtException", () => {
            this.exit(19);
        });
        globalThis.addEventListener("unload", () => {
            this.exit(0);
        });
        Deno.addSignalListener("SIGQUIT", () => {
            this.exit(3);
        });
        Deno.addSignalListener("SIGINT", () => {
            this.exit(2);
        });
        Deno.addSignalListener("SIGTERM", () => {
            this.exit(9);
        });
    }
    injectExitHandlers(hdls) {
        this._exitHandlers = hdls;
    }
    exit(code) {
        this._handleExit()
            .then(() => {
            Deno.exit(code);
        })
            .catch((err) => {
            console.error("ExitService: failed to handle exit", err);
            Deno.exit(code);
        });
    }
}
export class DenoSystemService {
    constructor() {
        this._exitService = new DenoExitServiceImpl();
        this._exitService.injectExitHandlers(DenoSystemService._exitHandlers);
    }
    Env() {
        return envFactory();
    }
    Args() {
        return Deno.args;
    }
    OnExit(hdl) {
        const id = crypto.randomUUID();
        DenoSystemService._exitHandlers.push({ hdl, id });
        return () => {
            const idx = DenoSystemService._exitHandlers.findIndex((h) => h.id === id);
            if (idx >= 0) {
                DenoSystemService._exitHandlers.splice(idx, 1);
            }
        };
    }
    Exit(code) {
        this._exitService.exit(code);
    }
}
DenoSystemService._exitHandlers = [];
let my = undefined;
export function DenoSysAbstraction(param) {
    if (!my) {
        my = new BaseSysAbstraction({
            TxtEnDecoder: (param === null || param === void 0 ? void 0 : param.TxtEnDecoder) || TxtEnDecoderSingleton(),
            FileSystem: new DenoFileService(),
            SystemService: new DenoSystemService(),
        });
    }
    return new WrapperSysAbstraction(my, param);
}
//# sourceMappingURL=deno-sys-abstraction.js.map