import { DenoEnvActions } from "./deno/deno-env-actions.js";
import { NodeEnvActions } from "./node/node-env-actions.js";
import { BrowserEnvActions } from "./web/web-env-actions.js";
import { CFEnvActions } from "./cf/cf-env-actions.js";
import { KeyedResolvOnce } from "./resolve-once.js";
import { getParamsResult } from "./utils/get-params-result.js";
const envActions = [
    { id: "cf", fn: (opts) => CFEnvActions.new(opts) },
    { id: "node", fn: (opts) => NodeEnvActions.new(opts) },
    { id: "deno", fn: (opts) => DenoEnvActions.new(opts) },
    { id: "browser", fn: (opts) => BrowserEnvActions.new(opts) },
];
export function registerEnvAction(fn) {
    const id = `id-${Math.random()}`;
    envActions.unshift({ id, fn });
    _envFactories.unget(id);
    return () => {
        const index = envActions.findIndex((i) => i.id === id);
        if (index >= 0) {
            envActions.splice(index, 1);
        }
    };
}
const _envFactories = new KeyedResolvOnce();
export function envFactory(opts = {}) {
    const found = envActions.find((fi) => fi.fn(opts).active());
    if (!found) {
        throw new Error("SysContainer:envFactory: no env available");
    }
    return _envFactories.get(found.id).once(() => {
        const action = found.fn(opts);
        const ret = new EnvImpl(action, opts);
        action.register(ret);
        return ret;
    });
}
function isIterable(obj) {
    if (obj == null) {
        return false;
    }
    return typeof obj[Symbol.iterator] === "function";
}
export class EnvImpl {
    constructor(map, opts = {}) {
        this._onSet = [];
        this._map = map;
        this._updatePresets(opts.presetEnv);
    }
    gets(...kparams) {
        return getParamsResult(kparams, {
            getParam: (k) => this.get(k),
        });
    }
    sets(...keys) {
        keys.forEach((key) => {
            if (Array.isArray(key)) {
                if (key.length === 2) {
                    const [k, v] = key;
                    if (typeof k === "string" && typeof v === "string") {
                        this.set(k, v);
                        return;
                    }
                }
                for (const item of key) {
                    if (Array.isArray(item)) {
                        if (item.length === 2) {
                            const [k, v] = item;
                            if (typeof k === "string" && typeof v === "string") {
                                this.set(k, v);
                            }
                        }
                    }
                }
            }
            else {
                if (isIterable(key)) {
                    for (const [k, v] of key) {
                        if (typeof k === "string" && typeof v === "string") {
                            this.set(k, v);
                        }
                    }
                }
                else {
                    const rKey = key;
                    for (const k in rKey) {
                        const v = rKey[k];
                        if (typeof k === "string" && typeof v === "string") {
                            this.set(k, v);
                        }
                    }
                }
            }
        });
    }
    _updatePresets(presetEnv) {
        if (!presetEnv) {
            return;
        }
        for (const [key, value] of presetEnv) {
            this._map.set(key, value);
        }
    }
    _applyOnSet(onSet, key, value) {
        onSet.forEach((item) => {
            let keys = [];
            if (key) {
                keys = [key];
            }
            else {
                keys = this._map.keys();
            }
            keys
                .filter((k) => {
                if (item.filter.size === 0) {
                    return true;
                }
                if (item.filter.has(k)) {
                    return true;
                }
                return false;
            })
                .forEach((k) => {
                let v;
                if (!key && !value) {
                    v = this._map.get(k);
                }
                else if (key && !value) {
                    v = undefined;
                }
                else {
                    v = value;
                }
                item.fn(k, v);
            });
        });
    }
    keys() {
        return this._map.keys();
    }
    onSet(fn, ...filter) {
        const item = { filter: new Set(filter), fn };
        this._onSet.push(item);
        this._applyOnSet([item]);
    }
    get(key) {
        return this._map.get(key);
    }
    set(key, value) {
        if (!value) {
            return;
        }
        this._map.set(key, value);
        this._applyOnSet(this._onSet, key, value);
    }
    delete(key) {
        this._map.delete(key);
        this._applyOnSet(this._onSet, key);
    }
}
//# sourceMappingURL=sys-env.js.map