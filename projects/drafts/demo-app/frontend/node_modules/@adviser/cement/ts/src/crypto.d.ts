export interface CTJsonWebKey {
    alg?: string;
    crv?: string;
    d?: string;
    dp?: string;
    dq?: string;
    e?: string;
    ext?: boolean;
    k?: string;
    key_ops?: string[];
    kty?: string;
    n?: string;
    oth?: RsaOtherPrimesInfo[];
    p?: string;
    q?: string;
    qi?: string;
    use?: string;
    x?: string;
    y?: string;
}
export type CTKeyFormat = "jwk" | "pkcs8" | "raw" | "spki";
export type CTKeyUsage = "decrypt" | "deriveBits" | "deriveKey" | "encrypt" | "sign" | "unwrapKey" | "verify" | "wrapKey";
export interface CTAlgorithm {
    name: string;
}
export type CTAlgorithmIdentifier = CTAlgorithm | string;
export interface CTRsaHashedImportParams extends CTAlgorithm {
    hash: CTAlgorithmIdentifier;
}
export type CTNamedCurve = string;
export interface CTEcKeyImportParams extends CTAlgorithm {
    namedCurve: CTNamedCurve;
}
export interface CTHmacImportParams extends CTAlgorithm {
    hash: CTAlgorithmIdentifier;
    length?: number;
}
export interface CTAesKeyAlgorithm extends CTAlgorithm {
    length: number;
}
export type CTKeyType = "private" | "public" | "secret";
export interface CTCryptoKey {
    readonly algorithm: CTAlgorithm;
    readonly extractable: boolean;
    readonly type: CTKeyType;
    readonly usages: CTKeyUsage[];
}
interface CTArrayBufferTypes {
    ArrayBuffer: ArrayBuffer;
}
type CTArrayBufferLike = CTArrayBufferTypes[keyof CTArrayBufferTypes];
export interface CTArrayBufferView {
    buffer: CTArrayBufferLike;
    byteLength: number;
    byteOffset: number;
}
export type CTBufferSource = CTArrayBufferView | ArrayBuffer | Uint8Array;
export interface CryptoRuntime {
    importKey(format: CTKeyFormat, keyData: CTJsonWebKey | CTBufferSource, algorithm: CTAlgorithmIdentifier | CTRsaHashedImportParams | CTEcKeyImportParams | CTHmacImportParams | CTAesKeyAlgorithm, extractable: boolean, keyUsages: CTKeyUsage[]): Promise<CTCryptoKey>;
    exportKey(format: CTKeyFormat, key: CTCryptoKey): Promise<CTJsonWebKey | ArrayBuffer>;
    decrypt(algo: {
        name: string;
        iv: Uint8Array;
        tagLength: number;
    }, key: CTCryptoKey, data: Uint8Array): Promise<ArrayBuffer>;
    encrypt(algo: {
        name: string;
        iv: Uint8Array;
        tagLength: number;
    }, key: CTCryptoKey, data: Uint8Array): Promise<ArrayBuffer>;
    digestSHA256(data: Uint8Array): Promise<ArrayBuffer>;
    randomBytes(size: number): Uint8Array;
}
export declare function toCryptoRuntime(cryptoOpts?: Partial<CryptoRuntime>): CryptoRuntime;
export {};
//# sourceMappingURL=crypto.d.ts.map