import { Option } from "./option.js";
import { Result } from "./result.js";
import { TxtEnDecoder } from "./txt-en-decoder.js";
import { CoerceURI } from "./uri.js";
export declare const Level: {
    WARN: string;
    DEBUG: string;
    INFO: string;
    ERROR: string;
};
export type Level = (typeof Level)[keyof typeof Level];
export type Serialized = string | number | boolean;
export type FnSerialized = () => Serialized | Serialized[];
export declare class LogValue {
    readonly fn: FnSerialized;
    constructor(fn: FnSerialized);
    value(): Serialized | Serialized[];
    toJSON(): Serialized | Serialized[];
}
export type LogSerializable = Record<string, LogValue | Promise<LogValue>>;
export declare function asyncLogValue(val: () => Promise<Serialized>): Promise<LogValue>;
export type LogValueArg = LogValue | Serialized | Serialized[] | FnSerialized | undefined | null;
export interface LogValueState {
    readonly state?: Set<unknown>;
    readonly ignoreAttr: Option<RegExp>;
}
export declare function logValue(val: LogValueArg, ctx: LogValueState): LogValue;
export interface Sized {
    size: number;
}
export interface Lengthed {
    length: number;
}
export type SizeOrLength = Sized | Lengthed;
export interface LogFormatter {
    format(attr: LogSerializable): Uint8Array;
}
export interface LevelHandler {
    enableLevel(level: Level, ...modules: string[]): void;
    disableLevel(level: Level, ...modules: string[]): void;
    setExposeStack(enable?: boolean): void;
    setIgnoreAttr(re?: RegExp): void;
    ignoreAttr: Option<RegExp>;
    isStackExposed: boolean;
    setDebug(...modules: (string | string[])[]): void;
    isEnabled(ilevel: unknown, module: unknown): boolean;
}
export type HttpType = Response | Result<Response> | Request | Result<Request>;
export interface LoggerInterface<R> {
    readonly levelHandler: LevelHandler;
    TxtEnDe(): TxtEnDecoder;
    Module(key: string): R;
    EnableLevel(level: Level, ...modules: string[]): R;
    DisableLevel(level: Level, ...modules: string[]): R;
    Attributes(): Record<string, unknown>;
    SetDebug(...modules: (string | string[])[]): R;
    SetIgnoreAttribute(re?: RegExp): R;
    SetExposeStack(enable?: boolean): R;
    SetFormatter(fmt: LogFormatter): R;
    Ref(key: string, action: {
        toString: () => string;
    } | FnSerialized): R;
    Result<T>(key: string, res: Result<T>): R;
    Url(url: CoerceURI, key?: string): R;
    Len(value: unknown, key?: string): R;
    Hash(value: unknown, key?: string): R;
    Str<T extends string | Record<string, string>>(key: T, value?: T extends string ? string : undefined): R;
    Uint64<T extends string | Record<string, number>>(key: T, value?: T extends string ? number : undefined): R;
    Int<T extends string | Record<string, number>>(key: T, value?: T extends string ? number : undefined): R;
    Bool<T extends string | Record<string, unknown>>(key: T, value?: T extends string ? unknown : undefined): R;
    Any<T extends string | Record<string, unknown>>(key: T, value?: T extends string ? unknown : undefined): R;
    Http(...mix: (HttpType | string)[]): R;
    Pair(x: Record<string, unknown>): R;
    Error(): R;
    Warn(): R;
    Debug(): R;
    Log(): R;
    WithLevel(level: Level): R;
    Err<T>(err: T | Result<T> | Error): R;
    Info(): R;
    Timestamp(): R;
    Dur(key: string, nsec: number): R;
}
export declare function IsLogger(obj: unknown): obj is Logger;
export interface WithLogger extends LoggerInterface<WithLogger> {
    Logger(): Logger;
}
export interface AsError {
    AsError(): Error;
    ResultError<T>(): Result<T>;
}
export interface Logger extends LoggerInterface<Logger> {
    With(): WithLogger;
    Msg(...args: string[]): AsError;
    Flush(): Promise<void>;
}
//# sourceMappingURL=logger.d.ts.map