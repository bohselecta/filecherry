import { runtimeFn } from "@adviser/cement";
function exitHandler(errCode, larg, done) {
    return (err, stdout, stderr) => {
        if (err) {
            expect(err.code).toBe(errCode);
        }
        if (stdout) {
            const res = stdout
                .toString()
                .split("\n")
                .filter((line) => line.trim())
                .map((line) => {
                const out = JSON.parse(line);
                return out;
            })
                .map((obj) => {
                delete obj.pid;
                return obj;
            });
            expect(res).toEqual([
                {
                    larg: larg,
                },
                {
                    larg: larg,
                    msg: "Called OnExit 1",
                },
                {
                    larg: larg,
                    msg: "Called OnExit 2",
                },
            ]);
            done();
        }
        if (stderr) {
            expect(stderr).toEqual({});
        }
    };
}
describe("node_sys", () => {
    if (runtimeFn().isNodeIsh || runtimeFn().isDeno) {
        let fnExec;
        let execHandler = "tsx src/test/test-exit-handler.ts";
        beforeAll(async () => {
            const { exec } = await import("node:child_process");
            fnExec = exec;
            if (runtimeFn().isDeno) {
                execHandler = "deno run --allow-net --allow-read --allow-run --unstable-sloppy-imports src/test/test-exit-handler.ts";
            }
        });
        it("just-exit", () => {
            return new Promise((done) => {
                fnExec(`${execHandler}  exit24`, exitHandler(24, "exit24", done));
            });
        });
        it("throw", () => {
            return new Promise((done) => {
                fnExec(`${execHandler}  throw`, exitHandler(19, "throw", done));
            });
        });
        it("via sigint", () => {
            return new Promise((done) => {
                fnExec(`${execHandler}  sigint`, exitHandler(2, "sigint", done));
            });
        });
        it("via sigterm", () => {
            return new Promise((done) => {
                fnExec(`${execHandler}  sigterm`, exitHandler(9, "sigterm", done));
            });
        });
        it("via sigquit", () => {
            return new Promise((done) => {
                fnExec(`${execHandler}  sigquit`, exitHandler(3, "sigquit", done));
            });
        });
    }
    else {
        it.skip("nothing in browser", () => {
            expect(true).toBe(true);
        });
    }
});
//# sourceMappingURL=node-sys-abstraction.test.js.map