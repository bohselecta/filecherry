import { Time } from "./time.js";
import { Logger } from "./logger.js";
export type TraceCtx = {
    readonly spanId: string;
    readonly time: Time;
    readonly parent: TraceNode;
    readonly metrics: Map<string, Metric<unknown>>;
    readonly logger?: Logger;
} & Record<string, unknown>;
export type CleanCtx = {
    readonly spanId: string;
} & Record<string, unknown>;
export type TraceCtxParam = {
    readonly spanId: string;
} & Partial<{
    readonly time: Time;
    readonly parent: TraceNode;
    readonly logger: Logger;
}> & Record<string, unknown>;
export declare class Metric<T> {
    value?: T;
    readonly path: string;
    constructor(path: string);
    set(value: T): void;
    add<R extends number | ArrayLike<T>>(value: R): void;
}
export type MetricMap = Map<string, Metric<unknown>>;
export declare class Metrics {
    readonly tracenode: TraceNode;
    private readonly map;
    readonly spanRefs: MetricMap;
    constructor(tracenode: TraceNode);
    toJSON(): Record<string, unknown>;
    get<T>(ipath: string): Metric<T>;
}
export interface Invokaction {
    readonly result: "success" | "error";
    readonly start: number;
    readonly end: number;
    readonly metrics?: Metrics;
}
export type TraceNodeMap = Map<string, TraceNode>;
export declare class TraceNode {
    readonly childs: TraceNodeMap;
    readonly invokations: Invokaction[];
    readonly spanId: string;
    readonly ctx: TraceCtx;
    readonly metrics: Metrics;
    static root(time: Time, logger?: Logger): TraceNode;
    constructor(ctx: TraceCtx);
    getRootPath(rpath?: string[]): string;
    invokes(): {
        ctx: CleanCtx;
        invokations: Invokaction[];
    };
    ctxWith(spanId: string, logger?: Logger): TraceCtxParam;
    span<V extends (trace: TraceNode) => Promise<T> | T, T>(inSpanId: string | TraceCtxParam, fn: V): ReturnType<V>;
}
//# sourceMappingURL=tracer.d.ts.map