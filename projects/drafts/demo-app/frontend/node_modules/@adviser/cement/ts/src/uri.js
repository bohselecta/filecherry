import { exception2Result, Result } from "./result.js";
import { getParamsResult } from "./utils/get-params-result.js";
import { relativePath } from "./utils/relative-path.js";
import { stripper } from "./utils/stripper.js";
function match(iref, ioth) {
    const mr = {
        score: 0,
        protocol: false,
        hostname: false,
        port: false,
        pathname: false,
        pathParts: [],
        params: {},
    };
    const ref = URI.from(iref);
    const oth = URI.from(ioth);
    if (ref.protocol === oth.protocol) {
        mr.score += 1;
        mr.protocol = true;
    }
    try {
        const refH = ref.hostname;
        const refP = ref.port;
        if (refH === oth.hostname) {
            mr.score += 1;
            mr.hostname = true;
        }
        if (refP.length && refP === oth.port) {
            mr.score += 1;
            mr.port = true;
        }
    }
    catch (e) {
    }
    if (ref.pathname.length && ref.pathname !== "/") {
        const pref = ref.pathname.split("/").filter((p) => p.length);
        const poth = oth.pathname.split("/").filter((p) => p.length);
        for (let i = 0; i < pref.length && i < poth.length; i++) {
            if (poth[i] === pref[i]) {
                mr.score += 1;
                mr.pathname = true;
                mr.pathParts.push(pref[i]);
            }
        }
    }
    for (const [key, value] of ref.getParams) {
        if (oth.getParam(key) === value) {
            mr.score += 1;
            mr.params[key] = value;
        }
    }
    return mr;
}
function coerceKey(key, def) {
    if (typeof key === "object") {
        const keys = Object.keys(key);
        if (keys.length !== 1) {
            throw new Error(`Invalid key: ${JSON.stringify(key)}`);
        }
        return { key: keys[0], def: key[keys[0]] };
    }
    return { key, def: def };
}
function falsy2undef(value) {
    return value === undefined || value === null ? undefined : value;
}
function ensureURLWithDefaultProto(url, defaultProtocol) {
    if (!url) {
        return new MutableURL(`${defaultProtocol}//`);
    }
    if (typeof url === "string") {
        try {
            return new MutableURL(url);
        }
        catch (e) {
            return new MutableURL(`${defaultProtocol}//${url}`);
        }
    }
    else {
        return new MutableURL(url.toString());
    }
}
export function isURL(value) {
    return (value instanceof URL ||
        (!!value &&
            typeof value.searchParams === "object" &&
            typeof value.searchParams.sort === "function" &&
            typeof value.hash === "string"));
}
export class MutableURL extends URL {
    constructor(urlStr) {
        super("defect://does.not.exist");
        const partedURL = urlStr.split(":");
        this._hasHostpart = hasHostPartProtocols.has(partedURL[0]);
        let hostPartUrl = ["http", ...partedURL.slice(1)].join(":");
        if (!this._hasHostpart) {
            const pathname = hostPartUrl.replace(/http:\/\/[/]*/, "").replace(/[#?].*$/, "");
            hostPartUrl = hostPartUrl.replace(/http:\/\//, `http://localhost/${pathname}`);
        }
        try {
            this._sysURL = new URL(hostPartUrl);
        }
        catch (ie) {
            const e = ie;
            e.message = `${e.message} for URL: ${urlStr}`;
            throw e;
        }
        this._protocol = `${partedURL[0]}:`;
        if (this._hasHostpart) {
            this._pathname = this._sysURL.pathname;
        }
        else {
            this._pathname = urlStr.replace(new RegExp(`^${this._protocol}//`), "").replace(/[#?].*$/, "");
        }
        this.hash = this._sysURL.hash;
    }
    clone() {
        return new MutableURL(this.toString());
    }
    get host() {
        if (!this._hasHostpart) {
            throw new Error(`you can use hostname only if protocol is ${this.toString()} ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
        }
        return this._sysURL.host;
    }
    get port() {
        if (!this._hasHostpart) {
            throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
        }
        return this._sysURL.port;
    }
    set port(p) {
        if (!this._hasHostpart) {
            throw new Error(`you can use port only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
        }
        this._sysURL.port = p;
    }
    get hostname() {
        if (!this._hasHostpart) {
            throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
        }
        return this._sysURL.hostname;
    }
    set hostname(h) {
        if (!this._hasHostpart) {
            throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
        }
        this._sysURL.hostname = h;
    }
    set pathname(p) {
        this._pathname = p;
    }
    get pathname() {
        return this._pathname;
    }
    get protocol() {
        return this._protocol;
    }
    set protocol(p) {
        if (!p.endsWith(":")) {
            p = `${p}:`;
        }
        this._protocol = p;
    }
    get searchParams() {
        return this._sysURL.searchParams;
    }
    toString() {
        let search = "";
        if (this._sysURL.searchParams.size) {
            for (const [key, value] of Array.from(this._sysURL.searchParams.entries()).sort((a, b) => a[0].localeCompare(b[0]))) {
                search += `${!search.length ? "?" : "&"}${key}=${encodeURIComponent(value)}`;
            }
        }
        let hostpart = "";
        if (this._hasHostpart) {
            hostpart = this._sysURL.hostname;
            if (this._sysURL.port) {
                hostpart += `:${this._sysURL.port}`;
            }
            if (!this._pathname.startsWith("/")) {
                hostpart += "/";
            }
        }
        return `${this._protocol}//${hostpart}${this._pathname}${search}`;
    }
}
function from(fac, strURLUri, defaultProtocol) {
    switch (typeof falsy2undef(strURLUri)) {
        case "undefined":
            return fac(new MutableURL(`${defaultProtocol}///`));
        case "string":
            return fac(ensureURLWithDefaultProto(strURLUri, defaultProtocol));
        case "object":
            if (BuildURI.is(strURLUri)) {
                return fac(new MutableURL(strURLUri._url.toString()));
            }
            else if (URI.is(strURLUri)) {
                return fac(new MutableURL(strURLUri._url.toString()));
            }
            else if (isURL(strURLUri)) {
                return fac(new MutableURL(strURLUri.toString()));
            }
            throw new Error(`unknown object type: ${strURLUri}`);
        default:
            throw new Error(`Invalid argument: ${typeof strURLUri}`);
    }
}
function getParamResult(key, val, msgFn = (key) => {
    return `missing parameter: ${key}`;
}) {
    if (val === undefined) {
        return Result.Err(msgFn(key));
    }
    return Result.Ok(val);
}
export class BuildURI {
    constructor(url) {
        this._url = url;
    }
    static is(value) {
        return (value instanceof BuildURI ||
            (!!value && typeof value.delParam === "function" && typeof value.setParam === "function"));
    }
    static from(strURLUri, defaultProtocol = "file:") {
        return from((url) => new BuildURI(url), strURLUri, defaultProtocol);
    }
    match(other) {
        return match(this.URI(), URI.from(other));
    }
    port(p) {
        this._url.port = p;
        return this;
    }
    hostname(h) {
        this._url.hostname = h;
        return this;
    }
    protocol(p) {
        if (!p.endsWith(":")) {
            p = `${p}:`;
        }
        this._url.protocol = p;
        return this;
    }
    pathname(p) {
        this._url.pathname = p;
        return this;
    }
    resolve(p) {
        if (!p) {
            return this;
        }
        if (typeof p === "string") {
            if (!p.match(/^[a-zA-Z0-9]+:/)) {
                if (p.startsWith("/")) {
                    this.pathname(p);
                    return this;
                }
                return this.appendRelative(p);
            }
        }
        this._url = new MutableURL(p.toString());
        return this;
    }
    appendRelative(p) {
        const appendUrl = URI.from(p);
        const pathname = "./" + appendUrl.pathname;
        const basePath = this._url.pathname;
        this.pathname(relativePath(basePath, pathname));
        for (const [key, value] of appendUrl.getParams) {
            this.setParam(key, value);
        }
        return this;
    }
    cleanParams() {
        for (const key of Array.from(this._url.searchParams.keys())) {
            this._url.searchParams.delete(key);
        }
        return this;
    }
    delParam(key) {
        this._url.searchParams.delete(key);
        return this;
    }
    defParam(key, str) {
        if (!this._url.searchParams.has(key)) {
            this._url.searchParams.set(key, str);
        }
        return this;
    }
    setParam(key, str) {
        this._url.searchParams.set(key, str);
        return this;
    }
    hasParam(key) {
        return this._url.searchParams.has(key);
    }
    get getParams() {
        return this._url.searchParams.entries();
    }
    getParam(key, def) {
        const { key: k, def: d } = coerceKey(key, def);
        let val = this._url.searchParams.get(k);
        if (!falsy2undef(val) && d) {
            val = d;
        }
        return falsy2undef(val);
    }
    getParamResult(key, msgFn) {
        return getParamResult(key, this.getParam(key), msgFn);
    }
    getParamsResult(...keys) {
        return getParamsResult(keys, this);
    }
    toString() {
        this._url.searchParams.sort();
        return this._url.toString();
    }
    toJSON() {
        return this.toString();
    }
    asURL() {
        return this.URI().asURL();
    }
    asObj(...strips) {
        return this.URI().asObj(...strips);
    }
    clone() {
        return BuildURI.from(this.toString());
    }
    URI() {
        return URI.from(this._url);
    }
}
export function isCoerceURI(value) {
    if (!value) {
        return false;
    }
    if (isURL(value)) {
        return true;
    }
    if (URI.is(value)) {
        return true;
    }
    if (BuildURI.is(value)) {
        return true;
    }
    if (typeof value === "string") {
        return true;
    }
    return false;
}
export const hasHostPartProtocols = new Set(["http", "https", "ws", "wss"]);
export class URI {
    static protocolHasHostpart(protocol) {
        protocol = protocol.replace(/:$/, "");
        hasHostPartProtocols.add(protocol);
        return () => {
            hasHostPartProtocols.delete(protocol);
        };
    }
    match(other) {
        return match(this, other);
    }
    static merge(into, from, defaultProtocol = "file:") {
        const intoUrl = BuildURI.from(into, defaultProtocol);
        const fromUrl = URI.from(from, defaultProtocol);
        intoUrl.protocol(fromUrl.protocol);
        const fPath = fromUrl.pathname;
        if (!(fPath.length === 0 || fPath === "/" || fPath === "./")) {
            intoUrl.pathname(fromUrl.pathname);
        }
        for (const [key, value] of fromUrl.getParams) {
            intoUrl.setParam(key, value);
        }
        return intoUrl.URI();
    }
    static is(value) {
        return (value instanceof URI ||
            (!!value &&
                typeof value.asURL === "function" &&
                typeof value.getParam === "function" &&
                typeof value.hasParam === "function"));
    }
    static from(strURLUri, defaultProtocol = "file:") {
        return from((url) => new URI(url), strURLUri, defaultProtocol);
    }
    static fromResult(strURLUri, defaultProtocol = "file:") {
        return exception2Result(() => from((url) => new URI(url), strURLUri, defaultProtocol));
    }
    constructor(url) {
        this._url = url.clone();
    }
    build() {
        return BuildURI.from(this._url);
    }
    get hostname() {
        return this._url.hostname;
    }
    get port() {
        return this._url.port;
    }
    get host() {
        return this._url.host;
    }
    get protocol() {
        return this._url.protocol;
    }
    get pathname() {
        return this._url.pathname;
    }
    get getParams() {
        return this._url.searchParams.entries();
    }
    hasParam(key) {
        return this._url.searchParams.has(key);
    }
    getParam(key, def) {
        const { key: k, def: d } = coerceKey(key, def);
        let val = this._url.searchParams.get(k);
        if (!falsy2undef(val) && d) {
            val = d;
        }
        return falsy2undef(val);
    }
    getParamResult(key, msgFn) {
        return getParamResult(key, this.getParam(key), msgFn);
    }
    getParamsResult(...keys) {
        return getParamsResult(keys, this);
    }
    clone() {
        return new URI(this._url);
    }
    asURL() {
        return this._url.clone();
    }
    toString() {
        return this._url.toString();
    }
    toJSON() {
        return this.toString();
    }
    asObj(...strips) {
        const pathURI = {
            style: "path",
            protocol: this.protocol,
            pathname: this.pathname,
            searchParams: Object.fromEntries(this.getParams),
        };
        if (hasHostPartProtocols.has(this.protocol.replace(/:$/, ""))) {
            return stripper(strips, {
                ...pathURI,
                style: "host",
                hostname: this.hostname,
                port: this.port,
            });
        }
        return stripper(strips, pathURI);
    }
}
//# sourceMappingURL=uri.js.map