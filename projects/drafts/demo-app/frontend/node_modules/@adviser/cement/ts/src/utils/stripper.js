export function stripper(strip, obj) {
    const strips = Array.isArray(strip) ? strip : [strip];
    const restrips = strips.map((s) => {
        if (typeof s === "string") {
            const escaped = s.replace(/[-\\[\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\^\\$\\|]/g, "\\$&");
            return new RegExp(`^${escaped}$`);
        }
        return s;
    });
    return localStripper(undefined, restrips, obj);
}
function localStripper(path, restrips, obj) {
    if (typeof obj !== "object" || obj === null) {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.map((i) => localStripper(path, restrips, i));
    }
    const ret = { ...obj };
    const matcher = (key, nextPath) => {
        for (const re of restrips) {
            if (re.test(key) || re.test(nextPath)) {
                return true;
            }
        }
        return false;
    };
    for (const key in ret) {
        if (Object.prototype.hasOwnProperty.call(ret, key)) {
            let nextPath;
            if (path) {
                nextPath = [path, key].join(".");
            }
            else {
                nextPath = key;
            }
            if (matcher(key, nextPath)) {
                delete ret[key];
                continue;
            }
            if (typeof ret[key] === "object") {
                if (Array.isArray(ret[key])) {
                    ret[key] = ret[key].reduce((acc, v, i) => {
                        const toDelete = matcher(key, `${nextPath}[${i}]`);
                        if (!toDelete) {
                            acc.push(localStripper(`${nextPath}[${i}]`, restrips, v));
                        }
                        return acc;
                    }, []);
                }
                else {
                    ret[key] = localStripper(nextPath, restrips, ret[key]);
                }
            }
        }
    }
    return ret;
}
//# sourceMappingURL=stripper.js.map