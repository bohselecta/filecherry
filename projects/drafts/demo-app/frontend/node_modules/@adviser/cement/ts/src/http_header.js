export class HeadersImpl extends Headers {
    constructor(init) {
        super();
        this._headers = init;
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    entries() {
        return this._headers.entries();
    }
    keys() {
        return this._headers.keys();
    }
    values() {
        return this._headers.values();
    }
    append(key, value) {
        const values = this._headers.get(key);
        if (typeof value === "undefined") {
            value = "";
        }
        if (Array.isArray(value)) {
            this._headers.set(key, [values, ...value].filter((i) => i).join(", "));
        }
        else {
            this._headers.set(key, [values, value].filter((i) => i).join(", "));
        }
        return this;
    }
}
export class HttpHeader {
    constructor() {
        this._headers = new Map();
    }
    static from(headers) {
        if (headers instanceof HttpHeader) {
            return headers.Clone();
        }
        const h = new HttpHeader();
        if (headers) {
            if (Array.isArray(headers)) {
                for (const [k, v] of headers) {
                    if (v) {
                        h.Add(k, v);
                    }
                }
            }
            else if (headers instanceof Headers) {
                for (const [k, v] of headers.entries()) {
                    if (v) {
                        h.Add(k, v.split(",").map((v) => v.trim()));
                    }
                }
            }
            else {
                for (const k in headers) {
                    const v = headers[k];
                    (Array.isArray(v) ? v : [v]).forEach((v) => {
                        h.Add(k, v);
                    });
                }
            }
        }
        return h;
    }
    _asStringString() {
        const ret = new Map();
        for (const [key, values] of this._headers) {
            ret.set(key, values.join(", "));
        }
        return ret;
    }
    _key(key) {
        return key.toLowerCase();
    }
    Values(key) {
        const values = this._headers.get(this._key(key));
        return values || [];
    }
    Get(key) {
        const values = this._headers.get(this._key(key));
        if (values === undefined || values.length === 0) {
            return undefined;
        }
        return values[0];
    }
    Set(key, valueOr) {
        const value = Array.isArray(valueOr) ? valueOr : [valueOr];
        this._headers.set(this._key(key), value);
        return this;
    }
    Add(key, value) {
        if (typeof value === "undefined") {
            return this;
        }
        const vs = Array.isArray(value) ? value : [value];
        const values = this._headers.get(this._key(key));
        if (values === undefined) {
            this._headers.set(this._key(key), vs);
        }
        else {
            values.push(...vs);
        }
        return this;
    }
    Del(ey) {
        this._headers.delete(this._key(ey));
        return this;
    }
    Items() {
        return Array.from(this._headers).filter(([_, vs]) => vs.length > 0);
    }
    SortItems() {
        return this.Items().sort(([[a]], [[b]]) => a.localeCompare(b));
    }
    Clone() {
        const clone = new HttpHeader();
        for (const [key, values] of this._headers.entries()) {
            clone._headers.set(key, values.slice());
        }
        return clone;
    }
    AsRecordStringStringArray() {
        const obj = {};
        for (const [key, values] of this._headers.entries()) {
            obj[key] = [...values];
        }
        return obj;
    }
    AsRecordStringString() {
        const obj = {};
        for (const [key, values] of this._headers.entries()) {
            obj[key] = values.join(", ");
        }
        return obj;
    }
    AsHeaderInit() {
        const obj = {};
        for (const [key, values] of this._headers.entries()) {
            obj[key] = values[0];
        }
        return obj;
    }
    AsHeaders() {
        return new HeadersImpl(this._asStringString());
    }
    Merge(other) {
        const ret = this.Clone();
        if (other) {
            for (const [key, values] of other.Items()) {
                ret.Add(key, values);
            }
        }
        return ret;
    }
}
//# sourceMappingURL=http_header.js.map