var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
import { EnvImpl, envFactory, registerEnvAction, runtimeFn, param } from "@adviser/cement";
import { CFEnvActions } from "./cf/cf-env-actions.js";
import { BrowserEnvActions } from "./web/web-env-actions.js";
describe("sys_env", () => {
    let key;
    const envImpl = envFactory();
    beforeEach(() => {
        key = `key-${Math.random()}`;
    });
    it("actions", () => {
        expect(envImpl.get(key)).toBeUndefined();
        envImpl.set(key, "value");
        expect(envImpl.get(key)).toBe("value");
        envImpl.set(key);
        expect(envImpl.get(key)).toBe("value");
        envImpl.delete(key);
        expect(envImpl.get(key)).toBeUndefined();
    });
    it("preset", () => {
        const env = new EnvImpl(BrowserEnvActions.new({}), {
            presetEnv: new Map([[key, "value"]]),
        });
        expect(env.get(key)).toBe("value");
        env.delete(key);
        expect(env.get(key)).toBeUndefined();
    });
    it("onSet wild card", () => {
        const fn = vi.fn();
        envImpl.onSet(fn);
        expect(fn).toBeCalledTimes(envImpl.keys().length);
        expect(fn.mock.calls.map((i) => i[0]).sort()).toEqual(envImpl.keys().sort());
        expect(fn.mock.calls.map((i) => i[1]).sort()).toEqual(envImpl
            .keys()
            .map((i) => envImpl.get(i))
            .sort());
    });
    it("onSet filter", () => {
        const env = new EnvImpl(BrowserEnvActions.new({}), {
            presetEnv: new Map([[key, "value"]]),
        });
        const fn = vi.fn();
        env.onSet(fn, key);
        expect(fn).toBeCalledTimes(1);
        expect(fn.mock.calls[0]).toEqual([key, "value"]);
        env.set(key, "value2");
        expect(fn).toBeCalledTimes(2);
        expect(fn.mock.calls[1]).toEqual([key, "value2"]);
        env.delete(key);
        expect(fn).toBeCalledTimes(3);
        expect(fn.mock.calls[2]).toEqual([key, undefined]);
    });
    it("test register", () => {
        var _TestEnvActions_map;
        class TestEnvActions {
            constructor(opts) {
                _TestEnvActions_map.set(this, void 0);
                __classPrivateFieldSet(this, _TestEnvActions_map, opts.presetEnv || new Map(), "f");
            }
            register(env) {
                return env;
            }
            active() {
                return true;
            }
            keys() {
                return Array.from(__classPrivateFieldGet(this, _TestEnvActions_map, "f").keys());
            }
            get(key) {
                return __classPrivateFieldGet(this, _TestEnvActions_map, "f").get(key);
            }
            set(key, value) {
                if (value) {
                    __classPrivateFieldGet(this, _TestEnvActions_map, "f").set(key, value);
                }
            }
            delete(key) {
                __classPrivateFieldGet(this, _TestEnvActions_map, "f").delete(key);
            }
        }
        _TestEnvActions_map = new WeakMap();
        let tea = {};
        const unreg = registerEnvAction((opts) => {
            tea = new TestEnvActions(opts);
            return tea;
        });
        const env = envFactory({
            presetEnv: new Map([[key, "value"]]),
        });
        expect(env.get(key)).toBe("value");
        expect(tea.get(key)).toBe("value");
        unreg();
    });
    if (runtimeFn().isCFWorker) {
        it("CFWorker env", () => {
            const env = envFactory();
            const onSet = vi.fn();
            env.onSet(onSet);
            CFEnvActions.inject({ "cf-key": "cf-value" });
            env.set("cf-key-1", "cf-value-2");
            expect(onSet).toBeCalledWith("cf-key", "cf-value");
            expect(env.get("cf-key")).toBe("cf-value");
        });
    }
    it("gets ok", () => {
        const res0 = envImpl.gets({ key: param.REQUIRED });
        expect(res0.isErr()).toBeTruthy();
        envImpl.set("key", "value");
        const res = envImpl.gets({ key: param.REQUIRED });
        expect(res.isOk()).toBeTruthy();
        expect(res.unwrap()).toEqual({ key: "value" });
    });
    it("gets error", () => {
        envImpl.set("key", "value");
        const res = envImpl.gets({
            unk1: param.REQUIRED,
            unk2: param.REQUIRED,
            key: param.REQUIRED,
        });
        expect(res.isErr()).toBeTruthy();
        expect(res.Err().message).toEqual("missing parameters: unk1,unk2");
    });
    it("sets array flat tuple", () => {
        envImpl.sets(["key1", "value1"], ["key2", "value2"]);
        expect(envImpl.get("key1")).toBe("value1");
        expect(envImpl.get("key2")).toBe("value2");
    });
    it("sets array array tuple", () => {
        envImpl.sets([
            ["key1", "value1"],
            ["key2", "value2"],
        ]);
        expect(envImpl.get("key1")).toBe("value1");
        expect(envImpl.get("key2")).toBe("value2");
    });
    it("sets object", () => {
        envImpl.sets({
            key1: "value1",
            key2: "value2",
        });
        expect(envImpl.get("key1")).toBe("value1");
        expect(envImpl.get("key2")).toBe("value2");
    });
    it("sets iterator", () => {
        envImpl.sets(new Map(Object.entries({
            key1: "value1",
            key2: "value2",
        })).entries());
        expect(envImpl.get("key1")).toBe("value1");
        expect(envImpl.get("key2")).toBe("value2");
    });
    it("sets combination", () => {
        envImpl.sets(new Map(Object.entries({
            key1: "value1",
            key2: "value2",
        })).entries(), {
            key3: "value3",
            key4: "value4",
        }, ["key5", "value5"], ["key6", "value6"], [
            ["key7", "value7"],
            ["key8", "value8"],
        ]);
        expect(envImpl.get("key1")).toBe("value1");
        expect(envImpl.get("key2")).toBe("value2");
        expect(envImpl.get("key3")).toBe("value3");
        expect(envImpl.get("key4")).toBe("value4");
        expect(envImpl.get("key5")).toBe("value5");
        expect(envImpl.get("key6")).toBe("value6");
        expect(envImpl.get("key7")).toBe("value7");
        expect(envImpl.get("key8")).toBe("value8");
    });
});
//# sourceMappingURL=sys-env.test.js.map