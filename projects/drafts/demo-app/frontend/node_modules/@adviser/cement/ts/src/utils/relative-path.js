export const PartType = {
    Slash: 0x1,
    Root: 0x3,
    Up: 0x4,
    Noop: 0x8,
};
export class Path {
    constructor(parts = []) {
        this.parts = parts;
    }
    toString() {
        return this.parts
            .map((part) => {
            if (typeof part === "string") {
                return part;
            }
            else {
                switch (part) {
                    case PartType.Slash:
                    case PartType.Root:
                        return "/";
                    case PartType.Up:
                        return "..";
                    default:
                        return part;
                }
            }
        })
            .join("");
    }
    add(part) {
        if (this.parts.includes(PartType.Root) && part === PartType.Root) {
            throw new Error("Cannot add absolute part to absolute path");
        }
        const last = this.parts[this.parts.length - 1];
        if (last & PartType.Slash && part === PartType.Slash) {
            return;
        }
        switch (part) {
            case ".":
                this.parts.push(PartType.Noop);
                return;
            case "..":
                part = PartType.Up;
        }
        if (last === PartType.Noop && part === PartType.Slash) {
            if (last === PartType.Noop) {
                this.parts.pop();
            }
            return;
        }
        this.parts.push(part);
    }
}
export function splitPath(path) {
    const p = new Path();
    if (path === "") {
        return p;
    }
    for (let count = 0; path.length; count++) {
        if (path.match(/^\/+/)) {
            if (count === 0) {
                p.add(PartType.Root);
            }
            else {
                p.add(PartType.Slash);
            }
            path = path.replace(/^\/+/, "");
        }
        else {
            const part = path.replace(/\/.*$/, "");
            p.add(part);
            path = path.replace(/^[^/]+/, "");
        }
    }
    return p;
}
export function pathJoin(...paths) {
    let prev = "";
    const res = [];
    for (let i = 0; i < paths.length; i++) {
        const path = paths[i];
        if (path === "") {
            continue;
        }
        if (!(prev.endsWith("/") || path.startsWith("/"))) {
            if (prev !== "") {
                res.push("/");
            }
            res.push(path);
        }
        else {
            res.push(path);
        }
        prev = path;
    }
    return res.join("");
}
export function relativePath(path, relative) {
    const relativeParts = splitPath(relative);
    let result;
    if (relativeParts.parts[0] === PartType.Root) {
        result = relative;
    }
    else {
        result = pathJoin(path, relative);
    }
    const unoptPath = splitPath(result);
    const out = [];
    let topUp = false;
    for (const part of unoptPath.parts) {
        switch (part) {
            case PartType.Root:
                out.push(PartType.Root);
                break;
            case PartType.Up:
                if (out.length && !topUp) {
                    const last = out.length - 1;
                    if (typeof out[last] === "string" && out[last - 1] == PartType.Root) {
                        out.pop();
                    }
                    else {
                        out.pop();
                        out.pop();
                    }
                    if (out.length === 0) {
                        topUp = !topUp ? true : topUp;
                        out.push(PartType.Up);
                    }
                }
                else {
                    out.push(PartType.Up);
                }
                break;
            case PartType.Slash:
                if (!(out[out.length - 1] & PartType.Slash)) {
                    out.push(PartType.Slash);
                }
                break;
            default:
                out.push(part);
                break;
        }
    }
    return new Path(out).toString();
}
//# sourceMappingURL=relative-path.js.map