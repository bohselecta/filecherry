export declare abstract class Result<T, E = Error> {
    static Ok<T = void>(t: T): Result<T, Error>;
    static Err<T, E extends Error = Error>(t: E | string | Result<unknown, E>): Result<T, E>;
    static Is<T>(t: unknown): t is Result<T>;
    isOk(): boolean;
    isErr(): boolean;
    Ok(): T;
    Err(): E;
    abstract is_ok(): boolean;
    abstract is_err(): boolean;
    abstract unwrap(): T;
    abstract unwrap_err(): E;
}
export declare class ResultOK<T> extends Result<T, Error> {
    private _t;
    constructor(t: T);
    is_ok(): boolean;
    is_err(): boolean;
    unwrap_err(): Error;
    unwrap(): T;
}
export declare class ResultError<T extends Error> extends Result<never, T> {
    private _error;
    constructor(t: T);
    is_ok(): boolean;
    is_err(): boolean;
    unwrap(): never;
    unwrap_err(): T;
}
export type WithoutResult<T> = T extends Result<infer U> ? U : T;
type WithResult<T> = T extends Promise<infer U> ? Promise<Result<U>> : Result<T>;
export declare function exception2Result<FN extends () => Promise<T> | T, T>(fn: FN): WithResult<ReturnType<FN>>;
export {};
//# sourceMappingURL=result.d.ts.map