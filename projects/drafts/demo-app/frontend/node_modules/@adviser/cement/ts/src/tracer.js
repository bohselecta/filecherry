export class Metric {
    constructor(path) {
        this.path = path;
    }
    set(value) {
        this.value = value;
    }
    add(value) {
        if (typeof value === "number") {
            if (this.value === undefined) {
                this.value = 0;
            }
            this.value = (this.value + value);
        }
        else if (Array.isArray(value)) {
            if (!Array.isArray(this.value)) {
                this.value = [];
            }
            this.value.push(...value);
        }
        else {
            throw new Error("add only support number or array");
        }
    }
}
export class Metrics {
    constructor(tracenode) {
        this.spanRefs = new Map();
        this.tracenode = tracenode;
        this.map = tracenode.ctx.metrics;
    }
    toJSON() {
        const obj = {};
        for (const [key, value] of this.map) {
            obj[key] = value.value;
        }
        return obj;
    }
    get(ipath) {
        const path = ipath.replace(/[/]+/g, "/").trim();
        if (path.startsWith("/")) {
            if (path.slice(1).length === 0) {
                throw new Error(`Metrics path must contain value /:${path}`);
            }
            let metric = this.map.get(path);
            if (!metric) {
                metric = new Metric(path);
                this.map.set(path, metric);
            }
            this.spanRefs.set(path, metric);
            return metric;
        }
        else if (path.includes("/")) {
            throw new Error(`Metrics path must start with /:${path}`);
        }
        const rootPath = this.tracenode.getRootPath();
        return this.get(`${rootPath}/${path}`);
    }
}
export class TraceNode {
    static root(time, logger) {
        return new TraceNode({
            spanId: "root",
            time,
            logger,
            metrics: new Map(),
            parent: undefined,
        });
    }
    constructor(ctx) {
        this.childs = new Map();
        this.invokations = [];
        this.spanId = ctx.spanId;
        this.ctx = ctx;
        this.metrics = new Metrics(this);
    }
    getRootPath(rpath = []) {
        if (!this.ctx.parent) {
            return "/" + rpath.reverse().join("/");
        }
        return this.ctx.parent.getRootPath(rpath.concat(this.ctx.spanId));
    }
    invokes() {
        const cleanCtx = { ...this.ctx };
        delete cleanCtx.parent;
        delete cleanCtx.time;
        delete cleanCtx.logger;
        delete cleanCtx.metrics;
        const spanRefs = this.metrics.toJSON.call({ map: this.metrics.spanRefs });
        const metricsRefs = Object.keys(spanRefs).length > 0 ? { metricRefs: spanRefs } : {};
        return {
            ctx: cleanCtx,
            invokations: this.invokations,
            ...metricsRefs,
        };
    }
    ctxWith(spanId, logger) {
        const ctx = {
            ...this.ctx,
            spanId,
        };
        if (logger) {
            ctx.logger = logger;
        }
        return ctx;
    }
    span(inSpanId, fn) {
        let ctx;
        if (typeof inSpanId === "string") {
            ctx = {
                ...this.ctx,
                spanId: inSpanId,
                parent: this,
            };
        }
        else {
            ctx = {
                ...this.ctx,
                ...inSpanId,
                parent: this,
            };
        }
        if (ctx.logger) {
            ctx = {
                ...ctx,
                ...ctx.logger.Attributes(),
            };
        }
        const spanId = ctx.spanId;
        let spanTrace = this.childs.get(spanId);
        if (!spanTrace) {
            spanTrace = new TraceNode(ctx);
            this.childs.set(spanId.toString(), spanTrace);
        }
        const invokation = {
            start: this.ctx.time.Now().getTime(),
            end: 0,
            result: "success",
        };
        spanTrace.invokations.push(invokation);
        try {
            const possiblePromise = fn(spanTrace);
            if (possiblePromise instanceof Promise) {
                return possiblePromise
                    .then((v) => {
                    return v;
                })
                    .catch((e) => {
                    invokation.result = "error";
                    throw e;
                })
                    .finally(() => {
                    invokation.end = this.ctx.time.Now().getTime();
                });
            }
            invokation.end = this.ctx.time.Now().getTime();
            return possiblePromise;
        }
        catch (e) {
            invokation.result = "error";
            invokation.end = this.ctx.time.Now().getTime();
            throw e;
        }
    }
}
//# sourceMappingURL=tracer.js.map