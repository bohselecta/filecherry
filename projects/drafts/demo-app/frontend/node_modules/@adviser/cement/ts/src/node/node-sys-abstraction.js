import { BaseSysAbstraction, WrapperSysAbstraction, } from "../base-sys-abstraction.js";
import { NodeFileService } from "./node-file-service.js";
import { envFactory } from "../sys-env.js";
import { TxtEnDecoderSingleton } from "../txt-en-decoder.js";
import process from "node:process";
export class NodeExitServiceImpl {
    constructor() {
        this._exitHandlers = [];
        this.invoked = false;
        this._handleExit = async () => {
            if (this.invoked) {
                return;
            }
            this.invoked = true;
            for (const h of this._exitHandlers) {
                try {
                    const ret = h.hdl();
                    if (typeof ret.then === "function") {
                        await ret;
                    }
                }
                finally {
                }
            }
        };
        process.on("unhandledRejection", (reason, p) => {
            this.exit(19);
        });
        process.on("uncaughtException", (error) => {
            this.exit(18);
        });
        process.on("close", () => {
            this.exit(0);
        });
        process.on("exit", () => {
            this.exit(0);
        });
        process.on("SIGQUIT", () => {
            this.exit(3);
        });
        process.on("SIGINT", () => {
            this.exit(2);
        });
        process.on("SIGTERM", () => {
            this.exit(9);
        });
    }
    injectExitHandlers(hdls) {
        this._exitHandlers = hdls;
    }
    exit(code) {
        this._handleExit()
            .then(() => {
            process.exit(code);
        })
            .catch((err) => {
            console.error("ExitService: failed to handle exit", err);
            process.exit(code);
        });
    }
}
export class NodeSystemService {
    constructor() {
        this._exitService = new NodeExitServiceImpl();
        this._exitService.injectExitHandlers(NodeSystemService._exitHandlers);
    }
    Env() {
        return envFactory();
    }
    Args() {
        return process.argv;
    }
    OnExit(hdl) {
        const id = crypto.randomUUID();
        NodeSystemService._exitHandlers.push({ hdl, id });
        return () => {
            const idx = NodeSystemService._exitHandlers.findIndex((h) => h.id === id);
            if (idx >= 0) {
                NodeSystemService._exitHandlers.splice(idx, 1);
            }
        };
    }
    Exit(code) {
        this._exitService.exit(code);
    }
}
NodeSystemService._exitHandlers = [];
let my = undefined;
export function NodeSysAbstraction(param) {
    if (!my) {
        my = new BaseSysAbstraction({
            TxtEnDecoder: (param === null || param === void 0 ? void 0 : param.TxtEnDecoder) || TxtEnDecoderSingleton(),
            FileSystem: new NodeFileService(),
            SystemService: new NodeSystemService(),
        });
    }
    return new WrapperSysAbstraction(my, param);
}
//# sourceMappingURL=node-sys-abstraction.js.map