import YAML from "yaml";
import { Level, logValue, LogValue, } from "./logger.js";
import { WebSysAbstraction } from "./web/web-sys-abstraction.js";
import { Result } from "./result.js";
import { URI } from "./uri.js";
import { runtimeFn } from "./runtime.js";
import { ConsoleWriterStream } from "./utils/console-write-stream.js";
import { LogWriterStream } from "./log-writer-impl.js";
import { TxtEnDecoderSingleton } from "./txt-en-decoder.js";
import { LevelHandlerSingleton } from "./log-level-impl.js";
function getLen(value, lvs) {
    if (Array.isArray(value)) {
        return logValue(() => value.length, lvs);
    }
    else if (typeof value === "string") {
        return logValue(() => value.length, lvs);
    }
    else if (typeof value === "object" && value !== null) {
        if (typeof value.size === "number") {
            return logValue(() => value.size, lvs);
        }
        else if (typeof value.length === "number") {
            return logValue(() => value.length, lvs);
        }
        return logValue(() => Object.keys(value).length, lvs);
    }
    return logValue(() => -1, lvs);
}
function hash(value) {
    return "not implemented";
}
function toLogValue(lop) {
    if (lop && typeof lop.then === "function") {
        throw new Error("async logValue Not implemented");
    }
    return lop;
}
export class JSONFormatter {
    constructor(txtEnde, space) {
        this._txtEnDe = txtEnde;
        this._space = space;
    }
    format(attr) {
        let ret;
        try {
            ret = JSON.stringify(attr, null, this._space);
        }
        catch (e) {
            ret = JSON.stringify({ internal: { message: e.message, stack: e.stack } });
        }
        return this._txtEnDe.encode(ret + "\n");
    }
}
export class YAMLFormatter {
    constructor(txtEnde, space) {
        this._txtEnDe = txtEnde;
        this._space = space;
    }
    format(attr) {
        return this._txtEnDe.encode("---\n" + YAML.stringify(attr, null, this._space) + "\n");
    }
}
function toLogValueCtx(lvh) {
    return {
        ignoreAttr: lvh.ignoreAttr,
    };
}
export class LoggerImpl {
    constructor(params) {
        this._attributes = {};
        if (!params) {
            params = {};
        }
        if (!params.sys) {
            this._sys = WebSysAbstraction();
        }
        else {
            this._sys = params.sys;
        }
        if (!params.txtEnDe) {
            this._txtEnDe = TxtEnDecoderSingleton();
        }
        else {
            this._txtEnDe = params.txtEnDe;
        }
        if (!params.formatter) {
            this._formatter = new JSONFormatter(this._txtEnDe);
        }
        else {
            this._formatter = params.formatter;
        }
        if (params.logWriter) {
            this._logWriter = params.logWriter;
        }
        else {
            if (!params.out) {
                const rt = runtimeFn();
                let stream;
                if (rt.isBrowser) {
                    stream = new ConsoleWriterStream();
                }
                else {
                    if (rt.isNodeIsh || rt.isReactNative || rt.isDeno || rt.isCFWorker) {
                        stream = this._sys.Stdout();
                    }
                    else {
                        throw new Error("No output defined for runtime");
                    }
                }
                this._logWriter = new LogWriterStream(stream);
            }
            else {
                this._logWriter = new LogWriterStream(params.out);
            }
        }
        if (!params.withAttributes) {
            this._withAttributes = {};
        }
        else {
            this._withAttributes = { ...params.withAttributes };
        }
        this._attributes = { ...this._withAttributes };
        if (params.levelHandler) {
            this.levelHandler = params.levelHandler;
        }
        else {
            this.levelHandler = LevelHandlerSingleton();
        }
    }
    TxtEnDe() {
        return this._txtEnDe;
    }
    Attributes() {
        return JSON.parse(JSON.stringify(this._attributes, null));
    }
    SetExposeStack(enable) {
        this.levelHandler.setExposeStack(enable);
        return this;
    }
    EnableLevel(level, ...modules) {
        this.levelHandler.enableLevel(level, ...modules);
        return this;
    }
    DisableLevel(level, ...modules) {
        this.levelHandler.disableLevel(level, ...modules);
        return this;
    }
    Module(key) {
        this._attributes["module"] = logValue(key, toLogValueCtx(this.levelHandler));
        this._withAttributes["module"] = logValue(key, toLogValueCtx(this.levelHandler));
        return this;
    }
    SetDebug(...modules) {
        this.levelHandler.setDebug(...modules);
        return this;
    }
    SetIgnoreAttribute(re) {
        this.levelHandler.setIgnoreAttr(re);
        return this;
    }
    SetFormatter(formatter) {
        this._formatter = formatter;
        return this;
    }
    Timestamp() {
        this._attributes["ts"] = logValue(() => this._sys.Time().Now().toISOString(), toLogValueCtx(this.levelHandler));
        return this;
    }
    Warn() {
        this._attributes["level"] = logValue(Level.WARN, toLogValueCtx(this.levelHandler));
        return this;
    }
    Log() {
        return this;
    }
    Debug() {
        this._attributes["level"] = logValue(Level.DEBUG, toLogValueCtx(this.levelHandler));
        return this;
    }
    Error() {
        this._attributes["level"] = logValue(Level.ERROR, toLogValueCtx(this.levelHandler));
        return this;
    }
    Info() {
        this._attributes["level"] = logValue(Level.INFO, toLogValueCtx(this.levelHandler));
        return this;
    }
    Err(err) {
        var _a;
        let key = "error";
        if (Result.Is(err)) {
            if (err.isOk()) {
                key = "noerror";
                err = err.Ok();
            }
            else {
                err = err.Err();
            }
        }
        if (err instanceof Error) {
            if (err.cause) {
                this.coerceKey(key, {
                    message: err.message,
                    cause: err.cause,
                });
            }
            else {
                this._attributes[key] = logValue(err.message, toLogValueCtx(this.levelHandler));
            }
            if (this.levelHandler.isStackExposed) {
                this._attributes["stack"] = logValue((_a = err.stack) === null || _a === void 0 ? void 0 : _a.split(/[\r\n]+/).map((s) => s.trim()), toLogValueCtx(this.levelHandler));
            }
        }
        else {
            this.Any(key, err);
        }
        return this;
    }
    WithLevel(l) {
        this._attributes["level"] = logValue(l, toLogValueCtx(this.levelHandler));
        return this;
    }
    Ref(key, action) {
        if (typeof action === "function") {
            this._attributes[key] = logValue(action, toLogValueCtx(this.levelHandler));
        }
        else if (typeof action.toString === "function") {
            this._attributes[key] = logValue(() => action.toString(), toLogValueCtx(this.levelHandler));
        }
        else {
            this._attributes[key] = logValue("INVALID REF", toLogValueCtx(this.levelHandler));
        }
        return this;
    }
    Bool(key, value) {
        this.coerceKey(key, !!value);
        return this;
    }
    Http(...mix) {
        const key = mix.find((x) => typeof x === "string");
        mix = mix.filter((x) => typeof x !== "string");
        const resErrors = mix.filter((x) => Result.Is(x) && x.isErr());
        if (resErrors.length) {
            this.Err(resErrors.map((x) => x.Err().message).join("\n"));
            return this;
        }
        const req = mix
            .map((reqOrResult) => (Result.Is(reqOrResult) ? reqOrResult.Ok() : reqOrResult))
            .find((req) => typeof req.status !== "number");
        const res = mix
            .map((resOrResult) => (Result.Is(resOrResult) ? resOrResult.Ok() : resOrResult))
            .find((res) => typeof res.status === "number");
        let reqAndOrres;
        if (res && req) {
            reqAndOrres = { res, req };
        }
        else if (!res && !req) {
            reqAndOrres = undefined;
        }
        else if (res) {
            reqAndOrres = res;
        }
        else if (req) {
            reqAndOrres = req;
        }
        if (reqAndOrres) {
            this.Any(key || "Http", reqAndOrres);
        }
        return this;
    }
    Pair(x) {
        for (const key of Object.keys(x)) {
            const value = x[key];
            if (value instanceof LogValue) {
                this._attributes[key] = value;
                continue;
            }
            if (Result.Is(value)) {
                this.Result(key, value);
                continue;
            }
            this.Any(key, value);
        }
        return this;
    }
    Result(key, res) {
        if (res.isOk()) {
            this._attributes[key] = logValue(res.Ok(), toLogValueCtx(this.levelHandler));
        }
        else {
            this.Err(res.Err());
        }
        return this;
    }
    Len(value, key = "len") {
        this._attributes[key] = getLen(value, toLogValueCtx(this.levelHandler));
        return this;
    }
    Hash(value, key = "hash") {
        throw new Error("Not implemented");
    }
    Url(url, key = "url") {
        this.Ref(key, () => URI.from(url).toString());
        return this;
    }
    coerceKey(key, value) {
        if (typeof key === "string") {
            this._attributes[key] = logValue(value, toLogValueCtx(this.levelHandler));
        }
        else {
            this.Pair(key);
        }
    }
    Str(key, value) {
        this.coerceKey(key, value);
        return this;
    }
    Any(key, value) {
        this.coerceKey(key, value);
        return this;
    }
    Dur(key, nsec) {
        this._attributes[key] = logValue(`${nsec}ms`, toLogValueCtx(this.levelHandler));
        return this;
    }
    Uint64(key, value) {
        this.coerceKey(key, value);
        return this;
    }
    Int(key, value) {
        return this.Uint64(key, value);
    }
    async Flush() {
        return new Promise((resolve) => {
            this._logWriter._flush(undefined, resolve);
        });
    }
    With() {
        return new WithLoggerBuilder(new LoggerImpl({
            logWriter: this._logWriter,
            sys: this._sys,
            levelHandler: this.levelHandler,
            formatter: this._formatter,
            withAttributes: {
                module: this._attributes["module"],
                ...this._withAttributes,
            },
        }));
    }
    _resetAttributes(fn) {
        const ret = fn();
        Object.keys(this._attributes).forEach((key) => {
            delete this._attributes[key];
        });
        Object.assign(this._attributes, this._withAttributes);
        return ret;
    }
    Msg(...args) {
        const fnError = this._resetAttributes(() => {
            var _a, _b;
            const doWrite = this.levelHandler.isEnabled((_a = toLogValue(this._attributes["level"])) === null || _a === void 0 ? void 0 : _a.value(), (_b = toLogValue(this._attributes["module"])) === null || _b === void 0 ? void 0 : _b.value());
            this._attributes["msg"] = logValue(args.join(" "), toLogValueCtx(this.levelHandler));
            const msg = this._attributes["msg"].value();
            if (typeof msg === "string" && !msg.trim().length) {
                delete this._attributes["msg"];
            }
            let fnRet = () => this._formatter.format({ ...this._attributes });
            if (doWrite) {
                const encoded = fnRet();
                this._logWriter.write(encoded);
                fnRet = () => encoded;
            }
            return fnRet;
        });
        const asError = () => new Error(this._txtEnDe.decode(fnError()));
        return {
            ResultError: () => Result.Err(asError()),
            AsError: asError,
        };
    }
}
class WithLoggerBuilder {
    constructor(li) {
        this._li = li;
        this.levelHandler = li.levelHandler;
    }
    TxtEnDe() {
        return this._li.TxtEnDe();
    }
    Logger() {
        Object.assign(this._li._withAttributes, this._li._attributes);
        return this._li;
    }
    Attributes() {
        return { ...this._li._attributes };
    }
    SetExposeStack(enable) {
        this._li.levelHandler.setExposeStack(enable);
        return this;
    }
    SetIgnoreAttribute(re) {
        this._li.levelHandler.setIgnoreAttr(re);
        return this;
    }
    SetFormatter(fmt) {
        this._li.SetFormatter(fmt);
        return this;
    }
    EnableLevel(level, ...modules) {
        this._li.levelHandler.enableLevel(level, ...modules);
        return this;
    }
    DisableLevel(level, ...modules) {
        this._li.levelHandler.enableLevel(level, ...modules);
        return this;
    }
    Module(key) {
        this._li.Module(key);
        return this;
    }
    SetDebug(...modules) {
        this._li.SetDebug(...modules);
        return this;
    }
    Http(...mix) {
        this._li.Http(...mix);
        return this;
    }
    Pair(x) {
        this._li.Pair(x);
        return this;
    }
    Str(key, value) {
        this._li.Str(key, value);
        return this;
    }
    Len(value, key) {
        this._li.Len(value, key);
        return this;
    }
    Hash(value, key) {
        this._li.Hash(value, key);
        return this;
    }
    Ref(key, action) {
        this._li.Ref(key, action);
        return this;
    }
    Bool(key, value) {
        this._li.Bool(key, value);
        return this;
    }
    Result(key, res) {
        this._li.Result(key, res);
        return this;
    }
    Url(url, key) {
        this._li.Url(url, key);
        return this;
    }
    Int(key, value) {
        this._li.Int(key, value);
        return this;
    }
    Log() {
        this._li.Log();
        return this;
    }
    WithLevel(level) {
        this._li.WithLevel(level);
        return this;
    }
    Error() {
        this._li.Error();
        return this;
    }
    Warn() {
        this._li.Error();
        return this;
    }
    Debug() {
        this._li.Debug();
        return this;
    }
    Err(err) {
        this._li.Err(err);
        return this;
    }
    Info() {
        this._li.Info();
        return this;
    }
    Timestamp() {
        this._li.Timestamp();
        return this;
    }
    Any(key, value) {
        this._li.Any(key, value);
        return this;
    }
    Dur(key, nsec) {
        this._li.Dur(key, nsec);
        return this;
    }
    Uint64(key, value) {
        this._li.Uint64(key, value);
        return this;
    }
}
//# sourceMappingURL=logger-impl.js.map