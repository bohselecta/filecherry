import {
  ConsoleWriterStream,
  ConsoleWriterStreamDefaultWriter,
  FanoutWriteStream,
  stripper
} from "./chunk-PHS255C5.js";
import {
  TxtEnDecoderSingleton,
  __export,
  asyncCoerceIntoUint8,
  coerceIntoUint8,
  getParamsResult
} from "./chunk-LXTKPZ6M.js";

// src/utils/index.ts
var utils_exports = {};
__export(utils_exports, {
  ConsoleWriterStream: () => ConsoleWriterStream,
  ConsoleWriterStreamDefaultWriter: () => ConsoleWriterStreamDefaultWriter,
  FanoutWriteStream: () => FanoutWriteStream,
  UInt8ArrayEqual: () => UInt8ArrayEqual,
  array2stream: () => array2stream,
  asyncCoerceIntoUint8: () => asyncCoerceIntoUint8,
  coerceIntoUint8: () => coerceIntoUint8,
  devnull: () => devnull,
  getParamsResult: () => getParamsResult,
  rebuffer: () => rebuffer,
  rebufferArray: () => rebufferArray,
  stream2array: () => stream2array,
  stream2string: () => stream2string,
  stream2uint8array: () => stream2uint8array,
  streamMap: () => streamMap,
  string2stream: () => string2stream,
  stripper: () => stripper,
  toSortedArray: () => toSortedArray,
  toSortedObject: () => toSortedObject,
  toSortedObjectArray: () => toSortedObjectArray,
  uint8array2stream: () => uint8array2stream
});

// src/utils/stream-map.ts
function streamMap(s, sm) {
  const state = { reader: s.getReader(), streamMap: sm, idx: 0 };
  return new ReadableStream({
    async pull(controller) {
      const { done, value } = await state.reader.read();
      if (done) {
        if (state.streamMap.Close) {
          state.streamMap.Close();
        }
        controller.close();
        return;
      }
      const promiseOrU = state.streamMap.Map(value, state.idx++);
      let mapped;
      if (promiseOrU instanceof Promise || typeof promiseOrU.then === "function") {
        mapped = await promiseOrU;
      } else {
        mapped = promiseOrU;
      }
      controller.enqueue(mapped);
    }
  });
}
async function devnull(a) {
  const reader = a.getReader();
  let cnt = 0;
  while (true) {
    const { done } = await reader.read();
    if (done) {
      break;
    }
    cnt++;
  }
  return cnt;
}
function array2stream(a) {
  let i = 0;
  return new ReadableStream({
    pull(controller) {
      if (i >= a.length) {
        controller.close();
        return;
      }
      controller.enqueue(a[i]);
      i++;
    }
  });
}
async function stream2array(a) {
  const ret = [];
  const reader = a.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    ret.push(value);
  }
  return ret;
}

// src/utils/rebuffer.ts
async function rebufferArray(a, chunkSize) {
  return stream2array(rebuffer(array2stream(a), chunkSize));
}
function reChunk(cs, chunkSize) {
  const len = cs.reduce((acc, v) => acc + v.length, 0);
  const last = cs[cs.length - 1];
  const lastOfs = len - last.length;
  const rest = last.subarray(chunkSize - lastOfs);
  cs[cs.length - 1] = last.subarray(0, chunkSize - lastOfs);
  const chunk = new Uint8Array(chunkSize);
  let ofs = 0;
  for (const c of cs) {
    chunk.set(c, ofs);
    ofs += c.length;
  }
  return { rest, chunk };
}
function pump(ps, controller, next) {
  ps.reader.read().then(({ done, value }) => {
    if (done) {
      if (ps.tmpLen > 0) {
        controller.enqueue(reChunk(ps.tmp, ps.tmpLen).chunk);
      }
      controller.close();
      next();
      return;
    }
    if (ps.tmpLen + value.length > ps.chunkSize) {
      ps.tmp.push(value);
      const res = reChunk(ps.tmp, ps.chunkSize);
      controller.enqueue(res.chunk);
      ps.tmp = [res.rest];
      ps.tmpLen = res.rest.length;
      next();
      return;
    } else if (value.length) {
      ps.tmp.push(value);
      ps.tmpLen += value.length;
    }
    pump(ps, controller, next);
  }).catch((err) => {
    controller.error(err);
    next();
  });
}
function rebuffer(a, chunkSize) {
  const state = {
    reader: a.getReader(),
    tmp: [],
    tmpLen: 0,
    chunkSize
  };
  return new ReadableStream({
    async pull(controller) {
      return new Promise((resolve) => {
        pump(state, controller, resolve);
      });
    }
  });
}

// src/utils/stream2string.ts
async function stream2string(stream, maxSize) {
  if (!stream) {
    return Promise.resolve("");
  }
  const reader = stream.getReader();
  let res = "";
  const decoder = new TextDecoder();
  let rSize = 0;
  while (typeof maxSize === "undefined" || rSize < maxSize) {
    try {
      const read = await reader.read();
      if (read.done) {
        break;
      }
      if (maxSize && rSize + read.value.length > maxSize) {
        read.value = read.value.slice(0, maxSize - rSize);
      }
      const block = decoder.decode(read.value, { stream: true });
      rSize += read.value.length;
      res += block;
    } catch (err) {
      return Promise.reject(err);
    }
  }
  return Promise.resolve(res);
}
async function stream2uint8array(stream) {
  if (!stream) {
    return Promise.resolve(new Uint8Array());
  }
  const reader = stream.getReader();
  let res = new Uint8Array();
  while (1) {
    try {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      res = new Uint8Array([...res, ...value]);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  return Promise.resolve(res);
}

// src/utils/string2stream.ts
function string2stream(str, ende = TxtEnDecoderSingleton()) {
  return uint8array2stream(ende.encode(str));
}
function uint8array2stream(str) {
  return new ReadableStream({
    start(controller) {
      controller.enqueue(str);
      controller.close();
    }
  });
}

// src/utils/sorted-object.ts
function toSortedObjectArray(set) {
  if (!set) return [];
  return toSortedArray(set).map(([k, v]) => ({ [k]: v }));
}
function toSortedArray(set) {
  if (!set) return [];
  return Object.entries(set).sort(([a], [b]) => a.localeCompare(b));
}
function toSortedObject(set) {
  if (!set) return set;
  return Object.fromEntries(toSortedArray(set));
}

// src/utils/uint8array-equal.ts
function UInt8ArrayEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

export {
  streamMap,
  devnull,
  array2stream,
  stream2array,
  rebufferArray,
  rebuffer,
  stream2string,
  stream2uint8array,
  string2stream,
  uint8array2stream,
  toSortedObjectArray,
  toSortedArray,
  toSortedObject,
  UInt8ArrayEqual,
  utils_exports
};
//# sourceMappingURL=chunk-55W4AK2Z.js.map