{"version":3,"sources":["../../src/result.ts","../../src/types.ts","../../src/utils/get-params-result.ts","../../src/utils/coerce-uint8.ts","../../src/txt-en-decoder.ts"],"sourcesContent":["export abstract class Result<T, E = Error> {\n  static Ok<T = void>(t: T): Result<T, Error> {\n    return new ResultOK(t);\n  }\n  static Err<T, E extends Error = Error>(t: E | string | Result<unknown, E>): Result<T, E> {\n    if (typeof t === \"string\") {\n      return new ResultError(new Error(t) as E);\n    }\n    if (Result.Is(t)) {\n      if (t.is_ok()) {\n        return new ResultError(new Error(\"Result Error is Ok\") as E);\n      }\n      return t as Result<T, E>;\n    }\n    return new ResultError(t);\n  }\n  static Is<T>(t: unknown): t is Result<T> {\n    if (!t) {\n      return false;\n    }\n    if (t instanceof Result) {\n      return true;\n    }\n    const rt = t as Result<T>;\n    if ([typeof rt.is_ok, typeof rt.is_err, typeof rt.unwrap, typeof rt.unwrap_err].every((x) => x === \"function\")) {\n      return true;\n    }\n    return false;\n  }\n\n  isOk(): boolean {\n    return this.is_ok();\n  }\n  isErr(): boolean {\n    return this.is_err();\n  }\n\n  Ok(): T {\n    return this.unwrap();\n  }\n  Err(): E {\n    return this.unwrap_err();\n  }\n\n  abstract is_ok(): boolean;\n  abstract is_err(): boolean;\n  abstract unwrap(): T;\n  abstract unwrap_err(): E;\n}\n\nexport class ResultOK<T> extends Result<T, Error> {\n  private _t: T;\n  constructor(t: T) {\n    super();\n    this._t = t;\n  }\n  is_ok(): boolean {\n    return true;\n  }\n  is_err(): boolean {\n    return false;\n  }\n  unwrap_err(): Error {\n    throw new Error(\"Result is Ok\");\n  }\n  unwrap(): T {\n    return this._t;\n  }\n}\n\nexport class ResultError<T extends Error> extends Result<never, T> {\n  private _error: T;\n  constructor(t: T) {\n    super();\n    this._error = t;\n  }\n  is_ok(): boolean {\n    return false;\n  }\n  is_err(): boolean {\n    return true;\n  }\n  unwrap(): never {\n    throw new Error(`Result is Err: ${this._error}`);\n  }\n  unwrap_err(): T {\n    return this._error;\n  }\n}\n\nexport type WithoutResult<T> = T extends Result<infer U> ? U : T;\n\n// type WithoutPromise<T> = T extends Promise<infer U> ? U : T;\ntype WithResult<T> = T extends Promise<infer U> ? Promise<Result<U>> : Result<T>;\n\nexport function exception2Result<FN extends () => Promise<T> | T, T>(fn: FN): WithResult<ReturnType<FN>> {\n  try {\n    const res = fn();\n    if (res instanceof Promise) {\n      return res.then((value) => Result.Ok(value)).catch((e) => Result.Err(e)) as WithResult<ReturnType<FN>>;\n    }\n    return Result.Ok(res) as WithResult<ReturnType<FN>>;\n  } catch (e) {\n    return Result.Err(e as Error) as WithResult<ReturnType<FN>>;\n  }\n}\n\n/*\n\ntype FinalizedResult<T> = {\n  result: T;\n  scopeResult?: Result<void>;\n  finally: () => Promise<void>;\n}\n\ntype exection2ResultParam<T> = {\n  init: () => Promise<T>;\n  inScope?: (t: T) => Promise<void>;\n  cleanup: (t: T) => Promise<void>;\n\n}\n\nasync function expection2Result<T>({fn, inScope, cleanup}: exection2ResultParam<T>): Promise<Result<FinalizedResult<T>>> {\n  try {\n    const res = await fn();\n    if (inScope) {\n      try {\n        await inScope?.(res)\n      } catch (err) {\n        return Result.Err(err as Error)\n      }\n      await cleanup(res)\n      return Result.Ok({\n        result: res,\n        finally: async () => { }\n      })\n    }\n    return Result.Ok({\n      result: res ,\n      finally: async () => {\n        return cleanup(res)\n      }\n    })\n  } catch (err) {\n    return Result.Err(err as Error)\n  }\n}\n*/\n\n// await expection2Result({\n//   init: openDB,\n//   inScope: (res) => {\n//     res.query()\n//   },\n//   cleanup: async (y) => {\n//     await y.close()\n//  }\n// })\n// async function openDB() {\n//   try {\n//     const opendb = await openDB()\n//     return Result.Ok({\n//       openDB,\n//       finally: async () => {\n//         await opendb.close()\n//     }})\n//   } catch (err) {\n//     return Result.Err(err)\n//   }\n// }\n// }\n","interface IType {\n  readonly type: string;\n}\nclass _Required implements IType {\n  readonly type = \"REQUIRED\";\n}\n\nclass _Optional implements IType {\n  readonly type = \"OPTIONAL\";\n}\n\nexport const param: {\n  REQUIRED: _Required;\n  OPTIONAL: _Optional;\n} = {\n  REQUIRED: new _Required(),\n  OPTIONAL: new _Optional(),\n};\nexport type param = (typeof param)[keyof typeof param];\n","import { Result } from \"../result.js\";\nimport { param } from \"../types.js\";\n\nexport type MsgFn = (...keys: string[]) => string;\nexport type KeysParam = (string | MsgFn | Record<string, param | number | string | boolean | undefined | null>)[];\n\nexport function getParamsResult(\n  keys: KeysParam,\n  getParam: { getParam: (key: string) => string | undefined },\n): Result<Record<string, string>> {\n  const keyDef = keys.flat().reduce(\n    (acc, i) => {\n      if (typeof i === \"string\") {\n        acc.push({ key: i, def: undefined, isOptional: false });\n      } else if (typeof i === \"object\") {\n        acc.push(\n          ...Object.keys(i).map((k) => ({\n            key: k,\n            def: typeof i[k] === \"string\" ? i[k] : undefined,\n            isOptional: i[k] === param.OPTIONAL,\n          })),\n        );\n      }\n      return acc;\n    },\n    [] as { key: string; def?: string; isOptional: boolean }[],\n  );\n  //.filter((k) => typeof k === \"string\");\n  const msgFn =\n    keys.find((k) => typeof k === \"function\") ||\n    ((...keys: string[]): string => {\n      const msg = keys.join(\",\");\n      return `missing parameters: ${msg}`;\n    });\n  const errors: string[] = [];\n  const result: Record<string, string> = {};\n  for (const kd of keyDef) {\n    const val = getParam.getParam(kd.key);\n    if (val === undefined) {\n      if (typeof kd.def === \"string\") {\n        result[kd.key] = kd.def;\n      } else {\n        if (!kd.isOptional) {\n          errors.push(kd.key);\n        }\n      }\n    } else {\n      result[kd.key] = val;\n    }\n  }\n  if (errors.length) {\n    return Result.Err(msgFn(...errors));\n  }\n  return Result.Ok(result);\n}\n","import { Result } from \"../result.js\";\n\n// Tested in txt-en-decoder.test.ts\n\ninterface GlobalBuffer {\n  Buffer?: {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    isBuffer: (obj: any) => obj is {\n      buffer: ArrayBufferLike;\n      byteOffset: number;\n      byteLength: number;\n    };\n  };\n}\nconst globalBuffer = globalThis as GlobalBuffer;\n\nexport type ToUInt8Plain = Uint8Array | ArrayBuffer | ArrayBufferView;\nexport type ToUInt8Async = ToUInt8Plain | Blob;\nexport type ToUInt8 = ToUInt8Plain | Result<ToUInt8Plain>;\nexport type AsyncToUInt8 = ToUInt8Async | Result<ToUInt8Async> | Promise<ToUInt8Async> | Promise<Result<ToUInt8Async>>;\n\nexport function coerceIntoUint8(raw: ToUInt8): Result<Uint8Array> {\n  if (raw instanceof ArrayBuffer) {\n    return Result.Ok(new Uint8Array(raw));\n  }\n  if (ArrayBuffer.isView(raw)) {\n    return Result.Ok(new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength));\n  }\n  if (raw instanceof Blob) {\n    return Result.Err(\"Blob not supported\");\n  }\n  if (globalBuffer.Buffer && globalBuffer.Buffer.isBuffer(raw)) {\n    return Result.Ok(new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength));\n  }\n  if (raw instanceof Uint8Array) {\n    return Result.Ok(raw);\n  }\n  if (Result.Is(raw)) {\n    if (raw.isErr()) {\n      return Result.Err(raw);\n    }\n    return coerceIntoUint8(raw.unwrap());\n  }\n  return Result.Err(\"Not a Uint8Array\");\n}\n\nexport async function asyncCoerceIntoUint8(raw: AsyncToUInt8): Promise<Result<Uint8Array>> {\n  let resolved = await raw;\n  if (resolved instanceof Blob) {\n    resolved = await resolved.arrayBuffer();\n  }\n  return coerceIntoUint8(resolved as ToUInt8);\n}\n","import { Result } from \"./result.js\";\nimport { coerceIntoUint8, ToUInt8 } from \"./utils/coerce-uint8.js\";\n\nexport type ToEnDecoder = ToUInt8 | string | Result<string>;\nexport type AsyncToEnDecoder = ToEnDecoder | Blob | Promise<ToEnDecoder | Blob>;\n\nexport interface TxtEnDecoder {\n  encode(input: string): Uint8Array;\n  decode(input: ToEnDecoder): string;\n  asyncDecode(input: AsyncToEnDecoder): Promise<string>;\n}\n\nclass TxtOps implements TxtEnDecoder {\n  readonly encoder = new TextEncoder();\n  readonly decoder = new TextDecoder();\n\n  encode(str: string): Uint8Array {\n    return this.encoder.encode(str);\n  }\n  decode(data: ToEnDecoder): string {\n    if (Result.Is(data)) {\n      if (data.isErr()) {\n        throw data.Err();\n      }\n      // only for string let do coerceInto the work\n      const unwrapped = data.unwrap();\n      if (typeof unwrapped === \"string\") {\n        return this.decode(unwrapped);\n      }\n    }\n    if (typeof data === \"string\") {\n      return data;\n    }\n    return this.decoder.decode(coerceIntoUint8(data as ToUInt8).Ok());\n  }\n\n  async asyncDecode(data: AsyncToEnDecoder): Promise<string> {\n    let resolved = await data;\n    if (resolved instanceof Blob) {\n      resolved = await resolved.arrayBuffer();\n    }\n    return this.decode(resolved);\n  }\n}\n\nlet txtEnDecoder: TxtEnDecoder;\nexport function TxtEnDecoderSingleton(): TxtEnDecoder {\n  txtEnDecoder = txtEnDecoder ?? new TxtOps();\n  return txtEnDecoder;\n}\n"],"mappings":"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","names":["keys"]}