"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils/index.ts
var utils_exports = {};
__export(utils_exports, {
  ConsoleWriterStream: () => ConsoleWriterStream,
  ConsoleWriterStreamDefaultWriter: () => ConsoleWriterStreamDefaultWriter,
  FanoutWriteStream: () => FanoutWriteStream,
  UInt8ArrayEqual: () => UInt8ArrayEqual,
  array2stream: () => array2stream,
  asyncCoerceIntoUint8: () => asyncCoerceIntoUint8,
  coerceIntoUint8: () => coerceIntoUint8,
  devnull: () => devnull,
  getParamsResult: () => getParamsResult,
  rebuffer: () => rebuffer,
  rebufferArray: () => rebufferArray,
  stream2array: () => stream2array,
  stream2string: () => stream2string,
  stream2uint8array: () => stream2uint8array,
  streamMap: () => streamMap,
  string2stream: () => string2stream,
  stripper: () => stripper,
  toSortedArray: () => toSortedArray,
  toSortedObject: () => toSortedObject,
  toSortedObjectArray: () => toSortedObjectArray,
  uint8array2stream: () => uint8array2stream
});
module.exports = __toCommonJS(utils_exports);

// src/utils/stream-map.ts
function streamMap(s, sm) {
  const state = { reader: s.getReader(), streamMap: sm, idx: 0 };
  return new ReadableStream({
    async pull(controller) {
      const { done, value } = await state.reader.read();
      if (done) {
        if (state.streamMap.Close) {
          state.streamMap.Close();
        }
        controller.close();
        return;
      }
      const promiseOrU = state.streamMap.Map(value, state.idx++);
      let mapped;
      if (promiseOrU instanceof Promise || typeof promiseOrU.then === "function") {
        mapped = await promiseOrU;
      } else {
        mapped = promiseOrU;
      }
      controller.enqueue(mapped);
    }
  });
}
async function devnull(a) {
  const reader = a.getReader();
  let cnt = 0;
  while (true) {
    const { done } = await reader.read();
    if (done) {
      break;
    }
    cnt++;
  }
  return cnt;
}
function array2stream(a) {
  let i = 0;
  return new ReadableStream({
    pull(controller) {
      if (i >= a.length) {
        controller.close();
        return;
      }
      controller.enqueue(a[i]);
      i++;
    }
  });
}
async function stream2array(a) {
  const ret = [];
  const reader = a.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    ret.push(value);
  }
  return ret;
}

// src/utils/rebuffer.ts
async function rebufferArray(a, chunkSize) {
  return stream2array(rebuffer(array2stream(a), chunkSize));
}
function reChunk(cs, chunkSize) {
  const len = cs.reduce((acc, v) => acc + v.length, 0);
  const last = cs[cs.length - 1];
  const lastOfs = len - last.length;
  const rest = last.subarray(chunkSize - lastOfs);
  cs[cs.length - 1] = last.subarray(0, chunkSize - lastOfs);
  const chunk = new Uint8Array(chunkSize);
  let ofs = 0;
  for (const c of cs) {
    chunk.set(c, ofs);
    ofs += c.length;
  }
  return { rest, chunk };
}
function pump(ps, controller, next) {
  ps.reader.read().then(({ done, value }) => {
    if (done) {
      if (ps.tmpLen > 0) {
        controller.enqueue(reChunk(ps.tmp, ps.tmpLen).chunk);
      }
      controller.close();
      next();
      return;
    }
    if (ps.tmpLen + value.length > ps.chunkSize) {
      ps.tmp.push(value);
      const res = reChunk(ps.tmp, ps.chunkSize);
      controller.enqueue(res.chunk);
      ps.tmp = [res.rest];
      ps.tmpLen = res.rest.length;
      next();
      return;
    } else if (value.length) {
      ps.tmp.push(value);
      ps.tmpLen += value.length;
    }
    pump(ps, controller, next);
  }).catch((err) => {
    controller.error(err);
    next();
  });
}
function rebuffer(a, chunkSize) {
  const state = {
    reader: a.getReader(),
    tmp: [],
    tmpLen: 0,
    chunkSize
  };
  return new ReadableStream({
    async pull(controller) {
      return new Promise((resolve) => {
        pump(state, controller, resolve);
      });
    }
  });
}

// src/utils/stream2string.ts
async function stream2string(stream, maxSize) {
  if (!stream) {
    return Promise.resolve("");
  }
  const reader = stream.getReader();
  let res = "";
  const decoder = new TextDecoder();
  let rSize = 0;
  while (typeof maxSize === "undefined" || rSize < maxSize) {
    try {
      const read = await reader.read();
      if (read.done) {
        break;
      }
      if (maxSize && rSize + read.value.length > maxSize) {
        read.value = read.value.slice(0, maxSize - rSize);
      }
      const block = decoder.decode(read.value, { stream: true });
      rSize += read.value.length;
      res += block;
    } catch (err) {
      return Promise.reject(err);
    }
  }
  return Promise.resolve(res);
}
async function stream2uint8array(stream) {
  if (!stream) {
    return Promise.resolve(new Uint8Array());
  }
  const reader = stream.getReader();
  let res = new Uint8Array();
  while (1) {
    try {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      res = new Uint8Array([...res, ...value]);
    } catch (err) {
      return Promise.reject(err);
    }
  }
  return Promise.resolve(res);
}

// src/result.ts
var Result = class _Result {
  static Ok(t) {
    return new ResultOK(t);
  }
  static Err(t) {
    if (typeof t === "string") {
      return new ResultError(new Error(t));
    }
    if (_Result.Is(t)) {
      if (t.is_ok()) {
        return new ResultError(new Error("Result Error is Ok"));
      }
      return t;
    }
    return new ResultError(t);
  }
  static Is(t) {
    if (!t) {
      return false;
    }
    if (t instanceof _Result) {
      return true;
    }
    const rt = t;
    if ([typeof rt.is_ok, typeof rt.is_err, typeof rt.unwrap, typeof rt.unwrap_err].every((x) => x === "function")) {
      return true;
    }
    return false;
  }
  isOk() {
    return this.is_ok();
  }
  isErr() {
    return this.is_err();
  }
  Ok() {
    return this.unwrap();
  }
  Err() {
    return this.unwrap_err();
  }
};
var ResultOK = class extends Result {
  constructor(t) {
    super();
    this._t = t;
  }
  is_ok() {
    return true;
  }
  is_err() {
    return false;
  }
  unwrap_err() {
    throw new Error("Result is Ok");
  }
  unwrap() {
    return this._t;
  }
};
var ResultError = class extends Result {
  constructor(t) {
    super();
    this._error = t;
  }
  is_ok() {
    return false;
  }
  is_err() {
    return true;
  }
  unwrap() {
    throw new Error(`Result is Err: ${this._error}`);
  }
  unwrap_err() {
    return this._error;
  }
};

// src/utils/coerce-uint8.ts
var globalBuffer = globalThis;
function coerceIntoUint8(raw) {
  if (raw instanceof ArrayBuffer) {
    return Result.Ok(new Uint8Array(raw));
  }
  if (ArrayBuffer.isView(raw)) {
    return Result.Ok(new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength));
  }
  if (raw instanceof Blob) {
    return Result.Err("Blob not supported");
  }
  if (globalBuffer.Buffer && globalBuffer.Buffer.isBuffer(raw)) {
    return Result.Ok(new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength));
  }
  if (raw instanceof Uint8Array) {
    return Result.Ok(raw);
  }
  if (Result.Is(raw)) {
    if (raw.isErr()) {
      return Result.Err(raw);
    }
    return coerceIntoUint8(raw.unwrap());
  }
  return Result.Err("Not a Uint8Array");
}
async function asyncCoerceIntoUint8(raw) {
  let resolved = await raw;
  if (resolved instanceof Blob) {
    resolved = await resolved.arrayBuffer();
  }
  return coerceIntoUint8(resolved);
}

// src/txt-en-decoder.ts
var TxtOps = class {
  constructor() {
    this.encoder = new TextEncoder();
    this.decoder = new TextDecoder();
  }
  encode(str) {
    return this.encoder.encode(str);
  }
  decode(data) {
    if (Result.Is(data)) {
      if (data.isErr()) {
        throw data.Err();
      }
      const unwrapped = data.unwrap();
      if (typeof unwrapped === "string") {
        return this.decode(unwrapped);
      }
    }
    if (typeof data === "string") {
      return data;
    }
    return this.decoder.decode(coerceIntoUint8(data).Ok());
  }
  async asyncDecode(data) {
    let resolved = await data;
    if (resolved instanceof Blob) {
      resolved = await resolved.arrayBuffer();
    }
    return this.decode(resolved);
  }
};
var txtEnDecoder;
function TxtEnDecoderSingleton() {
  txtEnDecoder = txtEnDecoder != null ? txtEnDecoder : new TxtOps();
  return txtEnDecoder;
}

// src/utils/string2stream.ts
function string2stream(str, ende = TxtEnDecoderSingleton()) {
  return uint8array2stream(ende.encode(str));
}
function uint8array2stream(str) {
  return new ReadableStream({
    start(controller) {
      controller.enqueue(str);
      controller.close();
    }
  });
}

// src/utils/console-write-stream.ts
var ConsoleWriterStreamDefaultWriter = class {
  constructor(stream) {
    this.stream = stream;
    this.desiredSize = null;
    this.decoder = new TextDecoder();
    this._stream = stream;
    this.ready = Promise.resolve(void 0);
    this.closed = Promise.resolve(void 0);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
  abort(reason) {
    throw new Error("Method not implemented.");
  }
  async close() {
  }
  releaseLock() {
    this._stream.locked = false;
    this.ready = Promise.resolve(void 0);
    this.closed = Promise.resolve(void 0);
  }
  write(chunk) {
    let strObj = this.decoder.decode(chunk).trimEnd();
    let output = "log";
    try {
      strObj = JSON.parse(strObj);
      output = strObj.level;
    } catch (e) {
    }
    switch (output) {
      case "error":
        console.error(strObj);
        break;
      case "warn":
        console.warn(strObj);
        break;
      default:
        console.log(strObj);
    }
    return Promise.resolve();
  }
};
var ConsoleWriterStream = class {
  constructor() {
    this.locked = false;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars
  abort(reason) {
    throw new Error("Method not implemented.");
  }
  close() {
    return Promise.resolve();
  }
  getWriter() {
    if (this.locked) {
      throw new Error("Stream is locked");
    }
    this.locked = true;
    if (!this._writer) {
      this._writer = new ConsoleWriterStreamDefaultWriter(this);
    }
    return this._writer;
  }
};

// src/utils/fanout-write-stream.ts
var FanoutWriteStream = class {
  constructor(writers) {
    this.desiredSize = null;
    this._writers = writers;
    this.ready = Promise.all(this._writers.map((w) => w.ready)).then(() => void 0);
    this.closed = Promise.all(this._writers.map((w) => w.closed)).then(() => void 0);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  abort(reason) {
    return Promise.all(this._writers.map((w) => w.abort(reason))).then(() => {
    });
  }
  close() {
    return Promise.all(this._writers.map((w) => w.close())).then(() => {
    });
  }
  releaseLock() {
    this._writers.map((w) => w.releaseLock());
  }
  write(chunk) {
    return Promise.all(this._writers.map((w) => w.write(chunk))).then(() => {
    });
  }
};

// src/types.ts
var _Required = class {
  constructor() {
    this.type = "REQUIRED";
  }
};
var _Optional = class {
  constructor() {
    this.type = "OPTIONAL";
  }
};
var param = {
  REQUIRED: new _Required(),
  OPTIONAL: new _Optional()
};

// src/utils/get-params-result.ts
function getParamsResult(keys, getParam) {
  const keyDef = keys.flat().reduce(
    (acc, i) => {
      if (typeof i === "string") {
        acc.push({ key: i, def: void 0, isOptional: false });
      } else if (typeof i === "object") {
        acc.push(
          ...Object.keys(i).map((k) => ({
            key: k,
            def: typeof i[k] === "string" ? i[k] : void 0,
            isOptional: i[k] === param.OPTIONAL
          }))
        );
      }
      return acc;
    },
    []
  );
  const msgFn = keys.find((k) => typeof k === "function") || ((...keys2) => {
    const msg = keys2.join(",");
    return `missing parameters: ${msg}`;
  });
  const errors = [];
  const result = {};
  for (const kd of keyDef) {
    const val = getParam.getParam(kd.key);
    if (val === void 0) {
      if (typeof kd.def === "string") {
        result[kd.key] = kd.def;
      } else {
        if (!kd.isOptional) {
          errors.push(kd.key);
        }
      }
    } else {
      result[kd.key] = val;
    }
  }
  if (errors.length) {
    return Result.Err(msgFn(...errors));
  }
  return Result.Ok(result);
}

// src/utils/stripper.ts
function stripper(strip, obj) {
  const strips = Array.isArray(strip) ? strip : [strip];
  const restrips = strips.map((s) => {
    if (typeof s === "string") {
      const escaped = s.replace(/[-\\[\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\^\\$\\|]/g, "\\$&");
      return new RegExp(`^${escaped}$`);
    }
    return s;
  });
  return localStripper(void 0, restrips, obj);
}
function localStripper(path, restrips, obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map((i) => localStripper(path, restrips, i));
  }
  const ret = { ...obj };
  const matcher = (key, nextPath) => {
    for (const re of restrips) {
      if (re.test(key) || re.test(nextPath)) {
        return true;
      }
    }
    return false;
  };
  for (const key in ret) {
    if (Object.prototype.hasOwnProperty.call(ret, key)) {
      let nextPath;
      if (path) {
        nextPath = [path, key].join(".");
      } else {
        nextPath = key;
      }
      if (matcher(key, nextPath)) {
        delete ret[key];
        continue;
      }
      if (typeof ret[key] === "object") {
        if (Array.isArray(ret[key])) {
          ret[key] = ret[key].reduce((acc, v, i) => {
            const toDelete = matcher(key, `${nextPath}[${i}]`);
            if (!toDelete) {
              acc.push(localStripper(`${nextPath}[${i}]`, restrips, v));
            }
            return acc;
          }, []);
        } else {
          ret[key] = localStripper(nextPath, restrips, ret[key]);
        }
      }
    }
  }
  return ret;
}

// src/utils/sorted-object.ts
function toSortedObjectArray(set) {
  if (!set) return [];
  return toSortedArray(set).map(([k, v]) => ({ [k]: v }));
}
function toSortedArray(set) {
  if (!set) return [];
  return Object.entries(set).sort(([a], [b]) => a.localeCompare(b));
}
function toSortedObject(set) {
  if (!set) return set;
  return Object.fromEntries(toSortedArray(set));
}

// src/utils/uint8array-equal.ts
function UInt8ArrayEqual(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ConsoleWriterStream,
  ConsoleWriterStreamDefaultWriter,
  FanoutWriteStream,
  UInt8ArrayEqual,
  array2stream,
  asyncCoerceIntoUint8,
  coerceIntoUint8,
  devnull,
  getParamsResult,
  rebuffer,
  rebufferArray,
  stream2array,
  stream2string,
  stream2uint8array,
  streamMap,
  string2stream,
  stripper,
  toSortedArray,
  toSortedObject,
  toSortedObjectArray,
  uint8array2stream
});
//# sourceMappingURL=index.cjs.map