{"version":3,"sources":["../../../src/utils/index.ts","../../../src/utils/stream-map.ts","../../../src/utils/rebuffer.ts","../../../src/utils/stream2string.ts","../../../src/result.ts","../../../src/utils/coerce-uint8.ts","../../../src/txt-en-decoder.ts","../../../src/utils/string2stream.ts","../../../src/utils/console-write-stream.ts","../../../src/utils/fanout-write-stream.ts","../../../src/types.ts","../../../src/utils/get-params-result.ts","../../../src/utils/stripper.ts","../../../src/utils/sorted-object.ts","../../../src/utils/uint8array-equal.ts"],"sourcesContent":["export * from \"./rebuffer.js\";\nexport * from \"./stream-map.js\";\nexport * from \"./stream2string.js\";\nexport * from \"./string2stream.js\";\nexport * from \"./console-write-stream.js\";\nexport * from \"./fanout-write-stream.js\";\nexport * from \"./get-params-result.js\";\nexport * from \"./stripper.js\";\nexport * from \"./sorted-object.js\";\nexport * from \"./uint8array-equal.js\";\nexport * from \"./coerce-uint8.js\";\n","export interface StreamMap<T, U> {\n  Map(s: T, idx: number): U | Promise<U>;\n  readonly Close?: () => void;\n}\nexport function streamMap<T, U>(s: ReadableStream<T>, sm: StreamMap<T, U>): ReadableStream<U> {\n  const state = { reader: s.getReader(), streamMap: sm, idx: 0 };\n  return new ReadableStream<U>({\n    async pull(controller): Promise<void> {\n      const { done, value } = await state.reader.read();\n      if (done) {\n        if (state.streamMap.Close) {\n          state.streamMap.Close();\n        }\n        controller.close();\n        return;\n      }\n      const promiseOrU = state.streamMap.Map(value, state.idx++);\n      let mapped: U;\n      if (promiseOrU instanceof Promise || typeof (promiseOrU as { then: () => void }).then === \"function\") {\n        mapped = await promiseOrU;\n      } else {\n        mapped = promiseOrU;\n      }\n      controller.enqueue(mapped);\n    },\n  });\n}\n\nexport async function devnull<T>(a: ReadableStream<T>): Promise<number> {\n  const reader = a.getReader();\n  let cnt = 0;\n  while (true) {\n    const { done } = await reader.read();\n    if (done) {\n      break;\n    }\n    cnt++;\n  }\n  return cnt;\n}\n\nexport function array2stream<T>(a: T[]): ReadableStream<T> {\n  let i = 0;\n  return new ReadableStream<T>({\n    pull(controller): void {\n      if (i >= a.length) {\n        controller.close();\n        return;\n      }\n      controller.enqueue(a[i]);\n      i++;\n    },\n  });\n}\n\nexport async function stream2array<T>(a: ReadableStream<T>): Promise<T[]> {\n  const ret: T[] = [];\n  const reader = a.getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    ret.push(value);\n  }\n  return ret;\n}\n","import { array2stream, stream2array } from \"./stream-map.js\";\n\ninterface ReChunkResult {\n  readonly rest: Uint8Array;\n  readonly chunk: Uint8Array;\n}\n\nexport async function rebufferArray(a: Uint8Array[], chunkSize: number): Promise<Uint8Array[]> {\n  return stream2array(rebuffer(array2stream(a), chunkSize));\n}\n\nfunction reChunk(cs: Uint8Array[], chunkSize: number): ReChunkResult {\n  const len = cs.reduce((acc, v) => acc + v.length, 0);\n  const last = cs[cs.length - 1];\n  const lastOfs = len - last.length;\n  // console.log(\"reChunk\", len, lastOfs, last.length, chunkSize, chunkSize - lastOfs)\n  const rest = last.subarray(chunkSize - lastOfs);\n  cs[cs.length - 1] = last.subarray(0, chunkSize - lastOfs);\n  const chunk = new Uint8Array(chunkSize);\n  let ofs = 0;\n  for (const c of cs) {\n    chunk.set(c, ofs);\n    ofs += c.length;\n  }\n  return { rest, chunk };\n}\n\ninterface pumpState {\n  readonly reader: ReadableStreamDefaultReader<Uint8Array>;\n  tmp: Uint8Array[];\n  tmpLen: number;\n  readonly chunkSize: number;\n}\n\nfunction pump(ps: pumpState, controller: ReadableStreamDefaultController<Uint8Array>, next: () => void): void {\n  ps.reader\n    .read()\n    .then(({ done, value }) => {\n      if (done) {\n        if (ps.tmpLen > 0) {\n          controller.enqueue(reChunk(ps.tmp, ps.tmpLen).chunk);\n        }\n        controller.close();\n        next();\n        return;\n      }\n      if (ps.tmpLen + value.length > ps.chunkSize) {\n        ps.tmp.push(value);\n        const res = reChunk(ps.tmp, ps.chunkSize);\n        controller.enqueue(res.chunk);\n        ps.tmp = [res.rest];\n        ps.tmpLen = res.rest.length;\n        next();\n        return;\n      } else if (value.length) {\n        ps.tmp.push(value);\n        ps.tmpLen += value.length;\n      }\n      pump(ps, controller, next);\n    })\n    .catch((err) => {\n      controller.error(err);\n      next();\n    });\n}\n\nexport function rebuffer(a: ReadableStream<Uint8Array>, chunkSize: number): ReadableStream<Uint8Array> {\n  const state: pumpState = {\n    reader: a.getReader(),\n    tmp: [],\n    tmpLen: 0,\n    chunkSize,\n  };\n  return new ReadableStream<Uint8Array>({\n    async pull(controller): Promise<void> {\n      return new Promise<void>((resolve) => {\n        pump(state, controller, resolve);\n      });\n    },\n  });\n}\n","export async function stream2string(stream?: ReadableStream<Uint8Array> | null, maxSize?: number): Promise<string> {\n  if (!stream) {\n    return Promise.resolve(\"\");\n  }\n  const reader = stream.getReader();\n  let res = \"\";\n  const decoder = new TextDecoder();\n  let rSize = 0;\n  while (typeof maxSize === \"undefined\" || rSize < maxSize) {\n    try {\n      const read = await reader.read();\n      if (read.done) {\n        break;\n      }\n      if (maxSize && rSize + read.value.length > maxSize) {\n        read.value = read.value.slice(0, maxSize - rSize);\n      }\n      const block = decoder.decode(read.value, { stream: true });\n      rSize += read.value.length;\n      res += block;\n    } catch (err) {\n      return Promise.reject(err as Error);\n    }\n  }\n  return Promise.resolve(res);\n}\n\nexport async function stream2uint8array(stream?: ReadableStream<Uint8Array> | null): Promise<Uint8Array> {\n  if (!stream) {\n    return Promise.resolve(new Uint8Array());\n  }\n  const reader = stream.getReader();\n  let res = new Uint8Array();\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    try {\n      const { done, value } = await reader.read();\n      if (done) {\n        break;\n      }\n      res = new Uint8Array([...res, ...value]);\n    } catch (err) {\n      return Promise.reject(err as Error);\n    }\n  }\n  return Promise.resolve(res);\n}\n","export abstract class Result<T, E = Error> {\n  static Ok<T = void>(t: T): Result<T, Error> {\n    return new ResultOK(t);\n  }\n  static Err<T, E extends Error = Error>(t: E | string | Result<unknown, E>): Result<T, E> {\n    if (typeof t === \"string\") {\n      return new ResultError(new Error(t) as E);\n    }\n    if (Result.Is(t)) {\n      if (t.is_ok()) {\n        return new ResultError(new Error(\"Result Error is Ok\") as E);\n      }\n      return t as Result<T, E>;\n    }\n    return new ResultError(t);\n  }\n  static Is<T>(t: unknown): t is Result<T> {\n    if (!t) {\n      return false;\n    }\n    if (t instanceof Result) {\n      return true;\n    }\n    const rt = t as Result<T>;\n    if ([typeof rt.is_ok, typeof rt.is_err, typeof rt.unwrap, typeof rt.unwrap_err].every((x) => x === \"function\")) {\n      return true;\n    }\n    return false;\n  }\n\n  isOk(): boolean {\n    return this.is_ok();\n  }\n  isErr(): boolean {\n    return this.is_err();\n  }\n\n  Ok(): T {\n    return this.unwrap();\n  }\n  Err(): E {\n    return this.unwrap_err();\n  }\n\n  abstract is_ok(): boolean;\n  abstract is_err(): boolean;\n  abstract unwrap(): T;\n  abstract unwrap_err(): E;\n}\n\nexport class ResultOK<T> extends Result<T, Error> {\n  private _t: T;\n  constructor(t: T) {\n    super();\n    this._t = t;\n  }\n  is_ok(): boolean {\n    return true;\n  }\n  is_err(): boolean {\n    return false;\n  }\n  unwrap_err(): Error {\n    throw new Error(\"Result is Ok\");\n  }\n  unwrap(): T {\n    return this._t;\n  }\n}\n\nexport class ResultError<T extends Error> extends Result<never, T> {\n  private _error: T;\n  constructor(t: T) {\n    super();\n    this._error = t;\n  }\n  is_ok(): boolean {\n    return false;\n  }\n  is_err(): boolean {\n    return true;\n  }\n  unwrap(): never {\n    throw new Error(`Result is Err: ${this._error}`);\n  }\n  unwrap_err(): T {\n    return this._error;\n  }\n}\n\nexport type WithoutResult<T> = T extends Result<infer U> ? U : T;\n\n// type WithoutPromise<T> = T extends Promise<infer U> ? U : T;\ntype WithResult<T> = T extends Promise<infer U> ? Promise<Result<U>> : Result<T>;\n\nexport function exception2Result<FN extends () => Promise<T> | T, T>(fn: FN): WithResult<ReturnType<FN>> {\n  try {\n    const res = fn();\n    if (res instanceof Promise) {\n      return res.then((value) => Result.Ok(value)).catch((e) => Result.Err(e)) as WithResult<ReturnType<FN>>;\n    }\n    return Result.Ok(res) as WithResult<ReturnType<FN>>;\n  } catch (e) {\n    return Result.Err(e as Error) as WithResult<ReturnType<FN>>;\n  }\n}\n\n/*\n\ntype FinalizedResult<T> = {\n  result: T;\n  scopeResult?: Result<void>;\n  finally: () => Promise<void>;\n}\n\ntype exection2ResultParam<T> = {\n  init: () => Promise<T>;\n  inScope?: (t: T) => Promise<void>;\n  cleanup: (t: T) => Promise<void>;\n\n}\n\nasync function expection2Result<T>({fn, inScope, cleanup}: exection2ResultParam<T>): Promise<Result<FinalizedResult<T>>> {\n  try {\n    const res = await fn();\n    if (inScope) {\n      try {\n        await inScope?.(res)\n      } catch (err) {\n        return Result.Err(err as Error)\n      }\n      await cleanup(res)\n      return Result.Ok({\n        result: res,\n        finally: async () => { }\n      })\n    }\n    return Result.Ok({\n      result: res ,\n      finally: async () => {\n        return cleanup(res)\n      }\n    })\n  } catch (err) {\n    return Result.Err(err as Error)\n  }\n}\n*/\n\n// await expection2Result({\n//   init: openDB,\n//   inScope: (res) => {\n//     res.query()\n//   },\n//   cleanup: async (y) => {\n//     await y.close()\n//  }\n// })\n// async function openDB() {\n//   try {\n//     const opendb = await openDB()\n//     return Result.Ok({\n//       openDB,\n//       finally: async () => {\n//         await opendb.close()\n//     }})\n//   } catch (err) {\n//     return Result.Err(err)\n//   }\n// }\n// }\n","import { Result } from \"../result.js\";\n\n// Tested in txt-en-decoder.test.ts\n\ninterface GlobalBuffer {\n  Buffer?: {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    isBuffer: (obj: any) => obj is {\n      buffer: ArrayBufferLike;\n      byteOffset: number;\n      byteLength: number;\n    };\n  };\n}\nconst globalBuffer = globalThis as GlobalBuffer;\n\nexport type ToUInt8Plain = Uint8Array | ArrayBuffer | ArrayBufferView;\nexport type ToUInt8Async = ToUInt8Plain | Blob;\nexport type ToUInt8 = ToUInt8Plain | Result<ToUInt8Plain>;\nexport type AsyncToUInt8 = ToUInt8Async | Result<ToUInt8Async> | Promise<ToUInt8Async> | Promise<Result<ToUInt8Async>>;\n\nexport function coerceIntoUint8(raw: ToUInt8): Result<Uint8Array> {\n  if (raw instanceof ArrayBuffer) {\n    return Result.Ok(new Uint8Array(raw));\n  }\n  if (ArrayBuffer.isView(raw)) {\n    return Result.Ok(new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength));\n  }\n  if (raw instanceof Blob) {\n    return Result.Err(\"Blob not supported\");\n  }\n  if (globalBuffer.Buffer && globalBuffer.Buffer.isBuffer(raw)) {\n    return Result.Ok(new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength));\n  }\n  if (raw instanceof Uint8Array) {\n    return Result.Ok(raw);\n  }\n  if (Result.Is(raw)) {\n    if (raw.isErr()) {\n      return Result.Err(raw);\n    }\n    return coerceIntoUint8(raw.unwrap());\n  }\n  return Result.Err(\"Not a Uint8Array\");\n}\n\nexport async function asyncCoerceIntoUint8(raw: AsyncToUInt8): Promise<Result<Uint8Array>> {\n  let resolved = await raw;\n  if (resolved instanceof Blob) {\n    resolved = await resolved.arrayBuffer();\n  }\n  return coerceIntoUint8(resolved as ToUInt8);\n}\n","import { Result } from \"./result.js\";\nimport { coerceIntoUint8, ToUInt8 } from \"./utils/coerce-uint8.js\";\n\nexport type ToEnDecoder = ToUInt8 | string | Result<string>;\nexport type AsyncToEnDecoder = ToEnDecoder | Blob | Promise<ToEnDecoder | Blob>;\n\nexport interface TxtEnDecoder {\n  encode(input: string): Uint8Array;\n  decode(input: ToEnDecoder): string;\n  asyncDecode(input: AsyncToEnDecoder): Promise<string>;\n}\n\nclass TxtOps implements TxtEnDecoder {\n  readonly encoder = new TextEncoder();\n  readonly decoder = new TextDecoder();\n\n  encode(str: string): Uint8Array {\n    return this.encoder.encode(str);\n  }\n  decode(data: ToEnDecoder): string {\n    if (Result.Is(data)) {\n      if (data.isErr()) {\n        throw data.Err();\n      }\n      // only for string let do coerceInto the work\n      const unwrapped = data.unwrap();\n      if (typeof unwrapped === \"string\") {\n        return this.decode(unwrapped);\n      }\n    }\n    if (typeof data === \"string\") {\n      return data;\n    }\n    return this.decoder.decode(coerceIntoUint8(data as ToUInt8).Ok());\n  }\n\n  async asyncDecode(data: AsyncToEnDecoder): Promise<string> {\n    let resolved = await data;\n    if (resolved instanceof Blob) {\n      resolved = await resolved.arrayBuffer();\n    }\n    return this.decode(resolved);\n  }\n}\n\nlet txtEnDecoder: TxtEnDecoder;\nexport function TxtEnDecoderSingleton(): TxtEnDecoder {\n  txtEnDecoder = txtEnDecoder ?? new TxtOps();\n  return txtEnDecoder;\n}\n","import { TxtEnDecoder, TxtEnDecoderSingleton } from \"../txt-en-decoder.js\";\n\nexport function string2stream(str: string, ende: TxtEnDecoder = TxtEnDecoderSingleton()): ReadableStream<Uint8Array> {\n  return uint8array2stream(ende.encode(str));\n}\n\nexport function uint8array2stream(str: Uint8Array): ReadableStream<Uint8Array> {\n  return new ReadableStream<Uint8Array>({\n    start(controller): void {\n      controller.enqueue(str);\n      controller.close();\n    },\n  });\n}\n","export class ConsoleWriterStreamDefaultWriter implements WritableStreamDefaultWriter<Uint8Array> {\n  readonly desiredSize: number | null = null;\n  readonly decoder: TextDecoder = new TextDecoder();\n\n  closed: Promise<undefined>;\n  ready: Promise<undefined>;\n  readonly _stream: ConsoleWriterStream;\n\n  constructor(private stream: ConsoleWriterStream) {\n    this._stream = stream;\n    this.ready = Promise.resolve(undefined);\n    this.closed = Promise.resolve(undefined);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any\n  abort(reason?: any): Promise<void> {\n    throw new Error(\"Method not implemented.\");\n  }\n  async close(): Promise<void> {\n    // noop\n  }\n  releaseLock(): void {\n    this._stream.locked = false;\n    this.ready = Promise.resolve(undefined);\n    this.closed = Promise.resolve(undefined);\n  }\n  write(chunk?: Uint8Array): Promise<void> {\n    let strObj: string | { level: string } = this.decoder.decode(chunk).trimEnd();\n    let output = \"log\";\n    try {\n      strObj = JSON.parse(strObj) as { level: string };\n      output = strObj.level;\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    } catch (e) {\n      /* noop */\n    }\n    switch (output) {\n      case \"error\":\n        // eslint-disable-next-line no-console\n        console.error(strObj);\n        break;\n      case \"warn\":\n        // eslint-disable-next-line no-console\n        console.warn(strObj);\n        break;\n      default:\n        // eslint-disable-next-line no-console\n        console.log(strObj);\n    }\n    return Promise.resolve();\n  }\n}\n\nexport class ConsoleWriterStream implements WritableStream<Uint8Array> {\n  locked = false;\n  _writer?: WritableStreamDefaultWriter<Uint8Array>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars\n  abort(reason?: any): Promise<void> {\n    throw new Error(\"Method not implemented.\");\n  }\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n  getWriter(): WritableStreamDefaultWriter<Uint8Array> {\n    if (this.locked) {\n      throw new Error(\"Stream is locked\");\n    }\n    this.locked = true;\n    if (!this._writer) {\n      this._writer = new ConsoleWriterStreamDefaultWriter(this);\n    }\n    return this._writer;\n  }\n}\n","export class FanoutWriteStream implements WritableStreamDefaultWriter<Uint8Array> {\n  readonly _writers: WritableStreamDefaultWriter<Uint8Array>[];\n  readonly ready: Promise<undefined>;\n  readonly closed: Promise<undefined>;\n  readonly desiredSize: number | null = null;\n  constructor(writers: WritableStreamDefaultWriter<Uint8Array>[]) {\n    this._writers = writers;\n    this.ready = Promise.all(this._writers.map((w) => w.ready)).then(() => undefined);\n    this.closed = Promise.all(this._writers.map((w) => w.closed)).then(() => undefined);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  abort(reason?: any): Promise<void> {\n    return Promise.all(this._writers.map((w) => w.abort(reason))).then(() => {\n      /* do nothing */\n    });\n  }\n  close(): Promise<void> {\n    return Promise.all(this._writers.map((w) => w.close())).then(() => {\n      /* do nothing */\n    });\n  }\n  releaseLock(): void {\n    this._writers.map((w) => w.releaseLock());\n  }\n\n  write(chunk?: Uint8Array): Promise<void> {\n    return Promise.all(this._writers.map((w) => w.write(chunk))).then(() => {\n      /* do nothing */\n    });\n  }\n}\n","interface IType {\n  readonly type: string;\n}\nclass _Required implements IType {\n  readonly type = \"REQUIRED\";\n}\n\nclass _Optional implements IType {\n  readonly type = \"OPTIONAL\";\n}\n\nexport const param: {\n  REQUIRED: _Required;\n  OPTIONAL: _Optional;\n} = {\n  REQUIRED: new _Required(),\n  OPTIONAL: new _Optional(),\n};\nexport type param = (typeof param)[keyof typeof param];\n","import { Result } from \"../result.js\";\nimport { param } from \"../types.js\";\n\nexport type MsgFn = (...keys: string[]) => string;\nexport type KeysParam = (string | MsgFn | Record<string, param | number | string | boolean | undefined | null>)[];\n\nexport function getParamsResult(\n  keys: KeysParam,\n  getParam: { getParam: (key: string) => string | undefined },\n): Result<Record<string, string>> {\n  const keyDef = keys.flat().reduce(\n    (acc, i) => {\n      if (typeof i === \"string\") {\n        acc.push({ key: i, def: undefined, isOptional: false });\n      } else if (typeof i === \"object\") {\n        acc.push(\n          ...Object.keys(i).map((k) => ({\n            key: k,\n            def: typeof i[k] === \"string\" ? i[k] : undefined,\n            isOptional: i[k] === param.OPTIONAL,\n          })),\n        );\n      }\n      return acc;\n    },\n    [] as { key: string; def?: string; isOptional: boolean }[],\n  );\n  //.filter((k) => typeof k === \"string\");\n  const msgFn =\n    keys.find((k) => typeof k === \"function\") ||\n    ((...keys: string[]): string => {\n      const msg = keys.join(\",\");\n      return `missing parameters: ${msg}`;\n    });\n  const errors: string[] = [];\n  const result: Record<string, string> = {};\n  for (const kd of keyDef) {\n    const val = getParam.getParam(kd.key);\n    if (val === undefined) {\n      if (typeof kd.def === \"string\") {\n        result[kd.key] = kd.def;\n      } else {\n        if (!kd.isOptional) {\n          errors.push(kd.key);\n        }\n      }\n    } else {\n      result[kd.key] = val;\n    }\n  }\n  if (errors.length) {\n    return Result.Err(msgFn(...errors));\n  }\n  return Result.Ok(result);\n}\n","export type StripCommand = string | RegExp;\n\nexport function stripper<T extends ArrayLike<S> | S, S>(\n  strip: StripCommand | StripCommand[],\n  obj: T,\n): T extends ArrayLike<unknown> ? Record<string, unknown>[] : Record<string, unknown> {\n  const strips = Array.isArray(strip) ? strip : [strip];\n  const restrips = strips.map((s) => {\n    if (typeof s === \"string\") {\n      const escaped = s.replace(/[-\\\\[\\]\\\\/\\\\{\\\\}\\\\(\\\\)\\\\*\\\\+\\\\?\\\\.\\\\\\\\^\\\\$\\\\|]/g, \"\\\\$&\");\n      return new RegExp(`^${escaped}$`);\n    }\n    return s;\n  });\n  return localStripper(undefined, restrips, obj) as T extends ArrayLike<unknown>\n    ? Record<string, unknown>[]\n    : Record<string, unknown>;\n}\n\nfunction localStripper<T>(path: string | undefined, restrips: RegExp[], obj: T): unknown {\n  if (typeof obj !== \"object\" || obj === null) {\n    return obj;\n  }\n  if (Array.isArray(obj)) {\n    return obj.map((i) => localStripper(path, restrips, i));\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const ret = { ...obj } as Record<string, any>;\n  const matcher = (key: string, nextPath: string): boolean => {\n    for (const re of restrips) {\n      if (re.test(key) || re.test(nextPath)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  for (const key in ret) {\n    if (Object.prototype.hasOwnProperty.call(ret, key)) {\n      let nextPath: string;\n      if (path) {\n        nextPath = [path, key].join(\".\");\n      } else {\n        nextPath = key;\n      }\n      if (matcher(key, nextPath)) {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete ret[key];\n        continue;\n      }\n      if (typeof ret[key] === \"object\") {\n        if (Array.isArray(ret[key])) {\n          ret[key] = ret[key].reduce((acc: unknown[], v, i) => {\n            const toDelete = matcher(key, `${nextPath}[${i}]`);\n            if (!toDelete) {\n              acc.push(localStripper(`${nextPath}[${i}]`, restrips, v));\n            }\n            return acc;\n          }, []);\n        } else {\n          ret[key] = localStripper(nextPath, restrips, ret[key]);\n        }\n      }\n    }\n  }\n  return ret;\n}\n","export function toSortedObjectArray<T>(set?: T): Record<string, unknown>[] {\n  if (!set) return [];\n  return toSortedArray(set).map(([k, v]) => ({ [k]: v }));\n}\n\nexport function toSortedArray<T>(set?: T): [string, unknown][] {\n  if (!set) return [];\n  return Object.entries(set).sort(([a], [b]) => a.localeCompare(b));\n}\n\nexport function toSortedObject<S, T extends NonNullable<S>>(set?: T): T {\n  if (!set) return set as T;\n  return Object.fromEntries(toSortedArray(set)) as T;\n  // return toSortedArray(set).reduce((acc, cur) => {\n  //     acc[cur[0]] = cur[1];\n  //     return acc\n  // }, {} as Record<string, unknown>) as T;\n}\n","export function UInt8ArrayEqual(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n"],"mappings":"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","names":["keys"]}