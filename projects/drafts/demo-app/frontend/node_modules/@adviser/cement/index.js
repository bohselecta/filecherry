import {
  BuildURI,
  IsLogger,
  JSONFormatter,
  Level,
  LevelHandlerImpl,
  LevelHandlerSingleton,
  LogCollector,
  LogValue,
  LogWriteStream,
  LoggerImpl,
  MockLogger,
  MutableURL,
  None,
  Option,
  Some,
  URI,
  YAMLFormatter,
  asyncLogValue,
  bin2string,
  bin2text,
  hasHostPartProtocols,
  isCoerceURI,
  isURL,
  logValue
} from "./chunk-UEER5ZC2.js";
import {
  utils_exports
} from "./chunk-55W4AK2Z.js";
import "./chunk-PHS255C5.js";
import "./chunk-H6MLKWIZ.js";
import {
  BaseSysAbstraction,
  ConstTime,
  EnvImpl,
  Future,
  IDMode,
  IdService,
  Keyed,
  KeyedResolvOnce,
  KeyedResolvSeq,
  LRUMap,
  LRUSet,
  RandomMode,
  RandomService,
  ResolveOnce,
  ResolveSeq,
  StepTime,
  String2TimeMode,
  SysTime,
  Time,
  TimeFactory,
  TimeMode,
  TimeUnits,
  WrapperSysAbstraction,
  envFactory,
  registerEnvAction,
  runtimeFn
} from "./chunk-23MCJYE6.js";
import {
  Result,
  ResultError,
  ResultOK,
  TxtEnDecoderSingleton,
  __privateAdd,
  __privateMethod,
  exception2Result,
  param
} from "./chunk-LXTKPZ6M.js";

// src/tracer.ts
var Metric = class {
  constructor(path) {
    this.path = path;
  }
  set(value) {
    this.value = value;
  }
  add(value) {
    if (typeof value === "number") {
      if (this.value === void 0) {
        this.value = 0;
      }
      this.value = this.value + value;
    } else if (Array.isArray(value)) {
      if (!Array.isArray(this.value)) {
        this.value = [];
      }
      this.value.push(...value);
    } else {
      throw new Error("add only support number or array");
    }
  }
};
var Metrics = class {
  constructor(tracenode) {
    this.spanRefs = /* @__PURE__ */ new Map();
    this.tracenode = tracenode;
    this.map = tracenode.ctx.metrics;
  }
  toJSON() {
    const obj = {};
    for (const [key, value] of this.map) {
      obj[key] = value.value;
    }
    return obj;
  }
  get(ipath) {
    const path = ipath.replace(/[/]+/g, "/").trim();
    if (path.startsWith("/")) {
      if (path.slice(1).length === 0) {
        throw new Error(`Metrics path must contain value /:${path}`);
      }
      let metric = this.map.get(path);
      if (!metric) {
        metric = new Metric(path);
        this.map.set(path, metric);
      }
      this.spanRefs.set(path, metric);
      return metric;
    } else if (path.includes("/")) {
      throw new Error(`Metrics path must start with /:${path}`);
    }
    const rootPath = this.tracenode.getRootPath();
    return this.get(`${rootPath}/${path}`);
  }
};
var TraceNode = class _TraceNode {
  constructor(ctx) {
    this.childs = /* @__PURE__ */ new Map();
    this.invokations = [];
    this.spanId = ctx.spanId;
    this.ctx = ctx;
    this.metrics = new Metrics(this);
  }
  static root(time, logger) {
    return new _TraceNode({
      spanId: "root",
      time,
      logger,
      metrics: /* @__PURE__ */ new Map(),
      parent: void 0
    });
  }
  getRootPath(rpath = []) {
    if (!this.ctx.parent) {
      return "/" + rpath.reverse().join("/");
    }
    return this.ctx.parent.getRootPath(rpath.concat(this.ctx.spanId));
  }
  invokes() {
    const cleanCtx = { ...this.ctx };
    delete cleanCtx.parent;
    delete cleanCtx.time;
    delete cleanCtx.logger;
    delete cleanCtx.metrics;
    const spanRefs = this.metrics.toJSON.call({ map: this.metrics.spanRefs });
    const metricsRefs = Object.keys(spanRefs).length > 0 ? { metricRefs: spanRefs } : {};
    return {
      ctx: cleanCtx,
      invokations: this.invokations,
      ...metricsRefs
    };
  }
  ctxWith(spanId, logger) {
    const ctx = {
      ...this.ctx,
      spanId
    };
    if (logger) {
      ctx.logger = logger;
    }
    return ctx;
  }
  // <V extends () => Promise<T> | T, T>(id: string, fn: V): ReturnType<V>
  span(inSpanId, fn) {
    let ctx;
    if (typeof inSpanId === "string") {
      ctx = {
        ...this.ctx,
        spanId: inSpanId,
        parent: this
      };
    } else {
      ctx = {
        ...this.ctx,
        ...inSpanId,
        parent: this
      };
    }
    if (ctx.logger) {
      ctx = {
        ...ctx,
        ...ctx.logger.Attributes()
      };
    }
    const spanId = ctx.spanId;
    let spanTrace = this.childs.get(spanId);
    if (!spanTrace) {
      spanTrace = new _TraceNode(ctx);
      this.childs.set(spanId.toString(), spanTrace);
    }
    const invokation = {
      start: this.ctx.time.Now().getTime(),
      end: 0,
      result: "success"
    };
    spanTrace.invokations.push(invokation);
    try {
      const possiblePromise = fn(spanTrace);
      if (possiblePromise instanceof Promise) {
        return possiblePromise.then((v) => {
          return v;
        }).catch((e) => {
          invokation.result = "error";
          throw e;
        }).finally(() => {
          invokation.end = this.ctx.time.Now().getTime();
        });
      }
      invokation.end = this.ctx.time.Now().getTime();
      return possiblePromise;
    } catch (e) {
      invokation.result = "error";
      invokation.end = this.ctx.time.Now().getTime();
      throw e;
    }
  }
};

// src/crypto.ts
function randomBytes(size) {
  const bytes = new Uint8Array(size);
  if (size > 0) {
    crypto.getRandomValues(bytes);
  }
  return bytes;
}
function digestSHA256(data) {
  return Promise.resolve(crypto.subtle.digest("SHA-256", data));
}
function toCryptoRuntime(cryptoOpts = {}) {
  const runtime = {
    importKey: cryptoOpts.importKey || crypto.subtle.importKey.bind(crypto.subtle),
    exportKey: cryptoOpts.exportKey || crypto.subtle.exportKey.bind(crypto.subtle),
    encrypt: cryptoOpts.encrypt || crypto.subtle.encrypt.bind(crypto.subtle),
    decrypt: cryptoOpts.decrypt || crypto.subtle.decrypt.bind(crypto.subtle),
    randomBytes: cryptoOpts.randomBytes || randomBytes,
    digestSHA256: cryptoOpts.digestSHA256 || digestSHA256
  };
  return runtime;
}

// src/version.ts
var VERSION = Object.keys({
  __packageVersion__: "xxxx"
})[0];

// src/http_header.ts
var HeadersImpl = class extends Headers {
  constructor(init) {
    super();
    this._headers = init;
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  entries() {
    return this._headers.entries();
  }
  keys() {
    return this._headers.keys();
  }
  values() {
    return this._headers.values();
  }
  append(key, value) {
    const values = this._headers.get(key);
    if (typeof value === "undefined") {
      value = "";
    }
    if (Array.isArray(value)) {
      this._headers.set(key, [values, ...value].filter((i) => i).join(", "));
    } else {
      this._headers.set(key, [values, value].filter((i) => i).join(", "));
    }
    return this;
  }
};
var HttpHeader = class _HttpHeader {
  constructor() {
    this._headers = /* @__PURE__ */ new Map();
  }
  static from(headers) {
    if (headers instanceof _HttpHeader) {
      return headers.Clone();
    }
    const h = new _HttpHeader();
    if (headers) {
      if (Array.isArray(headers)) {
        for (const [k, v] of headers) {
          if (v) {
            h.Add(k, v);
          }
        }
      } else if (headers instanceof Headers) {
        for (const [k, v] of headers.entries()) {
          if (v) {
            h.Add(
              k,
              v.split(",").map((v2) => v2.trim())
            );
          }
        }
      } else {
        for (const k in headers) {
          const v = headers[k];
          (Array.isArray(v) ? v : [v]).forEach((v2) => {
            h.Add(k, v2);
          });
        }
      }
    }
    return h;
  }
  _asStringString() {
    const ret = /* @__PURE__ */ new Map();
    for (const [key, values] of this._headers) {
      ret.set(key, values.join(", "));
    }
    return ret;
  }
  _key(key) {
    return key.toLowerCase();
  }
  Values(key) {
    const values = this._headers.get(this._key(key));
    return values || [];
  }
  Get(key) {
    const values = this._headers.get(this._key(key));
    if (values === void 0 || values.length === 0) {
      return void 0;
    }
    return values[0];
  }
  Set(key, valueOr) {
    const value = Array.isArray(valueOr) ? valueOr : [valueOr];
    this._headers.set(this._key(key), value);
    return this;
  }
  Add(key, value) {
    if (typeof value === "undefined") {
      return this;
    }
    const vs = Array.isArray(value) ? value : [value];
    const values = this._headers.get(this._key(key));
    if (values === void 0) {
      this._headers.set(this._key(key), vs);
    } else {
      values.push(...vs);
    }
    return this;
  }
  Del(ey) {
    this._headers.delete(this._key(ey));
    return this;
  }
  Items() {
    return Array.from(this._headers).filter(([_, vs]) => vs.length > 0);
  }
  SortItems() {
    return this.Items().sort(([[a]], [[b]]) => a.localeCompare(b));
  }
  Clone() {
    const clone = new _HttpHeader();
    for (const [key, values] of this._headers.entries()) {
      clone._headers.set(key, values.slice());
    }
    return clone;
  }
  AsRecordStringStringArray() {
    const obj = {};
    for (const [key, values] of this._headers.entries()) {
      obj[key] = [...values];
    }
    return obj;
  }
  AsRecordStringString() {
    const obj = {};
    for (const [key, values] of this._headers.entries()) {
      obj[key] = values.join(", ");
    }
    return obj;
  }
  AsHeaderInit() {
    const obj = {};
    for (const [key, values] of this._headers.entries()) {
      obj[key] = values[0];
    }
    return obj;
  }
  AsHeaders() {
    return new HeadersImpl(this._asStringString());
  }
  Merge(other) {
    const ret = this.Clone();
    if (other) {
      for (const [key, values] of other.Items()) {
        ret.Add(key, values);
      }
    }
    return ret;
  }
};

// src/path-ops.ts
var _pathOpsImpl_instances, parts_fn;
var pathOpsImpl = class {
  constructor() {
    __privateAdd(this, _pathOpsImpl_instances);
  }
  join(...paths) {
    return paths.map((i) => i.replace(/\/+$/, "")).join("/");
  }
  dirname(path) {
    return __privateMethod(this, _pathOpsImpl_instances, parts_fn).call(this, path).dirname;
  }
  basename(path) {
    return __privateMethod(this, _pathOpsImpl_instances, parts_fn).call(this, path).basename;
  }
};
_pathOpsImpl_instances = new WeakSet();
parts_fn = function(path) {
  const splitted = path.split("/");
  const last = splitted.pop();
  if (splitted.length && last === "") {
    return __privateMethod(this, _pathOpsImpl_instances, parts_fn).call(this, this.join(...splitted));
  }
  return {
    dirname: this.join(...splitted),
    basename: last != null ? last : ""
  };
};
var pathOps = new pathOpsImpl();

// src/json-en-decoder.ts
var JSONOps = class {
  constructor(txtOps) {
    this.txtOps = txtOps;
  }
  async asyncStringify(input, replacer, space) {
    const resolved = await input;
    return this.stringify(resolved, replacer, space);
  }
  async asyncUint8ify(input, replacer, space) {
    const resolved = await input;
    return this.uint8ify(resolved, replacer, space);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async asyncParse(input, reviver) {
    return this.parse(await this.txtOps.asyncDecode(input), reviver);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  stringify(input, replacer, space) {
    return JSON.stringify(Result.Is(input) ? input.unwrap() : input, replacer, space);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  uint8ify(input, replacer, space) {
    return this.txtOps.encode(this.stringify(input, replacer, space));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  parse(input, reviver) {
    return exception2Result(() => JSON.parse(this.txtOps.decode(input), reviver));
  }
};
var jsonEnDecoder;
function JSONEnDecoderSingleton(txtEnde) {
  let needNew = false;
  if (txtEnde && txtEnde !== TxtEnDecoderSingleton()) {
    needNew = !!txtEnde;
    txtEnde = txtEnde != null ? txtEnde : TxtEnDecoderSingleton();
  }
  if (needNew && txtEnde) {
    return new JSONOps(txtEnde);
  }
  jsonEnDecoder = jsonEnDecoder != null ? jsonEnDecoder : new JSONOps(TxtEnDecoderSingleton());
  return jsonEnDecoder;
}
export {
  BaseSysAbstraction,
  BuildURI,
  ConstTime,
  EnvImpl,
  Future,
  HeadersImpl,
  HttpHeader,
  IDMode,
  IdService,
  IsLogger,
  JSONEnDecoderSingleton,
  JSONFormatter,
  Keyed,
  KeyedResolvOnce,
  KeyedResolvSeq,
  LRUMap,
  LRUSet,
  Level,
  LevelHandlerImpl,
  LevelHandlerSingleton,
  LogCollector,
  LogValue,
  LogWriteStream,
  LoggerImpl,
  Metric,
  Metrics,
  MockLogger,
  MutableURL,
  None,
  Option,
  RandomMode,
  RandomService,
  ResolveOnce,
  ResolveSeq,
  Result,
  ResultError,
  ResultOK,
  Some,
  StepTime,
  String2TimeMode,
  SysTime,
  Time,
  TimeFactory,
  TimeMode,
  TimeUnits,
  TraceNode,
  TxtEnDecoderSingleton,
  URI,
  VERSION,
  WrapperSysAbstraction,
  YAMLFormatter,
  asyncLogValue,
  bin2string,
  bin2text,
  envFactory,
  exception2Result,
  hasHostPartProtocols,
  isCoerceURI,
  isURL,
  logValue,
  param,
  pathOps,
  registerEnvAction,
  runtimeFn,
  toCryptoRuntime,
  utils_exports as utils
};
//# sourceMappingURL=index.js.map