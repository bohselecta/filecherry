import {
  ConsoleWriterStream,
  FanoutWriteStream,
  stripper
} from "./chunk-PHS255C5.js";
import {
  WebSysAbstraction
} from "./chunk-H6MLKWIZ.js";
import {
  Future,
  runtimeFn
} from "./chunk-23MCJYE6.js";
import {
  Result,
  TxtEnDecoderSingleton,
  exception2Result,
  getParamsResult
} from "./chunk-LXTKPZ6M.js";

// src/test/log-write-stream.ts
var LogWriteStream = class {
  constructor(bufferArr) {
    this._resolveClosed = new Future();
    this.closed = this._resolveClosed.asPromise();
    this.desiredSize = null;
    this.ready = Promise.resolve(void 0);
    this._bufferArr = bufferArr;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
  abort(reason) {
    throw new Error("Method not implemented.");
  }
  async close() {
    await this.closed;
    return Promise.resolve(void 0);
  }
  releaseLock() {
  }
  async write(chunk) {
    if (chunk) {
      this._bufferArr.push(chunk);
    }
    return Promise.resolve(void 0);
  }
};
var LogCollector = class {
  constructor(pass, txtEnDe) {
    this.locked = false;
    this._bufferArr = [];
    this._pass = pass;
    this._txtEnDe = txtEnDe || TxtEnDecoderSingleton();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  abort(reason) {
    throw new Error("Method not implemented.");
  }
  async close() {
    if (this._writer) {
      const ret = await this._writer.close();
      this._writer = void 0;
      return ret;
    }
    return Promise.resolve(void 0);
  }
  getWriter() {
    if (!this._writer) {
      const dests = [new LogWriteStream(this._bufferArr)];
      if (this._pass) {
        dests.push(this._pass);
      }
      this._writer = new FanoutWriteStream(dests);
    }
    return this._writer;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  Logs(notJsonLine = false) {
    if (!this._writer) {
      return [];
    }
    const jsonNlStr = this._txtEnDe.decode(
      new Uint8Array(
        function* (res) {
          for (const x of res) {
            yield* x;
          }
        }(this._bufferArr)
      )
    );
    if (!notJsonLine) {
      const splitStr = jsonNlStr.split("\n");
      const filterStr = splitStr.filter((a) => a.length);
      const mapStr = filterStr.map((a) => JSON.parse(a));
      return mapStr;
    }
    return jsonNlStr.split("\n").filter((a) => a.length);
  }
};

// src/bin2text.ts
function bin2text(hex, lineFn, size = 0) {
  const arr = new Uint8Array(hex.buffer, hex.byteOffset, hex.byteLength);
  let cutted = "  ";
  if (size == 0) {
    size = arr.length;
  }
  size = Math.min(size, arr.length);
  const cols = 16;
  for (let line = 0; line < size; line += cols) {
    if (line + cols <= size || arr.length == size) {
    } else {
      line = arr.length - arr.length % cols;
      size = arr.length;
      cutted = ">>";
    }
    const l = [line.toString(16).padStart(4, "0"), cutted];
    for (let col = 0; col < cols; col++) {
      if (line + col < size) {
        l.push(arr[line + col].toString(16).padStart(2, "0"));
      } else {
        l.push("  ");
      }
      l.push(" ");
    }
    for (let col = 0; col < cols; col++) {
      if (line + col < size) {
        const ch = arr[line + col];
        l.push(ch >= 32 && ch < 127 ? String.fromCharCode(ch) : ".");
      }
    }
    lineFn(l.join(""));
  }
}
function bin2string(hex, size = 0) {
  const collector = [];
  bin2text(
    hex,
    (line) => {
      collector.push(line);
    },
    size
  );
  return collector.join("\n");
}

// src/logger.ts
var Level = {
  WARN: "warn",
  DEBUG: "debug",
  INFO: "info",
  ERROR: "error"
};
var LogValue = class {
  constructor(fn) {
    this.fn = fn;
  }
  value() {
    try {
      return this.fn();
    } catch (e) {
      return `LogValue:${e.message}`;
    }
  }
  toJSON() {
    return this.value();
  }
};
function asyncLogValue(val) {
  throw new Error("Not implemented");
}
function logValue(val, ctx) {
  return logValueInternal(val, {
    ...ctx,
    state: ctx.state || /* @__PURE__ */ new Set([Math.random()])
  });
}
function logValueInternal(val, ctx) {
  var _a, _b;
  ctx = {
    ...ctx,
    state: ctx.state || /* @__PURE__ */ new Set([Math.random()])
  };
  switch (typeof val) {
    case "function":
      return new LogValue(val);
    case "string": {
      try {
        const ret = JSON.parse(val);
        if (typeof ret === "object" && ret !== null) {
          return logValueInternal(ret, ctx);
        }
      } catch (e) {
        try {
          const url = new URL(val);
          return new LogValue(() => url.toString());
        } catch (e2) {
        }
      }
      if (val.match(/[\n\r]/)) {
        const lines = val.split(/[\n\r]+/).map((v) => v.trim());
        return new LogValue(() => lines);
      }
      return new LogValue(() => val.toString());
    }
    case "number":
      return new LogValue(() => val);
    case "boolean":
      return new LogValue(() => val);
    case "object": {
      if (val === null) {
        return new LogValue(() => "null");
      }
      if (ArrayBuffer.isView(val)) {
        try {
          const decoder = new TextDecoder();
          const asStr = decoder.decode(val);
          const obj = JSON.parse(asStr);
          return logValueInternal(obj, ctx);
        } catch (e) {
          return logValueInternal(bin2string(val, 512), ctx);
        }
      }
      if (Array.isArray(val)) {
        return new LogValue(
          () => val.map((v) => logValue(v, { ...ctx, state: void 0 }).value())
        );
      }
      if (val instanceof Headers) {
        return new LogValue(() => Object.fromEntries(val.entries()));
      }
      if (val instanceof ReadableStream) {
        return new LogValue(() => ">Stream<");
      }
      if (val instanceof Promise) {
        return new LogValue(() => ">Promise<");
      }
      if ((_a = ctx.state) == null ? void 0 : _a.has(val)) {
        return new LogValue(() => "...");
      }
      (_b = ctx.state) == null ? void 0 : _b.add(val);
      if (typeof val.toJSON === "function") {
        return new LogValue(() => val.toJSON());
      }
      const res = {};
      const typedVal = val;
      for (const key in typedVal) {
        if (ctx.ignoreAttr.IsSome() && ctx.ignoreAttr.unwrap().test(key)) {
          continue;
        }
        const element = typedVal[key];
        if (element instanceof LogValue) {
          res[key] = element;
        } else {
          if (typeof element !== "function") {
            res[key] = logValueInternal(element, ctx);
          }
        }
      }
      return new LogValue(() => res);
    }
    default:
      if (!val) {
        return new LogValue(() => "--Falsy--");
      }
      throw new Error(`Invalid type:${typeof val}`);
  }
}
function IsLogger(obj) {
  return typeof obj === "object" && [
    "Module",
    "EnableLevel",
    "DisableLevel",
    "SetDebug",
    "Str",
    "Error",
    "Warn",
    "Debug",
    "Log",
    "WithLevel",
    "Err",
    "Info",
    "Timestamp",
    "Any",
    "Dur",
    "Uint64"
  ].map((fn) => typeof obj[fn] === "function").reduce((a, b) => a && b, true);
}

// src/option.ts
var Option = class _Option {
  static Some(t) {
    return new Some(t);
  }
  static None() {
    return new None();
  }
  static Is(t) {
    return t instanceof _Option;
  }
  static From(t) {
    if (!t) {
      return new None();
    }
    return new Some(t);
  }
  IsNone() {
    return this.is_none();
  }
  IsSome() {
    return this.is_some();
  }
  Unwrap() {
    return this.unwrap();
  }
};
var Some = class extends Option {
  constructor(_t) {
    super();
    this._t = _t;
  }
  is_none() {
    return false;
  }
  is_some() {
    return true;
  }
  unwrap() {
    return this._t;
  }
};
var None = class extends Option {
  is_none() {
    return true;
  }
  is_some() {
    return false;
  }
  unwrap() {
    throw new Error("None.unwrap");
  }
};

// src/log-level-impl.ts
var LevelHandlerImpl = class {
  constructor() {
    this._globalLevels = /* @__PURE__ */ new Set([Level.INFO, Level.ERROR, Level.WARN]);
    this._modules = /* @__PURE__ */ new Map();
    this.ignoreAttr = Option.Some(/^_/);
    this.isStackExposed = false;
  }
  enableLevel(level, ...modules) {
    if (modules.length == 0) {
      this._globalLevels.add(level);
      return;
    }
    this.forModules(
      level,
      (p) => {
        this._modules.set(p, /* @__PURE__ */ new Set([...this._globalLevels, level]));
      },
      ...modules
    );
  }
  disableLevel(level, ...modules) {
    if (modules.length == 0) {
      this._globalLevels.delete(level);
      return;
    }
    this.forModules(
      level,
      (p) => {
        this._modules.delete(p);
      },
      ...modules
    );
  }
  setExposeStack(enable) {
    this.isStackExposed = !!enable;
  }
  setIgnoreAttr(re) {
    this.ignoreAttr = Option.From(re);
  }
  forModules(level, fnAction, ...modules) {
    for (const m of modules.flat()) {
      if (typeof m !== "string") {
        continue;
      }
      const parts = m.split(",").map((s) => s.trim()).filter((s) => s.length);
      for (const p of parts) {
        fnAction(p);
      }
    }
  }
  setDebug(...modules) {
    this.forModules(
      Level.DEBUG,
      (p) => {
        this._modules.set(p, /* @__PURE__ */ new Set([...this._globalLevels, Level.DEBUG]));
      },
      ...modules
    );
  }
  isEnabled(ilevel, module) {
    const level = ilevel;
    if (typeof module === "string") {
      const levels = this._modules.get(module);
      if (levels && levels.has(level)) {
        return true;
      }
    }
    const wlevel = this._modules.get("*");
    if (wlevel && typeof level === "string") {
      if (wlevel.has(level)) {
        return true;
      }
    }
    if (typeof level !== "string") {
      return true;
    }
    return this._globalLevels.has(level);
  }
};
var levelSingleton = new LevelHandlerImpl();
function LevelHandlerSingleton() {
  return levelSingleton;
}

// src/logger-impl.ts
import YAML from "yaml";

// src/utils/relative-path.ts
var PartType = {
  Slash: 1,
  Root: 3,
  Up: 4,
  Noop: 8
  // RootUp = 0x8 /* ../ */,
};
var Path = class {
  constructor(parts = []) {
    this.parts = parts;
  }
  toString() {
    return this.parts.map((part) => {
      if (typeof part === "string") {
        return part;
      } else {
        switch (part) {
          case PartType.Slash:
          case PartType.Root:
            return "/";
          case PartType.Up:
            return "..";
          default:
            return part;
        }
      }
    }).join("");
  }
  add(part) {
    if (this.parts.includes(PartType.Root) && part === PartType.Root) {
      throw new Error("Cannot add absolute part to absolute path");
    }
    const last = this.parts[this.parts.length - 1];
    if (last & PartType.Slash && part === PartType.Slash) {
      return;
    }
    switch (part) {
      case ".":
        this.parts.push(PartType.Noop);
        return;
      case "..":
        part = PartType.Up;
    }
    if (last === PartType.Noop && part === PartType.Slash) {
      if (last === PartType.Noop) {
        this.parts.pop();
      }
      return;
    }
    this.parts.push(part);
  }
};
function splitPath(path) {
  const p = new Path();
  if (path === "") {
    return p;
  }
  for (let count = 0; path.length; count++) {
    if (path.match(/^\/+/)) {
      if (count === 0) {
        p.add(PartType.Root);
      } else {
        p.add(PartType.Slash);
      }
      path = path.replace(/^\/+/, "");
    } else {
      const part = path.replace(/\/.*$/, "");
      p.add(part);
      path = path.replace(/^[^/]+/, "");
    }
  }
  return p;
}
function pathJoin(...paths) {
  let prev = "";
  const res = [];
  for (let i = 0; i < paths.length; i++) {
    const path = paths[i];
    if (path === "") {
      continue;
    }
    if (!(prev.endsWith("/") || path.startsWith("/"))) {
      if (prev !== "") {
        res.push("/");
      }
      res.push(path);
    } else {
      res.push(path);
    }
    prev = path;
  }
  return res.join("");
}
function relativePath(path, relative) {
  const relativeParts = splitPath(relative);
  let result;
  if (relativeParts.parts[0] === PartType.Root) {
    result = relative;
  } else {
    result = pathJoin(path, relative);
  }
  const unoptPath = splitPath(result);
  const out = [];
  let topUp = false;
  for (const part of unoptPath.parts) {
    switch (part) {
      case PartType.Root:
        out.push(PartType.Root);
        break;
      case PartType.Up:
        if (out.length && !topUp) {
          const last = out.length - 1;
          if (typeof out[last] === "string" && out[last - 1] == PartType.Root) {
            out.pop();
          } else {
            out.pop();
            out.pop();
          }
          if (out.length === 0) {
            topUp = !topUp ? true : topUp;
            out.push(PartType.Up);
          }
        } else {
          out.push(PartType.Up);
        }
        break;
      case PartType.Slash:
        if (!(out[out.length - 1] & PartType.Slash)) {
          out.push(PartType.Slash);
        }
        break;
      default:
        out.push(part);
        break;
    }
  }
  return new Path(out).toString();
}

// src/uri.ts
function match(iref, ioth) {
  const mr = {
    score: 0,
    protocol: false,
    hostname: false,
    port: false,
    pathname: false,
    pathParts: [],
    params: {}
  };
  const ref = URI.from(iref);
  const oth = URI.from(ioth);
  if (ref.protocol === oth.protocol) {
    mr.score += 1;
    mr.protocol = true;
  }
  try {
    const refH = ref.hostname;
    const refP = ref.port;
    if (refH === oth.hostname) {
      mr.score += 1;
      mr.hostname = true;
    }
    if (refP.length && refP === oth.port) {
      mr.score += 1;
      mr.port = true;
    }
  } catch (e) {
  }
  if (ref.pathname.length && ref.pathname !== "/") {
    const pref = ref.pathname.split("/").filter((p) => p.length);
    const poth = oth.pathname.split("/").filter((p) => p.length);
    for (let i = 0; i < pref.length && i < poth.length; i++) {
      if (poth[i] === pref[i]) {
        mr.score += 1;
        mr.pathname = true;
        mr.pathParts.push(pref[i]);
      }
    }
  }
  for (const [key, value] of ref.getParams) {
    if (oth.getParam(key) === value) {
      mr.score += 1;
      mr.params[key] = value;
    }
  }
  return mr;
}
function coerceKey(key, def) {
  if (typeof key === "object") {
    const keys = Object.keys(key);
    if (keys.length !== 1) {
      throw new Error(`Invalid key: ${JSON.stringify(key)}`);
    }
    return { key: keys[0], def: key[keys[0]] };
  }
  return { key, def };
}
function falsy2undef(value) {
  return value === void 0 || value === null ? void 0 : value;
}
function ensureURLWithDefaultProto(url, defaultProtocol) {
  if (!url) {
    return new MutableURL(`${defaultProtocol}//`);
  }
  if (typeof url === "string") {
    try {
      return new MutableURL(url);
    } catch (e) {
      return new MutableURL(`${defaultProtocol}//${url}`);
    }
  } else {
    return new MutableURL(url.toString());
  }
}
function isURL(value) {
  return value instanceof URL || !!value && typeof value.searchParams === "object" && typeof value.searchParams.sort === "function" && typeof value.hash === "string";
}
var MutableURL = class _MutableURL extends URL {
  constructor(urlStr) {
    super("defect://does.not.exist");
    const partedURL = urlStr.split(":");
    this._hasHostpart = hasHostPartProtocols.has(partedURL[0]);
    let hostPartUrl = ["http", ...partedURL.slice(1)].join(":");
    if (!this._hasHostpart) {
      const pathname = hostPartUrl.replace(/http:\/\/[/]*/, "").replace(/[#?].*$/, "");
      hostPartUrl = hostPartUrl.replace(/http:\/\//, `http://localhost/${pathname}`);
    }
    try {
      this._sysURL = new URL(hostPartUrl);
    } catch (ie) {
      const e = ie;
      e.message = `${e.message} for URL: ${urlStr}`;
      throw e;
    }
    this._protocol = `${partedURL[0]}:`;
    if (this._hasHostpart) {
      this._pathname = this._sysURL.pathname;
    } else {
      this._pathname = urlStr.replace(new RegExp(`^${this._protocol}//`), "").replace(/[#?].*$/, "");
    }
    this.hash = this._sysURL.hash;
  }
  clone() {
    return new _MutableURL(this.toString());
  }
  get host() {
    if (!this._hasHostpart) {
      throw new Error(
        `you can use hostname only if protocol is ${this.toString()} ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`
      );
    }
    return this._sysURL.host;
  }
  get port() {
    if (!this._hasHostpart) {
      throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
    }
    return this._sysURL.port;
  }
  set port(p) {
    if (!this._hasHostpart) {
      throw new Error(`you can use port only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
    }
    this._sysURL.port = p;
  }
  get hostname() {
    if (!this._hasHostpart) {
      throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
    }
    return this._sysURL.hostname;
  }
  set hostname(h) {
    if (!this._hasHostpart) {
      throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
    }
    this._sysURL.hostname = h;
  }
  set pathname(p) {
    this._pathname = p;
  }
  get pathname() {
    return this._pathname;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(p) {
    if (!p.endsWith(":")) {
      p = `${p}:`;
    }
    this._protocol = p;
  }
  get searchParams() {
    return this._sysURL.searchParams;
  }
  toString() {
    let search = "";
    if (this._sysURL.searchParams.size) {
      for (const [key, value] of Array.from(this._sysURL.searchParams.entries()).sort((a, b) => a[0].localeCompare(b[0]))) {
        search += `${!search.length ? "?" : "&"}${key}=${encodeURIComponent(value)}`;
      }
    }
    let hostpart = "";
    if (this._hasHostpart) {
      hostpart = this._sysURL.hostname;
      if (this._sysURL.port) {
        hostpart += `:${this._sysURL.port}`;
      }
      if (!this._pathname.startsWith("/")) {
        hostpart += "/";
      }
    }
    return `${this._protocol}//${hostpart}${this._pathname}${search}`;
  }
};
function from(fac, strURLUri, defaultProtocol) {
  switch (typeof falsy2undef(strURLUri)) {
    case "undefined":
      return fac(new MutableURL(`${defaultProtocol}///`));
    case "string":
      return fac(ensureURLWithDefaultProto(strURLUri, defaultProtocol));
    case "object":
      if (BuildURI.is(strURLUri)) {
        return fac(new MutableURL(strURLUri._url.toString()));
      } else if (URI.is(strURLUri)) {
        return fac(new MutableURL(strURLUri._url.toString()));
      } else if (isURL(strURLUri)) {
        return fac(new MutableURL(strURLUri.toString()));
      }
      throw new Error(`unknown object type: ${strURLUri}`);
    default:
      throw new Error(`Invalid argument: ${typeof strURLUri}`);
  }
}
function getParamResult(key, val, msgFn = (key2) => {
  return `missing parameter: ${key2}`;
}) {
  if (val === void 0) {
    return Result.Err(msgFn(key));
  }
  return Result.Ok(val);
}
var BuildURI = class _BuildURI {
  // pathname needs this
  constructor(url) {
    this._url = url;
  }
  static is(value) {
    return value instanceof _BuildURI || !!value && typeof value.delParam === "function" && typeof value.setParam === "function";
  }
  static from(strURLUri, defaultProtocol = "file:") {
    return from((url) => new _BuildURI(url), strURLUri, defaultProtocol);
  }
  match(other) {
    return match(this.URI(), URI.from(other));
  }
  port(p) {
    this._url.port = p;
    return this;
  }
  hostname(h) {
    this._url.hostname = h;
    return this;
  }
  protocol(p) {
    if (!p.endsWith(":")) {
      p = `${p}:`;
    }
    this._url.protocol = p;
    return this;
  }
  pathname(p) {
    this._url.pathname = p;
    return this;
  }
  // could pass a relative path or a full URL
  // if relative path, it will be appended to the current path
  resolve(p) {
    if (!p) {
      return this;
    }
    if (typeof p === "string") {
      if (!p.match(/^[a-zA-Z0-9]+:/)) {
        if (p.startsWith("/")) {
          this.pathname(p);
          return this;
        }
        return this.appendRelative(p);
      }
    }
    this._url = new MutableURL(p.toString());
    return this;
  }
  appendRelative(p) {
    const appendUrl = URI.from(p);
    const pathname = "./" + appendUrl.pathname;
    const basePath = this._url.pathname;
    this.pathname(relativePath(basePath, pathname));
    for (const [key, value] of appendUrl.getParams) {
      this.setParam(key, value);
    }
    return this;
  }
  cleanParams() {
    for (const key of Array.from(this._url.searchParams.keys())) {
      this._url.searchParams.delete(key);
    }
    return this;
  }
  delParam(key) {
    this._url.searchParams.delete(key);
    return this;
  }
  defParam(key, str) {
    if (!this._url.searchParams.has(key)) {
      this._url.searchParams.set(key, str);
    }
    return this;
  }
  setParam(key, str) {
    this._url.searchParams.set(key, str);
    return this;
  }
  hasParam(key) {
    return this._url.searchParams.has(key);
  }
  get getParams() {
    return this._url.searchParams.entries();
  }
  getParam(key, def) {
    const { key: k, def: d } = coerceKey(key, def);
    let val = this._url.searchParams.get(k);
    if (!falsy2undef(val) && d) {
      val = d;
    }
    return falsy2undef(val);
  }
  getParamResult(key, msgFn) {
    return getParamResult(key, this.getParam(key), msgFn);
  }
  getParamsResult(...keys) {
    return getParamsResult(keys, this);
  }
  toString() {
    this._url.searchParams.sort();
    return this._url.toString();
  }
  toJSON() {
    return this.toString();
  }
  asURL() {
    return this.URI().asURL();
  }
  asObj(...strips) {
    return this.URI().asObj(...strips);
  }
  clone() {
    return _BuildURI.from(this.toString());
  }
  URI() {
    return URI.from(this._url);
  }
};
function isCoerceURI(value) {
  if (!value) {
    return false;
  }
  if (isURL(value)) {
    return true;
  }
  if (URI.is(value)) {
    return true;
  }
  if (BuildURI.is(value)) {
    return true;
  }
  if (typeof value === "string") {
    return true;
  }
  return false;
}
var hasHostPartProtocols = /* @__PURE__ */ new Set(["http", "https", "ws", "wss"]);
var URI = class _URI {
  static protocolHasHostpart(protocol) {
    protocol = protocol.replace(/:$/, "");
    hasHostPartProtocols.add(protocol);
    return () => {
      hasHostPartProtocols.delete(protocol);
    };
  }
  match(other) {
    return match(this, other);
  }
  // if no protocol is provided, default to file:
  static merge(into, from2, defaultProtocol = "file:") {
    const intoUrl = BuildURI.from(into, defaultProtocol);
    const fromUrl = _URI.from(from2, defaultProtocol);
    intoUrl.protocol(fromUrl.protocol);
    const fPath = fromUrl.pathname;
    if (!(fPath.length === 0 || fPath === "/" || fPath === "./")) {
      intoUrl.pathname(fromUrl.pathname);
    }
    for (const [key, value] of fromUrl.getParams) {
      intoUrl.setParam(key, value);
    }
    return intoUrl.URI();
  }
  static is(value) {
    return value instanceof _URI || !!value && typeof value.asURL === "function" && typeof value.getParam === "function" && typeof value.hasParam === "function";
  }
  // if no protocol is provided, default to file:
  static from(strURLUri, defaultProtocol = "file:") {
    return from((url) => new _URI(url), strURLUri, defaultProtocol);
  }
  static fromResult(strURLUri, defaultProtocol = "file:") {
    return exception2Result(() => from((url) => new _URI(url), strURLUri, defaultProtocol));
  }
  constructor(url) {
    this._url = url.clone();
  }
  build() {
    return BuildURI.from(this._url);
  }
  get hostname() {
    return this._url.hostname;
  }
  // get password(): string {
  //   return this._url.password;
  // }
  get port() {
    return this._url.port;
  }
  get host() {
    return this._url.host;
  }
  // get username(): string {
  //   return this._url.username;
  // }
  // get search(): string {
  //   return this._url.search;
  // }
  get protocol() {
    return this._url.protocol;
  }
  get pathname() {
    return this._url.pathname;
  }
  // get hash(): string {
  //   return this._url.hash;
  // }
  // get host(): string {
  //   return this._url.host;
  // }
  get getParams() {
    return this._url.searchParams.entries();
  }
  hasParam(key) {
    return this._url.searchParams.has(key);
  }
  getParam(key, def) {
    const { key: k, def: d } = coerceKey(key, def);
    let val = this._url.searchParams.get(k);
    if (!falsy2undef(val) && d) {
      val = d;
    }
    return falsy2undef(val);
  }
  getParamResult(key, msgFn) {
    return getParamResult(key, this.getParam(key), msgFn);
  }
  getParamsResult(...keys) {
    return getParamsResult(keys, this);
  }
  clone() {
    return new _URI(this._url);
  }
  asURL() {
    return this._url.clone();
  }
  toString() {
    return this._url.toString();
  }
  toJSON() {
    return this.toString();
  }
  asObj(...strips) {
    const pathURI = {
      style: "path",
      protocol: this.protocol,
      pathname: this.pathname,
      searchParams: Object.fromEntries(this.getParams)
    };
    if (hasHostPartProtocols.has(this.protocol.replace(/:$/, ""))) {
      return stripper(strips, {
        ...pathURI,
        style: "host",
        hostname: this.hostname,
        port: this.port
      });
    }
    return stripper(strips, pathURI);
  }
};

// src/log-writer-impl.ts
var LogWriterStream = class {
  constructor(out) {
    this._toFlush = [];
    this._flushIsRunning = false;
    this._flushDoneFns = [];
    this._out = out;
  }
  write(encoded) {
    const my = async () => {
      try {
        const writer = this._out.getWriter();
        await writer.ready;
        await writer.write(encoded);
        writer.releaseLock();
      } catch (err) {
        console.error("Chunk error:", err);
      }
    };
    this._toFlush.push(my);
    this._flush();
  }
  _flush(toFlush = void 0, done) {
    if (done) {
      this._flushDoneFns.push(done);
    }
    if (this._toFlush.length == 0) {
      this._flushIsRunning = false;
      this._flushDoneFns.forEach((fn) => fn());
      this._flushDoneFns = [];
      return;
    }
    if (!toFlush && this._toFlush.length == 1 && !this._flushIsRunning) {
      this._flushIsRunning = true;
    } else if (!toFlush) {
      return;
    }
    const my = this._toFlush.shift();
    my == null ? void 0 : my().catch((e) => {
      console.error("Flush error:", e);
    }).finally(() => {
      this._flush(this._toFlush);
    });
  }
};

// src/logger-impl.ts
function getLen(value, lvs) {
  if (Array.isArray(value)) {
    return logValue(() => value.length, lvs);
  } else if (typeof value === "string") {
    return logValue(() => value.length, lvs);
  } else if (typeof value === "object" && value !== null) {
    if (typeof value.size === "number") {
      return logValue(() => value.size, lvs);
    } else if (typeof value.length === "number") {
      return logValue(() => value.length, lvs);
    }
    return logValue(() => Object.keys(value).length, lvs);
  }
  return logValue(() => -1, lvs);
}
function toLogValue(lop) {
  if (lop && typeof lop.then === "function") {
    throw new Error("async logValue Not implemented");
  }
  return lop;
}
var JSONFormatter = class {
  constructor(txtEnde, space) {
    this._txtEnDe = txtEnde;
    this._space = space;
  }
  format(attr) {
    let ret;
    try {
      ret = JSON.stringify(attr, null, this._space);
    } catch (e) {
      ret = JSON.stringify({ internal: { message: e.message, stack: e.stack } });
    }
    return this._txtEnDe.encode(ret + "\n");
  }
};
var YAMLFormatter = class {
  constructor(txtEnde, space) {
    this._txtEnDe = txtEnde;
    this._space = space;
  }
  format(attr) {
    return this._txtEnDe.encode("---\n" + YAML.stringify(attr, null, this._space) + "\n");
  }
};
function toLogValueCtx(lvh) {
  return {
    ignoreAttr: lvh.ignoreAttr
  };
}
var LoggerImpl = class _LoggerImpl {
  // readonly _id: string = "logger-" + Math.random().toString(36)
  constructor(params) {
    this._attributes = {};
    if (!params) {
      params = {};
    }
    if (!params.sys) {
      this._sys = WebSysAbstraction();
    } else {
      this._sys = params.sys;
    }
    if (!params.txtEnDe) {
      this._txtEnDe = TxtEnDecoderSingleton();
    } else {
      this._txtEnDe = params.txtEnDe;
    }
    if (!params.formatter) {
      this._formatter = new JSONFormatter(this._txtEnDe);
    } else {
      this._formatter = params.formatter;
    }
    if (params.logWriter) {
      this._logWriter = params.logWriter;
    } else {
      if (!params.out) {
        const rt = runtimeFn();
        let stream;
        if (rt.isBrowser) {
          stream = new ConsoleWriterStream();
        } else {
          if (rt.isNodeIsh || rt.isReactNative || rt.isDeno || rt.isCFWorker) {
            stream = this._sys.Stdout();
          } else {
            throw new Error("No output defined for runtime");
          }
        }
        this._logWriter = new LogWriterStream(stream);
      } else {
        this._logWriter = new LogWriterStream(params.out);
      }
    }
    if (!params.withAttributes) {
      this._withAttributes = {};
    } else {
      this._withAttributes = { ...params.withAttributes };
    }
    this._attributes = { ...this._withAttributes };
    if (params.levelHandler) {
      this.levelHandler = params.levelHandler;
    } else {
      this.levelHandler = LevelHandlerSingleton();
    }
  }
  TxtEnDe() {
    return this._txtEnDe;
  }
  Attributes() {
    return JSON.parse(JSON.stringify(this._attributes, null));
  }
  SetExposeStack(enable) {
    this.levelHandler.setExposeStack(enable);
    return this;
  }
  EnableLevel(level, ...modules) {
    this.levelHandler.enableLevel(level, ...modules);
    return this;
  }
  DisableLevel(level, ...modules) {
    this.levelHandler.disableLevel(level, ...modules);
    return this;
  }
  Module(key) {
    this._attributes["module"] = logValue(key, toLogValueCtx(this.levelHandler));
    this._withAttributes["module"] = logValue(key, toLogValueCtx(this.levelHandler));
    return this;
  }
  // if the string is "*" it will enable for all modules
  SetDebug(...modules) {
    this.levelHandler.setDebug(...modules);
    return this;
  }
  SetIgnoreAttribute(re) {
    this.levelHandler.setIgnoreAttr(re);
    return this;
  }
  SetFormatter(formatter) {
    this._formatter = formatter;
    return this;
  }
  Timestamp() {
    this._attributes["ts"] = logValue(() => this._sys.Time().Now().toISOString(), toLogValueCtx(this.levelHandler));
    return this;
  }
  Warn() {
    this._attributes["level"] = logValue(Level.WARN, toLogValueCtx(this.levelHandler));
    return this;
  }
  Log() {
    return this;
  }
  Debug() {
    this._attributes["level"] = logValue(Level.DEBUG, toLogValueCtx(this.levelHandler));
    return this;
  }
  Error() {
    this._attributes["level"] = logValue(Level.ERROR, toLogValueCtx(this.levelHandler));
    return this;
  }
  Info() {
    this._attributes["level"] = logValue(Level.INFO, toLogValueCtx(this.levelHandler));
    return this;
  }
  Err(err) {
    var _a;
    let key = "error";
    if (Result.Is(err)) {
      if (err.isOk()) {
        key = "noerror";
        err = err.Ok();
      } else {
        err = err.Err();
      }
    }
    if (err instanceof Error) {
      if (err.cause) {
        this.coerceKey(key, {
          message: err.message,
          cause: err.cause
        });
      } else {
        this._attributes[key] = logValue(err.message, toLogValueCtx(this.levelHandler));
      }
      if (this.levelHandler.isStackExposed) {
        this._attributes["stack"] = logValue(
          (_a = err.stack) == null ? void 0 : _a.split(/[\r\n]+/).map((s) => s.trim()),
          toLogValueCtx(this.levelHandler)
        );
      }
    } else {
      this.Any(key, err);
    }
    return this;
  }
  WithLevel(l) {
    this._attributes["level"] = logValue(l, toLogValueCtx(this.levelHandler));
    return this;
  }
  Ref(key, action) {
    if (typeof action === "function") {
      this._attributes[key] = logValue(action, toLogValueCtx(this.levelHandler));
    } else if (typeof action.toString === "function") {
      this._attributes[key] = logValue(() => action.toString(), toLogValueCtx(this.levelHandler));
    } else {
      this._attributes[key] = logValue("INVALID REF", toLogValueCtx(this.levelHandler));
    }
    return this;
  }
  Bool(key, value) {
    this.coerceKey(key, !!value);
    return this;
  }
  Http(...mix) {
    const key = mix.find((x) => typeof x === "string");
    mix = mix.filter((x) => typeof x !== "string");
    const resErrors = mix.filter((x) => Result.Is(x) && x.isErr());
    if (resErrors.length) {
      this.Err(resErrors.map((x) => x.Err().message).join("\n"));
      return this;
    }
    const req = mix.map((reqOrResult) => Result.Is(reqOrResult) ? reqOrResult.Ok() : reqOrResult).find((req2) => typeof req2.status !== "number");
    const res = mix.map((resOrResult) => Result.Is(resOrResult) ? resOrResult.Ok() : resOrResult).find((res2) => typeof res2.status === "number");
    let reqAndOrres;
    if (res && req) {
      reqAndOrres = { res, req };
    } else if (!res && !req) {
      reqAndOrres = void 0;
    } else if (res) {
      reqAndOrres = res;
    } else if (req) {
      reqAndOrres = req;
    }
    if (reqAndOrres) {
      this.Any(key || "Http", reqAndOrres);
    }
    return this;
  }
  Pair(x) {
    for (const key of Object.keys(x)) {
      const value = x[key];
      if (value instanceof LogValue) {
        this._attributes[key] = value;
        continue;
      }
      if (Result.Is(value)) {
        this.Result(key, value);
        continue;
      }
      this.Any(key, value);
    }
    return this;
  }
  Result(key, res) {
    if (res.isOk()) {
      this._attributes[key] = logValue(res.Ok(), toLogValueCtx(this.levelHandler));
    } else {
      this.Err(res.Err());
    }
    return this;
  }
  Len(value, key = "len") {
    this._attributes[key] = getLen(value, toLogValueCtx(this.levelHandler));
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  Hash(value, key = "hash") {
    throw new Error("Not implemented");
  }
  Url(url, key = "url") {
    this.Ref(key, () => URI.from(url).toString());
    return this;
  }
  coerceKey(key, value) {
    if (typeof key === "string") {
      this._attributes[key] = logValue(value, toLogValueCtx(this.levelHandler));
    } else {
      this.Pair(key);
    }
  }
  Str(key, value) {
    this.coerceKey(key, value);
    return this;
  }
  Any(key, value) {
    this.coerceKey(key, value);
    return this;
  }
  Dur(key, nsec) {
    this._attributes[key] = logValue(`${nsec}ms`, toLogValueCtx(this.levelHandler));
    return this;
  }
  Uint64(key, value) {
    this.coerceKey(key, value);
    return this;
  }
  Int(key, value) {
    return this.Uint64(key, value);
  }
  async Flush() {
    return new Promise((resolve) => {
      this._logWriter._flush(void 0, resolve);
    });
  }
  With() {
    return new WithLoggerBuilder(
      new _LoggerImpl({
        logWriter: this._logWriter,
        sys: this._sys,
        levelHandler: this.levelHandler,
        formatter: this._formatter,
        withAttributes: {
          module: this._attributes["module"],
          ...this._withAttributes
        }
      })
    );
  }
  _resetAttributes(fn) {
    const ret = fn();
    Object.keys(this._attributes).forEach((key) => {
      delete this._attributes[key];
    });
    Object.assign(this._attributes, this._withAttributes);
    return ret;
  }
  Msg(...args) {
    const fnError = this._resetAttributes(() => {
      var _a, _b;
      const doWrite = this.levelHandler.isEnabled(
        (_a = toLogValue(this._attributes["level"])) == null ? void 0 : _a.value(),
        (_b = toLogValue(this._attributes["module"])) == null ? void 0 : _b.value()
      );
      this._attributes["msg"] = logValue(args.join(" "), toLogValueCtx(this.levelHandler));
      const msg = this._attributes["msg"].value();
      if (typeof msg === "string" && !msg.trim().length) {
        delete this._attributes["msg"];
      }
      let fnRet = () => this._formatter.format({ ...this._attributes });
      if (doWrite) {
        const encoded = fnRet();
        this._logWriter.write(encoded);
        fnRet = () => encoded;
      }
      return fnRet;
    });
    const asError = () => new Error(this._txtEnDe.decode(fnError()));
    return {
      ResultError: () => Result.Err(asError()),
      AsError: asError
    };
  }
};
var WithLoggerBuilder = class {
  constructor(li) {
    this._li = li;
    this.levelHandler = li.levelHandler;
  }
  TxtEnDe() {
    return this._li.TxtEnDe();
  }
  Logger() {
    Object.assign(this._li._withAttributes, this._li._attributes);
    return this._li;
  }
  Attributes() {
    return { ...this._li._attributes };
  }
  SetExposeStack(enable) {
    this._li.levelHandler.setExposeStack(enable);
    return this;
  }
  SetIgnoreAttribute(re) {
    this._li.levelHandler.setIgnoreAttr(re);
    return this;
  }
  SetFormatter(fmt) {
    this._li.SetFormatter(fmt);
    return this;
  }
  EnableLevel(level, ...modules) {
    this._li.levelHandler.enableLevel(level, ...modules);
    return this;
  }
  DisableLevel(level, ...modules) {
    this._li.levelHandler.enableLevel(level, ...modules);
    return this;
  }
  Module(key) {
    this._li.Module(key);
    return this;
  }
  SetDebug(...modules) {
    this._li.SetDebug(...modules);
    return this;
  }
  Http(...mix) {
    this._li.Http(...mix);
    return this;
  }
  Pair(x) {
    this._li.Pair(x);
    return this;
  }
  Str(key, value) {
    this._li.Str(key, value);
    return this;
  }
  Len(value, key) {
    this._li.Len(value, key);
    return this;
  }
  Hash(value, key) {
    this._li.Hash(value, key);
    return this;
  }
  Ref(key, action) {
    this._li.Ref(key, action);
    return this;
  }
  Bool(key, value) {
    this._li.Bool(key, value);
    return this;
  }
  Result(key, res) {
    this._li.Result(key, res);
    return this;
  }
  Url(url, key) {
    this._li.Url(url, key);
    return this;
  }
  Int(key, value) {
    this._li.Int(key, value);
    return this;
  }
  Log() {
    this._li.Log();
    return this;
  }
  WithLevel(level) {
    this._li.WithLevel(level);
    return this;
  }
  Error() {
    this._li.Error();
    return this;
  }
  Warn() {
    this._li.Error();
    return this;
  }
  Debug() {
    this._li.Debug();
    return this;
  }
  Err(err) {
    this._li.Err(err);
    return this;
  }
  Info() {
    this._li.Info();
    return this;
  }
  Timestamp() {
    this._li.Timestamp();
    return this;
  }
  Any(key, value) {
    this._li.Any(key, value);
    return this;
  }
  Dur(key, nsec) {
    this._li.Dur(key, nsec);
    return this;
  }
  Uint64(key, value) {
    this._li.Uint64(key, value);
    return this;
  }
};

// src/test/mock-logger.ts
function MockLogger(params) {
  const lc = new LogCollector(params == null ? void 0 : params.pass);
  let modNames = ["MockLogger"];
  if (typeof (params == null ? void 0 : params.moduleName) === "string") {
    modNames = [params == null ? void 0 : params.moduleName];
  } else if (Array.isArray(params == null ? void 0 : params.moduleName)) {
    modNames = [...params.moduleName, ...modNames];
  }
  const logger = new LoggerImpl({
    out: lc,
    sys: params == null ? void 0 : params.sys,
    levelHandler: new LevelHandlerImpl()
  }).With().Module(modNames[0]).Logger();
  if (!(params == null ? void 0 : params.disableDebug)) {
    logger.SetDebug(...modNames);
  }
  return {
    logCollector: lc,
    logger
  };
}

export {
  bin2text,
  bin2string,
  Level,
  LogValue,
  asyncLogValue,
  logValue,
  IsLogger,
  isURL,
  MutableURL,
  BuildURI,
  isCoerceURI,
  hasHostPartProtocols,
  URI,
  Option,
  Some,
  None,
  LevelHandlerImpl,
  LevelHandlerSingleton,
  JSONFormatter,
  YAMLFormatter,
  LoggerImpl,
  LogWriteStream,
  LogCollector,
  MockLogger
};
//# sourceMappingURL=chunk-UEER5ZC2.js.map