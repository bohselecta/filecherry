"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/cf/index.ts
var cf_exports = {};
__export(cf_exports, {
  CFEnvActions: () => CFEnvActions,
  CFSysAbstraction: () => CFSysAbstraction,
  CFSystemService: () => CFSystemService
});
module.exports = __toCommonJS(cf_exports);

// src/sys-abstraction.ts
var TimeMode = {
  REAL: "real",
  CONST: "const",
  STEP: "step"
};
var RandomMode = {
  CONST: "const",
  STEP: "step",
  RANDOM: "random"
};
var IDMode = {
  UUID: "uuid",
  CONST: "const",
  STEP: "step"
};

// src/time.ts
var Time = class {
  TimeSince(start) {
    const now = this.Now();
    return now.getTime() - start.getTime();
  }
};
var TimeUnits = {
  Microsecond: 1,
  Second: 1e3 * 1,
  //Microsecond,
  Minute: 60 * 1e3 * 1,
  //Second,
  Hour: 60 * 60 * 1e3 * 1
  // Minute,
};

// src/base-sys-abstraction.ts
var SysTime = class extends Time {
  Now() {
    return /* @__PURE__ */ new Date();
  }
  Sleep(duration) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, duration);
    });
  }
};
var ConstTime = class extends Time {
  Now() {
    return new Date(2021, 1, 1, 0, 0, 0, 0);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  Sleep(duration) {
    return Promise.resolve();
  }
};
var StepTime = class extends Time {
  constructor() {
    super();
    this._step = new ConstTime().Now();
    this._start = this._step;
  }
  Now(steps = 1) {
    for (let i = 0; steps > 0 && i < steps; i++) {
      this._step = new Date(this._step.getTime() + 1e3);
    }
    if (steps < 1) {
      this._step = new Date(this._start.getTime() + steps * -1e3);
    }
    return this._step;
  }
  Sleep(duration) {
    this._step = new Date(this._step.getTime() + duration);
    return Promise.resolve();
  }
};
function TimeFactory(timeMode) {
  switch (timeMode) {
    case TimeMode.REAL:
      return new SysTime();
    case TimeMode.CONST:
      return new ConstTime();
    case TimeMode.STEP:
      return new StepTime();
  }
  return new SysTime();
}
var RandomService = class {
  constructor(mode) {
    this._step = 0;
    this._mode = mode;
  }
  Random0ToValue(value) {
    switch (this._mode) {
      case RandomMode.CONST:
        return 0.5 * value;
      case RandomMode.STEP:
        this._step += 1e-4;
        return this._step * value;
      case RandomMode.RANDOM:
        return Math.random() * value;
      default:
        throw new Error("Unknown RandomMode");
    }
  }
};
var IdService = class {
  constructor(mode) {
    this._step = 0;
    if (!mode) {
      mode = IDMode.UUID;
    }
    this._mode = mode;
  }
  NextId() {
    switch (this._mode) {
      case IDMode.UUID:
        return crypto.randomUUID();
      case IDMode.CONST:
        return "VeryUniqueID";
      case IDMode.STEP:
        return `STEPId-${this._step++}`;
      default:
        throw new Error("Unknown IDMode");
    }
  }
};
function consumeReadableStream(reader, writeFn) {
  reader.read().then(({ done, value }) => {
    if (done) {
      return;
    }
    writeFn(value).then(() => {
      consumeReadableStream(reader, writeFn);
    }).catch((e) => {
      console.error("consumeReadableStream:writeFn", e);
    });
  }).catch((e) => {
    console.error("consumeReadableStream:read", e);
  });
}
function CFWriteableStream(writeFn) {
  const ts = new TransformStream();
  consumeReadableStream(ts.readable.getReader(), writeFn);
  return ts.writable;
}
var BaseSysAbstraction = class {
  constructor(params) {
    this._time = new SysTime();
    this._idService = new IdService();
    this._randomService = new RandomService(RandomMode.RANDOM);
    this._fileSystem = params.FileSystem;
    this._systemService = params.SystemService;
    this._txtEnDe = params.TxtEnDecoder;
    const decoder = this._txtEnDe;
    this._stdout = CFWriteableStream((chunk) => {
      const decoded = decoder.decode(chunk);
      console.log(decoded.trimEnd());
      return Promise.resolve();
    });
    this._stderr = CFWriteableStream((chunk) => {
      const decoded = decoder.decode(chunk);
      console.error(decoded.trimEnd());
      return Promise.resolve();
    });
  }
};
var WrapperSysAbstraction = class {
  constructor(base, params) {
    this._time = base._time;
    this._stdout = base._stdout;
    this._stderr = base._stderr;
    this._idService = base._idService;
    this._randomService = base._randomService;
    this._fileSystem = base._fileSystem;
    this._systemService = base._systemService;
    if (params) {
      if (params.TimeMode) {
        this._time = TimeFactory(params.TimeMode);
      }
      if (params.Stdout) {
        this._stdout = params.Stdout;
      }
      if (params.Stderr) {
        this._stderr = params.Stderr;
      }
      if (params.IdMode) {
        this._idService = new IdService(params.IdMode);
      }
      if (params.RandomMode) {
        this._randomService = new RandomService(params.RandomMode);
      }
      if (params.FileSystem) {
        this._fileSystem = params.FileSystem;
      }
      if (params.SystemService) {
        this._systemService = params.SystemService;
      }
    }
  }
  Time() {
    return this._time;
  }
  NextId() {
    return this._idService.NextId();
  }
  Random0ToValue(value) {
    return this._randomService.Random0ToValue(value);
  }
  Stdout() {
    return this._stdout;
  }
  Stderr() {
    return this._stderr;
  }
  System() {
    return this._systemService;
  }
  FileSystem() {
    return this._fileSystem;
  }
};

// src/future.ts
var _promise, _resolveFn, _rejectFn;
var Future = class {
  constructor() {
    __privateAdd(this, _promise);
    __privateAdd(this, _resolveFn, () => {
      throw new Error("This Promise is not working as expected.");
    });
    __privateAdd(this, _rejectFn, () => {
      throw new Error("This Promise is not working as expected.");
    });
    __privateSet(this, _promise, new Promise((resolve, reject) => {
      __privateSet(this, _resolveFn, resolve);
      __privateSet(this, _rejectFn, reject);
    }));
  }
  async asPromise() {
    return __privateGet(this, _promise);
  }
  resolve(value) {
    __privateGet(this, _resolveFn).call(this, value);
  }
  reject(reason) {
    __privateGet(this, _rejectFn).call(this, reason);
  }
};
_promise = new WeakMap();
_resolveFn = new WeakMap();
_rejectFn = new WeakMap();

// src/lru-map-set.ts
var LRUMap = class {
  constructor(c = {}) {
    this._map = /* @__PURE__ */ new Map();
    this.param = {
      maxEntries: c.maxEntries || 100,
      maxAge: c.maxAge || 0
    };
  }
  touch(key) {
    if (!this._map.has(key)) {
      throw new Error(`key not found in cache: ${key}`);
    }
    const value = this._map.get(key);
    this._map.delete(key);
    this._map.set(key, value);
    return value;
  }
  setParam(param2 = {}) {
    if (typeof param2.maxEntries === "number") {
      this.param.maxEntries = param2.maxEntries;
      if (param2.maxEntries > 0 && this._map.size > param2.maxEntries) {
        const toDelete = [];
        let cacheSize = this._map.size;
        for (const key of this._map.keys()) {
          if (cacheSize > param2.maxEntries) {
            toDelete.push(key);
            cacheSize--;
          } else {
            break;
          }
        }
        for (const key of toDelete) {
          this._map.delete(key);
        }
      }
    }
  }
  has(key) {
    return this._map.has(key);
  }
  get size() {
    return this._map.size;
  }
  async getSet(key, createFN) {
    const val = this.get(key);
    if (val) {
      return val;
    } else {
      const val2 = await createFN(key);
      this.set(key, val2);
      return val2;
    }
  }
  get(key) {
    if (this._map.has(key)) {
      return this.touch(key);
    }
    return this._map.get(key);
  }
  set(key, value) {
    this._map.delete(key);
    if (this.param.maxEntries > 0 && this._map.size >= this.param.maxEntries) {
      this._map.delete(this._map.keys().next().value);
      this._map.set(key, value);
    } else {
      this._map.set(key, value);
    }
  }
  delete(key) {
    this._map.delete(key);
  }
  clear() {
    this._map.clear();
  }
  forEach(callbackfn) {
    this._map.forEach(callbackfn);
  }
  entries() {
    return this._map.entries();
  }
  // *entries(): IterableIterator<[T, K]> {
  //   for (const x of this._cache.entries()) {
  //     yield x;
  //   }
  // }
  //   getLeastRecent(): K {
  //     return Array.from(this.cache)[0];
  //   }
  //   getMostRecent(): K {
  //     return Array.from(this.cache)[this.cache.size - 1];
  //   }
};

// src/result.ts
var Result = class _Result {
  static Ok(t) {
    return new ResultOK(t);
  }
  static Err(t) {
    if (typeof t === "string") {
      return new ResultError(new Error(t));
    }
    if (_Result.Is(t)) {
      if (t.is_ok()) {
        return new ResultError(new Error("Result Error is Ok"));
      }
      return t;
    }
    return new ResultError(t);
  }
  static Is(t) {
    if (!t) {
      return false;
    }
    if (t instanceof _Result) {
      return true;
    }
    const rt = t;
    if ([typeof rt.is_ok, typeof rt.is_err, typeof rt.unwrap, typeof rt.unwrap_err].every((x) => x === "function")) {
      return true;
    }
    return false;
  }
  isOk() {
    return this.is_ok();
  }
  isErr() {
    return this.is_err();
  }
  Ok() {
    return this.unwrap();
  }
  Err() {
    return this.unwrap_err();
  }
};
var ResultOK = class extends Result {
  constructor(t) {
    super();
    this._t = t;
  }
  is_ok() {
    return true;
  }
  is_err() {
    return false;
  }
  unwrap_err() {
    throw new Error("Result is Ok");
  }
  unwrap() {
    return this._t;
  }
};
var ResultError = class extends Result {
  constructor(t) {
    super();
    this._error = t;
  }
  is_ok() {
    return false;
  }
  is_err() {
    return true;
  }
  unwrap() {
    throw new Error(`Result is Err: ${this._error}`);
  }
  unwrap_err() {
    return this._error;
  }
};

// src/resolve-once.ts
var ResolveOnce = class {
  constructor(ctx) {
    this._onceDone = false;
    this._onceFutures = [];
    this._onceOk = false;
    this._isPromise = false;
    this.ctx = ctx;
  }
  get ready() {
    return this._onceDone;
  }
  reset() {
    this._onceDone = false;
    this._onceOk = false;
    this._onceValue = void 0;
    this._onceError = void 0;
    if (this._inProgress) {
      const idx = this._onceFutures.findIndex((f) => f === this._inProgress);
      if (idx >= 0) {
        this._onceFutures.push(...this._onceFutures.splice(2).slice(1));
      }
    } else {
      this._onceFutures.length = 0;
    }
  }
  // T extends Option<infer U> ? U : T
  once(fn) {
    if (this._onceDone) {
      if (this._onceError) {
        if (this._isPromise) {
          return Promise.reject(this._onceError);
        } else {
          throw this._onceError;
        }
      }
      if (this._onceOk) {
        if (this._isPromise) {
          return Promise.resolve(this._onceValue);
        } else {
          return this._onceValue;
        }
      }
      throw new Error("ResolveOnce.once impossible");
    }
    const future = new Future();
    this._onceFutures.push(future);
    if (this._onceFutures.length === 1) {
      const okFn = (value) => {
        this._onceValue = value;
        this._onceOk = true;
        this._onceDone = true;
        if (this._isPromise) {
          this._onceFutures.forEach((f) => f.resolve(this._onceValue));
        }
        this._onceFutures.length = 0;
      };
      const catchFn = (e) => {
        this._onceError = e;
        this._onceOk = false;
        this._onceValue = void 0;
        this._onceDone = true;
        if (this._isPromise) {
          this._onceFutures.forEach((f) => f.reject(this._onceError));
        }
        this._onceFutures.length = 0;
      };
      this._inProgress = future;
      try {
        const ret = fn(this.ctx);
        if (typeof ret.then === "function") {
          this._isPromise = true;
          ret.then(okFn).catch(catchFn).finally(() => {
            this._inProgress = void 0;
          });
        } else {
          okFn(ret);
        }
      } catch (e) {
        catchFn(e);
      }
      if (!this._isPromise) {
        this._inProgress = void 0;
      }
    }
    if (this._isPromise) {
      return future.asPromise();
    } else {
      return this.once(fn);
    }
  }
};
var Keyed = class {
  constructor(factory, params) {
    var _a;
    this.factory = factory;
    this._map = new LRUMap((_a = params == null ? void 0 : params.lru) != null ? _a : { maxEntries: -1 });
  }
  setParam(params) {
    this._map.setParam(params.lru);
  }
  async asyncGet(key) {
    return this.get(await key());
  }
  get(key) {
    if (typeof key === "function") {
      key = key();
    }
    let keyed = this._map.get(key);
    if (!keyed) {
      keyed = this.factory(key);
      this._map.set(key, keyed);
    }
    return keyed;
  }
  unget(key) {
    const keyed = this._map.get(key);
    keyed == null ? void 0 : keyed.reset();
    this._map.delete(key);
  }
  reset() {
    this._map.forEach((keyed) => keyed.reset());
    this._map.clear();
  }
};
var KeyedResolvOnce = class extends Keyed {
  constructor(kp = {}) {
    super((key) => new ResolveOnce(key), kp);
  }
  /**
   *
   * @returns The values of the resolved keys
   */
  values() {
    return Array.from(this._map.entries()).filter(([_, v]) => v._onceDone).map(([k, v]) => {
      if (v._onceDone) {
        if (v._onceError) {
          return {
            key: k,
            value: Result.Err(v._onceError)
          };
        }
        return {
          key: k,
          value: Result.Ok(v._onceValue)
        };
      }
      throw new Error("KeyedResolvOnce.values impossible");
    });
  }
};

// src/runtime.ts
function isSet(value, ref = globalThis) {
  const [head, ...tail] = value.split(".");
  if (["object", "function"].includes(typeof ref) && ref && ["object", "function"].includes(typeof ref[head]) && ref[head]) {
    if (tail.length <= 1) {
      return true;
    }
    return isSet(tail.join("."), ref[head]);
  }
  return false;
}
function runtimeFn() {
  const gt = globalThis;
  let isReactNative = (
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    isSet("navigator.product") && typeof gt["navigator"] === "object" && gt["navigator"]["product"] === "ReactNative"
  );
  let isNodeIsh = false;
  if (!isSet("Deno")) {
    isNodeIsh = isSet("process.versions.node") && !isReactNative;
  }
  let isDeno = isSet("Deno");
  const isCFWorker = isSet("caches.default") && isSet("WebSocketPair");
  if (isCFWorker) {
    isDeno = false;
    isNodeIsh = false;
    isReactNative = false;
  }
  return {
    isNodeIsh,
    isBrowser: !(isNodeIsh || isDeno || isCFWorker || isReactNative),
    isDeno,
    isReactNative,
    isCFWorker
  };
}

// src/deno/deno-env-actions.ts
var once = new ResolveOnce();
var _deno;
var _DenoEnvActions = class _DenoEnvActions {
  constructor(opts) {
    __privateAdd(this, _deno, globalThis);
    this.opts = opts;
  }
  static new(opts) {
    return once.once(() => new _DenoEnvActions(opts));
  }
  get _env() {
    return __privateGet(this, _deno).Deno.env;
  }
  register(env) {
    for (const key of env.keys()) {
      this._env.set(key, env.get(key) || "");
    }
    return env;
  }
  active() {
    return runtimeFn().isDeno;
  }
  keys() {
    return Object.keys(this._env.toObject());
  }
  get(key) {
    return this._env.get(key);
  }
  set(key, value) {
    if (value) {
      this._env.set(key, value);
    }
  }
  delete(key) {
    this._env.delete(key);
  }
};
_deno = new WeakMap();
var DenoEnvActions = _DenoEnvActions;

// src/node/node-env-actions.ts
var once2 = new ResolveOnce();
var _node;
var _NodeEnvActions = class _NodeEnvActions {
  constructor(opts) {
    __privateAdd(this, _node, globalThis);
    this._env = this.active() ? __privateGet(this, _node).process.env : {};
    this.opts = opts;
  }
  static new(opts) {
    return once2.once(() => new _NodeEnvActions(opts));
  }
  register(env) {
    for (const key of env.keys()) {
      this._env[key] = env.get(key) || "";
    }
    return env;
  }
  active() {
    return runtimeFn().isNodeIsh;
  }
  keys() {
    return Object.keys(this._env);
  }
  get(key) {
    return this._env[key];
  }
  set(key, value) {
    if (value) {
      this._env[key] = value;
    }
  }
  delete(key) {
    delete this._env[key];
  }
};
_node = new WeakMap();
var NodeEnvActions = _NodeEnvActions;

// src/web/web-env-actions.ts
var once3 = new ResolveOnce();
var BrowserEnvActions = class _BrowserEnvActions {
  constructor(opts) {
    this.env = /* @__PURE__ */ new Map();
    this.opts = opts;
  }
  static new(opts) {
    return once3.once(() => new _BrowserEnvActions(opts));
  }
  get(key) {
    return this.env.get(key);
  }
  set(key, value) {
    if (value) {
      this.env.set(key, value);
    }
  }
  delete(key) {
    this.env.delete(key);
  }
  keys() {
    return Array.from(this.env.keys());
  }
  active() {
    return true;
  }
  register(env) {
    const sym = Symbol.for(this.opts.symbol || "CP_ENV");
    const browser = globalThis;
    browser[sym] = env;
    return env;
  }
};

// src/cf/cf-env-actions.ts
var once4 = new ResolveOnce();
var CFEnvActions = class _CFEnvActions {
  constructor(env) {
    this.injectOnRegister = {};
    this.cfEnv = new Map(Object.entries(env.presetEnv || {}));
  }
  static new(opts) {
    return once4.once(() => new _CFEnvActions(opts));
  }
  static inject(o) {
    const env = _CFEnvActions.new({});
    for (const key in o) {
      const value = o[key];
      if (typeof value === "string") {
        if (env.env) {
          env.env.set(key, value);
        } else {
          env.injectOnRegister[key] = value;
        }
      }
    }
  }
  active() {
    return runtimeFn().isCFWorker;
  }
  register(env) {
    this.env = env;
    for (const key in this.injectOnRegister) {
      env.set(key, this.injectOnRegister[key]);
    }
    return env;
  }
  get(key) {
    return this.cfEnv.get(key);
  }
  set(key, value) {
    if (value) {
      this.cfEnv.set(key, value);
    }
  }
  delete(key) {
    this.cfEnv.delete(key);
  }
  keys() {
    return Array.from(this.cfEnv.keys());
  }
};

// src/types.ts
var _Required = class {
  constructor() {
    this.type = "REQUIRED";
  }
};
var _Optional = class {
  constructor() {
    this.type = "OPTIONAL";
  }
};
var param = {
  REQUIRED: new _Required(),
  OPTIONAL: new _Optional()
};

// src/utils/get-params-result.ts
function getParamsResult(keys, getParam) {
  const keyDef = keys.flat().reduce(
    (acc, i) => {
      if (typeof i === "string") {
        acc.push({ key: i, def: void 0, isOptional: false });
      } else if (typeof i === "object") {
        acc.push(
          ...Object.keys(i).map((k) => ({
            key: k,
            def: typeof i[k] === "string" ? i[k] : void 0,
            isOptional: i[k] === param.OPTIONAL
          }))
        );
      }
      return acc;
    },
    []
  );
  const msgFn = keys.find((k) => typeof k === "function") || ((...keys2) => {
    const msg = keys2.join(",");
    return `missing parameters: ${msg}`;
  });
  const errors = [];
  const result = {};
  for (const kd of keyDef) {
    const val = getParam.getParam(kd.key);
    if (val === void 0) {
      if (typeof kd.def === "string") {
        result[kd.key] = kd.def;
      } else {
        if (!kd.isOptional) {
          errors.push(kd.key);
        }
      }
    } else {
      result[kd.key] = val;
    }
  }
  if (errors.length) {
    return Result.Err(msgFn(...errors));
  }
  return Result.Ok(result);
}

// src/sys-env.ts
var envActions = [
  { id: "cf", fn: (opts) => CFEnvActions.new(opts) },
  { id: "node", fn: (opts) => NodeEnvActions.new(opts) },
  { id: "deno", fn: (opts) => DenoEnvActions.new(opts) },
  { id: "browser", fn: (opts) => BrowserEnvActions.new(opts) }
];
var _envFactories = new KeyedResolvOnce();
function envFactory(opts = {}) {
  const found = envActions.find((fi) => fi.fn(opts).active());
  if (!found) {
    throw new Error("SysContainer:envFactory: no env available");
  }
  return _envFactories.get(found.id).once(() => {
    const action = found.fn(opts);
    const ret = new EnvImpl(action, opts);
    action.register(ret);
    return ret;
  });
}
function isIterable(obj) {
  if (obj == null) {
    return false;
  }
  return typeof obj[Symbol.iterator] === "function";
}
var EnvImpl = class {
  constructor(map, opts = {}) {
    this._onSet = [];
    this._map = map;
    this._updatePresets(opts.presetEnv);
  }
  gets(...kparams) {
    return getParamsResult(kparams, {
      getParam: (k) => this.get(k)
    });
  }
  sets(...keys) {
    keys.forEach((key) => {
      if (Array.isArray(key)) {
        if (key.length === 2) {
          const [k, v] = key;
          if (typeof k === "string" && typeof v === "string") {
            this.set(k, v);
            return;
          }
        }
        for (const item of key) {
          if (Array.isArray(item)) {
            if (item.length === 2) {
              const [k, v] = item;
              if (typeof k === "string" && typeof v === "string") {
                this.set(k, v);
              }
            }
          }
        }
      } else {
        if (isIterable(key)) {
          for (const [k, v] of key) {
            if (typeof k === "string" && typeof v === "string") {
              this.set(k, v);
            }
          }
        } else {
          const rKey = key;
          for (const k in rKey) {
            const v = rKey[k];
            if (typeof k === "string" && typeof v === "string") {
              this.set(k, v);
            }
          }
        }
      }
    });
  }
  _updatePresets(presetEnv) {
    if (!presetEnv) {
      return;
    }
    for (const [key, value] of presetEnv) {
      this._map.set(key, value);
    }
  }
  _applyOnSet(onSet, key, value) {
    onSet.forEach((item) => {
      let keys = [];
      if (key) {
        keys = [key];
      } else {
        keys = this._map.keys();
      }
      keys.filter((k) => {
        if (item.filter.size === 0) {
          return true;
        }
        if (item.filter.has(k)) {
          return true;
        }
        return false;
      }).forEach((k) => {
        let v;
        if (!key && !value) {
          v = this._map.get(k);
        } else if (key && !value) {
          v = void 0;
        } else {
          v = value;
        }
        item.fn(k, v);
      });
    });
  }
  keys() {
    return this._map.keys();
  }
  // filter is not set all sets passed
  onSet(fn, ...filter) {
    const item = { filter: new Set(filter), fn };
    this._onSet.push(item);
    this._applyOnSet([item]);
  }
  get(key) {
    return this._map.get(key);
  }
  set(key, value) {
    if (!value) {
      return;
    }
    this._map.set(key, value);
    this._applyOnSet(this._onSet, key, value);
  }
  delete(key) {
    this._map.delete(key);
    this._applyOnSet(this._onSet, key);
  }
};

// src/utils/coerce-uint8.ts
var globalBuffer = globalThis;
function coerceIntoUint8(raw) {
  if (raw instanceof ArrayBuffer) {
    return Result.Ok(new Uint8Array(raw));
  }
  if (ArrayBuffer.isView(raw)) {
    return Result.Ok(new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength));
  }
  if (raw instanceof Blob) {
    return Result.Err("Blob not supported");
  }
  if (globalBuffer.Buffer && globalBuffer.Buffer.isBuffer(raw)) {
    return Result.Ok(new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength));
  }
  if (raw instanceof Uint8Array) {
    return Result.Ok(raw);
  }
  if (Result.Is(raw)) {
    if (raw.isErr()) {
      return Result.Err(raw);
    }
    return coerceIntoUint8(raw.unwrap());
  }
  return Result.Err("Not a Uint8Array");
}

// src/txt-en-decoder.ts
var TxtOps = class {
  constructor() {
    this.encoder = new TextEncoder();
    this.decoder = new TextDecoder();
  }
  encode(str) {
    return this.encoder.encode(str);
  }
  decode(data) {
    if (Result.Is(data)) {
      if (data.isErr()) {
        throw data.Err();
      }
      const unwrapped = data.unwrap();
      if (typeof unwrapped === "string") {
        return this.decode(unwrapped);
      }
    }
    if (typeof data === "string") {
      return data;
    }
    return this.decoder.decode(coerceIntoUint8(data).Ok());
  }
  async asyncDecode(data) {
    let resolved = await data;
    if (resolved instanceof Blob) {
      resolved = await resolved.arrayBuffer();
    }
    return this.decode(resolved);
  }
};
var txtEnDecoder;
function TxtEnDecoderSingleton() {
  txtEnDecoder = txtEnDecoder != null ? txtEnDecoder : new TxtOps();
  return txtEnDecoder;
}

// src/web/web-sys-abstraction.ts
var WebFileService = class {
  get baseDir() {
    throw new Error("basedir-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  create(fname) {
    throw new Error("create-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  readFileString(fname) {
    throw new Error("readFileString-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  writeFileString(fname, content) {
    throw new Error("writeFileString-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  abs(fname) {
    throw new Error("abs-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  join(...paths) {
    throw new Error("join-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  relative(from, to) {
    throw new Error("relative-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  dirname(fname) {
    throw new Error("dirname-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  basename(fname) {
    throw new Error("basename-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  nodeImport(fname) {
    throw new Error("nodeImport-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isAbsolute(fname) {
    throw new Error("isAbsolute-Method not implemented.");
  }
};

// src/cf/cf-sys-abstraction.ts
var CFSystemService = class {
  Env() {
    return envFactory();
  }
  Args() {
    throw new Error("Args-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  OnExit(hdl) {
    throw new Error("OnExit-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  Exit(code) {
    throw new Error("Exit-Method not implemented.");
  }
};
var my = void 0;
function CFSysAbstraction(param2) {
  if (!my) {
    my = new BaseSysAbstraction({
      TxtEnDecoder: (param2 == null ? void 0 : param2.TxtEnDecoder) || TxtEnDecoderSingleton(),
      FileSystem: new WebFileService(),
      SystemService: new CFSystemService()
    });
  }
  return new WrapperSysAbstraction(my, param2);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CFEnvActions,
  CFSysAbstraction,
  CFSystemService
});
//# sourceMappingURL=index.cjs.map