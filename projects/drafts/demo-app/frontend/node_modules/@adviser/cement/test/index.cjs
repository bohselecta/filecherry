"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/test/index.ts
var test_exports = {};
__export(test_exports, {
  LogCollector: () => LogCollector,
  LogWriteStream: () => LogWriteStream,
  MockLogger: () => MockLogger
});
module.exports = __toCommonJS(test_exports);

// src/utils/fanout-write-stream.ts
var FanoutWriteStream = class {
  constructor(writers) {
    this.desiredSize = null;
    this._writers = writers;
    this.ready = Promise.all(this._writers.map((w) => w.ready)).then(() => void 0);
    this.closed = Promise.all(this._writers.map((w) => w.closed)).then(() => void 0);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  abort(reason) {
    return Promise.all(this._writers.map((w) => w.abort(reason))).then(() => {
    });
  }
  close() {
    return Promise.all(this._writers.map((w) => w.close())).then(() => {
    });
  }
  releaseLock() {
    this._writers.map((w) => w.releaseLock());
  }
  write(chunk) {
    return Promise.all(this._writers.map((w) => w.write(chunk))).then(() => {
    });
  }
};

// src/future.ts
var _promise, _resolveFn, _rejectFn;
var Future = class {
  constructor() {
    __privateAdd(this, _promise);
    __privateAdd(this, _resolveFn, () => {
      throw new Error("This Promise is not working as expected.");
    });
    __privateAdd(this, _rejectFn, () => {
      throw new Error("This Promise is not working as expected.");
    });
    __privateSet(this, _promise, new Promise((resolve, reject) => {
      __privateSet(this, _resolveFn, resolve);
      __privateSet(this, _rejectFn, reject);
    }));
  }
  async asPromise() {
    return __privateGet(this, _promise);
  }
  resolve(value) {
    __privateGet(this, _resolveFn).call(this, value);
  }
  reject(reason) {
    __privateGet(this, _rejectFn).call(this, reason);
  }
};
_promise = new WeakMap();
_resolveFn = new WeakMap();
_rejectFn = new WeakMap();

// src/result.ts
var Result = class _Result {
  static Ok(t) {
    return new ResultOK(t);
  }
  static Err(t) {
    if (typeof t === "string") {
      return new ResultError(new Error(t));
    }
    if (_Result.Is(t)) {
      if (t.is_ok()) {
        return new ResultError(new Error("Result Error is Ok"));
      }
      return t;
    }
    return new ResultError(t);
  }
  static Is(t) {
    if (!t) {
      return false;
    }
    if (t instanceof _Result) {
      return true;
    }
    const rt = t;
    if ([typeof rt.is_ok, typeof rt.is_err, typeof rt.unwrap, typeof rt.unwrap_err].every((x) => x === "function")) {
      return true;
    }
    return false;
  }
  isOk() {
    return this.is_ok();
  }
  isErr() {
    return this.is_err();
  }
  Ok() {
    return this.unwrap();
  }
  Err() {
    return this.unwrap_err();
  }
};
var ResultOK = class extends Result {
  constructor(t) {
    super();
    this._t = t;
  }
  is_ok() {
    return true;
  }
  is_err() {
    return false;
  }
  unwrap_err() {
    throw new Error("Result is Ok");
  }
  unwrap() {
    return this._t;
  }
};
var ResultError = class extends Result {
  constructor(t) {
    super();
    this._error = t;
  }
  is_ok() {
    return false;
  }
  is_err() {
    return true;
  }
  unwrap() {
    throw new Error(`Result is Err: ${this._error}`);
  }
  unwrap_err() {
    return this._error;
  }
};
function exception2Result(fn) {
  try {
    const res = fn();
    if (res instanceof Promise) {
      return res.then((value) => Result.Ok(value)).catch((e) => Result.Err(e));
    }
    return Result.Ok(res);
  } catch (e) {
    return Result.Err(e);
  }
}

// src/utils/coerce-uint8.ts
var globalBuffer = globalThis;
function coerceIntoUint8(raw) {
  if (raw instanceof ArrayBuffer) {
    return Result.Ok(new Uint8Array(raw));
  }
  if (ArrayBuffer.isView(raw)) {
    return Result.Ok(new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength));
  }
  if (raw instanceof Blob) {
    return Result.Err("Blob not supported");
  }
  if (globalBuffer.Buffer && globalBuffer.Buffer.isBuffer(raw)) {
    return Result.Ok(new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength));
  }
  if (raw instanceof Uint8Array) {
    return Result.Ok(raw);
  }
  if (Result.Is(raw)) {
    if (raw.isErr()) {
      return Result.Err(raw);
    }
    return coerceIntoUint8(raw.unwrap());
  }
  return Result.Err("Not a Uint8Array");
}

// src/txt-en-decoder.ts
var TxtOps = class {
  constructor() {
    this.encoder = new TextEncoder();
    this.decoder = new TextDecoder();
  }
  encode(str) {
    return this.encoder.encode(str);
  }
  decode(data) {
    if (Result.Is(data)) {
      if (data.isErr()) {
        throw data.Err();
      }
      const unwrapped = data.unwrap();
      if (typeof unwrapped === "string") {
        return this.decode(unwrapped);
      }
    }
    if (typeof data === "string") {
      return data;
    }
    return this.decoder.decode(coerceIntoUint8(data).Ok());
  }
  async asyncDecode(data) {
    let resolved = await data;
    if (resolved instanceof Blob) {
      resolved = await resolved.arrayBuffer();
    }
    return this.decode(resolved);
  }
};
var txtEnDecoder;
function TxtEnDecoderSingleton() {
  txtEnDecoder = txtEnDecoder != null ? txtEnDecoder : new TxtOps();
  return txtEnDecoder;
}

// src/test/log-write-stream.ts
var LogWriteStream = class {
  constructor(bufferArr) {
    this._resolveClosed = new Future();
    this.closed = this._resolveClosed.asPromise();
    this.desiredSize = null;
    this.ready = Promise.resolve(void 0);
    this._bufferArr = bufferArr;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
  abort(reason) {
    throw new Error("Method not implemented.");
  }
  async close() {
    await this.closed;
    return Promise.resolve(void 0);
  }
  releaseLock() {
  }
  async write(chunk) {
    if (chunk) {
      this._bufferArr.push(chunk);
    }
    return Promise.resolve(void 0);
  }
};
var LogCollector = class {
  constructor(pass, txtEnDe) {
    this.locked = false;
    this._bufferArr = [];
    this._pass = pass;
    this._txtEnDe = txtEnDe || TxtEnDecoderSingleton();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  abort(reason) {
    throw new Error("Method not implemented.");
  }
  async close() {
    if (this._writer) {
      const ret = await this._writer.close();
      this._writer = void 0;
      return ret;
    }
    return Promise.resolve(void 0);
  }
  getWriter() {
    if (!this._writer) {
      const dests = [new LogWriteStream(this._bufferArr)];
      if (this._pass) {
        dests.push(this._pass);
      }
      this._writer = new FanoutWriteStream(dests);
    }
    return this._writer;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  Logs(notJsonLine = false) {
    if (!this._writer) {
      return [];
    }
    const jsonNlStr = this._txtEnDe.decode(
      new Uint8Array(
        function* (res) {
          for (const x of res) {
            yield* x;
          }
        }(this._bufferArr)
      )
    );
    if (!notJsonLine) {
      const splitStr = jsonNlStr.split("\n");
      const filterStr = splitStr.filter((a) => a.length);
      const mapStr = filterStr.map((a) => JSON.parse(a));
      return mapStr;
    }
    return jsonNlStr.split("\n").filter((a) => a.length);
  }
};

// src/bin2text.ts
function bin2text(hex, lineFn, size = 0) {
  const arr = new Uint8Array(hex.buffer, hex.byteOffset, hex.byteLength);
  let cutted = "  ";
  if (size == 0) {
    size = arr.length;
  }
  size = Math.min(size, arr.length);
  const cols = 16;
  for (let line = 0; line < size; line += cols) {
    if (line + cols <= size || arr.length == size) {
    } else {
      line = arr.length - arr.length % cols;
      size = arr.length;
      cutted = ">>";
    }
    const l = [line.toString(16).padStart(4, "0"), cutted];
    for (let col = 0; col < cols; col++) {
      if (line + col < size) {
        l.push(arr[line + col].toString(16).padStart(2, "0"));
      } else {
        l.push("  ");
      }
      l.push(" ");
    }
    for (let col = 0; col < cols; col++) {
      if (line + col < size) {
        const ch = arr[line + col];
        l.push(ch >= 32 && ch < 127 ? String.fromCharCode(ch) : ".");
      }
    }
    lineFn(l.join(""));
  }
}
function bin2string(hex, size = 0) {
  const collector = [];
  bin2text(
    hex,
    (line) => {
      collector.push(line);
    },
    size
  );
  return collector.join("\n");
}

// src/logger.ts
var Level = {
  WARN: "warn",
  DEBUG: "debug",
  INFO: "info",
  ERROR: "error"
};
var LogValue = class {
  constructor(fn) {
    this.fn = fn;
  }
  value() {
    try {
      return this.fn();
    } catch (e) {
      return `LogValue:${e.message}`;
    }
  }
  toJSON() {
    return this.value();
  }
};
function logValue(val, ctx) {
  return logValueInternal(val, {
    ...ctx,
    state: ctx.state || /* @__PURE__ */ new Set([Math.random()])
  });
}
function logValueInternal(val, ctx) {
  var _a, _b;
  ctx = {
    ...ctx,
    state: ctx.state || /* @__PURE__ */ new Set([Math.random()])
  };
  switch (typeof val) {
    case "function":
      return new LogValue(val);
    case "string": {
      try {
        const ret = JSON.parse(val);
        if (typeof ret === "object" && ret !== null) {
          return logValueInternal(ret, ctx);
        }
      } catch (e) {
        try {
          const url = new URL(val);
          return new LogValue(() => url.toString());
        } catch (e2) {
        }
      }
      if (val.match(/[\n\r]/)) {
        const lines = val.split(/[\n\r]+/).map((v) => v.trim());
        return new LogValue(() => lines);
      }
      return new LogValue(() => val.toString());
    }
    case "number":
      return new LogValue(() => val);
    case "boolean":
      return new LogValue(() => val);
    case "object": {
      if (val === null) {
        return new LogValue(() => "null");
      }
      if (ArrayBuffer.isView(val)) {
        try {
          const decoder = new TextDecoder();
          const asStr = decoder.decode(val);
          const obj = JSON.parse(asStr);
          return logValueInternal(obj, ctx);
        } catch (e) {
          return logValueInternal(bin2string(val, 512), ctx);
        }
      }
      if (Array.isArray(val)) {
        return new LogValue(
          () => val.map((v) => logValue(v, { ...ctx, state: void 0 }).value())
        );
      }
      if (val instanceof Headers) {
        return new LogValue(() => Object.fromEntries(val.entries()));
      }
      if (val instanceof ReadableStream) {
        return new LogValue(() => ">Stream<");
      }
      if (val instanceof Promise) {
        return new LogValue(() => ">Promise<");
      }
      if ((_a = ctx.state) == null ? void 0 : _a.has(val)) {
        return new LogValue(() => "...");
      }
      (_b = ctx.state) == null ? void 0 : _b.add(val);
      if (typeof val.toJSON === "function") {
        return new LogValue(() => val.toJSON());
      }
      const res = {};
      const typedVal = val;
      for (const key in typedVal) {
        if (ctx.ignoreAttr.IsSome() && ctx.ignoreAttr.unwrap().test(key)) {
          continue;
        }
        const element = typedVal[key];
        if (element instanceof LogValue) {
          res[key] = element;
        } else {
          if (typeof element !== "function") {
            res[key] = logValueInternal(element, ctx);
          }
        }
      }
      return new LogValue(() => res);
    }
    default:
      if (!val) {
        return new LogValue(() => "--Falsy--");
      }
      throw new Error(`Invalid type:${typeof val}`);
  }
}

// src/option.ts
var Option = class _Option {
  static Some(t) {
    return new Some(t);
  }
  static None() {
    return new None();
  }
  static Is(t) {
    return t instanceof _Option;
  }
  static From(t) {
    if (!t) {
      return new None();
    }
    return new Some(t);
  }
  IsNone() {
    return this.is_none();
  }
  IsSome() {
    return this.is_some();
  }
  Unwrap() {
    return this.unwrap();
  }
};
var Some = class extends Option {
  constructor(_t) {
    super();
    this._t = _t;
  }
  is_none() {
    return false;
  }
  is_some() {
    return true;
  }
  unwrap() {
    return this._t;
  }
};
var None = class extends Option {
  is_none() {
    return true;
  }
  is_some() {
    return false;
  }
  unwrap() {
    throw new Error("None.unwrap");
  }
};

// src/log-level-impl.ts
var LevelHandlerImpl = class {
  constructor() {
    this._globalLevels = /* @__PURE__ */ new Set([Level.INFO, Level.ERROR, Level.WARN]);
    this._modules = /* @__PURE__ */ new Map();
    this.ignoreAttr = Option.Some(/^_/);
    this.isStackExposed = false;
  }
  enableLevel(level, ...modules) {
    if (modules.length == 0) {
      this._globalLevels.add(level);
      return;
    }
    this.forModules(
      level,
      (p) => {
        this._modules.set(p, /* @__PURE__ */ new Set([...this._globalLevels, level]));
      },
      ...modules
    );
  }
  disableLevel(level, ...modules) {
    if (modules.length == 0) {
      this._globalLevels.delete(level);
      return;
    }
    this.forModules(
      level,
      (p) => {
        this._modules.delete(p);
      },
      ...modules
    );
  }
  setExposeStack(enable) {
    this.isStackExposed = !!enable;
  }
  setIgnoreAttr(re) {
    this.ignoreAttr = Option.From(re);
  }
  forModules(level, fnAction, ...modules) {
    for (const m of modules.flat()) {
      if (typeof m !== "string") {
        continue;
      }
      const parts = m.split(",").map((s) => s.trim()).filter((s) => s.length);
      for (const p of parts) {
        fnAction(p);
      }
    }
  }
  setDebug(...modules) {
    this.forModules(
      Level.DEBUG,
      (p) => {
        this._modules.set(p, /* @__PURE__ */ new Set([...this._globalLevels, Level.DEBUG]));
      },
      ...modules
    );
  }
  isEnabled(ilevel, module2) {
    const level = ilevel;
    if (typeof module2 === "string") {
      const levels = this._modules.get(module2);
      if (levels && levels.has(level)) {
        return true;
      }
    }
    const wlevel = this._modules.get("*");
    if (wlevel && typeof level === "string") {
      if (wlevel.has(level)) {
        return true;
      }
    }
    if (typeof level !== "string") {
      return true;
    }
    return this._globalLevels.has(level);
  }
};
var levelSingleton = new LevelHandlerImpl();
function LevelHandlerSingleton() {
  return levelSingleton;
}

// src/logger-impl.ts
var import_yaml = __toESM(require("yaml"), 1);

// src/sys-abstraction.ts
var TimeMode = {
  REAL: "real",
  CONST: "const",
  STEP: "step"
};
var RandomMode = {
  CONST: "const",
  STEP: "step",
  RANDOM: "random"
};
var IDMode = {
  UUID: "uuid",
  CONST: "const",
  STEP: "step"
};

// src/time.ts
var Time = class {
  TimeSince(start) {
    const now = this.Now();
    return now.getTime() - start.getTime();
  }
};
var TimeUnits = {
  Microsecond: 1,
  Second: 1e3 * 1,
  //Microsecond,
  Minute: 60 * 1e3 * 1,
  //Second,
  Hour: 60 * 60 * 1e3 * 1
  // Minute,
};

// src/base-sys-abstraction.ts
var SysTime = class extends Time {
  Now() {
    return /* @__PURE__ */ new Date();
  }
  Sleep(duration) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, duration);
    });
  }
};
var ConstTime = class extends Time {
  Now() {
    return new Date(2021, 1, 1, 0, 0, 0, 0);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  Sleep(duration) {
    return Promise.resolve();
  }
};
var StepTime = class extends Time {
  constructor() {
    super();
    this._step = new ConstTime().Now();
    this._start = this._step;
  }
  Now(steps = 1) {
    for (let i = 0; steps > 0 && i < steps; i++) {
      this._step = new Date(this._step.getTime() + 1e3);
    }
    if (steps < 1) {
      this._step = new Date(this._start.getTime() + steps * -1e3);
    }
    return this._step;
  }
  Sleep(duration) {
    this._step = new Date(this._step.getTime() + duration);
    return Promise.resolve();
  }
};
function TimeFactory(timeMode) {
  switch (timeMode) {
    case TimeMode.REAL:
      return new SysTime();
    case TimeMode.CONST:
      return new ConstTime();
    case TimeMode.STEP:
      return new StepTime();
  }
  return new SysTime();
}
var RandomService = class {
  constructor(mode) {
    this._step = 0;
    this._mode = mode;
  }
  Random0ToValue(value) {
    switch (this._mode) {
      case RandomMode.CONST:
        return 0.5 * value;
      case RandomMode.STEP:
        this._step += 1e-4;
        return this._step * value;
      case RandomMode.RANDOM:
        return Math.random() * value;
      default:
        throw new Error("Unknown RandomMode");
    }
  }
};
var IdService = class {
  constructor(mode) {
    this._step = 0;
    if (!mode) {
      mode = IDMode.UUID;
    }
    this._mode = mode;
  }
  NextId() {
    switch (this._mode) {
      case IDMode.UUID:
        return crypto.randomUUID();
      case IDMode.CONST:
        return "VeryUniqueID";
      case IDMode.STEP:
        return `STEPId-${this._step++}`;
      default:
        throw new Error("Unknown IDMode");
    }
  }
};
function consumeReadableStream(reader, writeFn) {
  reader.read().then(({ done, value }) => {
    if (done) {
      return;
    }
    writeFn(value).then(() => {
      consumeReadableStream(reader, writeFn);
    }).catch((e) => {
      console.error("consumeReadableStream:writeFn", e);
    });
  }).catch((e) => {
    console.error("consumeReadableStream:read", e);
  });
}
function CFWriteableStream(writeFn) {
  const ts = new TransformStream();
  consumeReadableStream(ts.readable.getReader(), writeFn);
  return ts.writable;
}
var BaseSysAbstraction = class {
  constructor(params) {
    this._time = new SysTime();
    this._idService = new IdService();
    this._randomService = new RandomService(RandomMode.RANDOM);
    this._fileSystem = params.FileSystem;
    this._systemService = params.SystemService;
    this._txtEnDe = params.TxtEnDecoder;
    const decoder = this._txtEnDe;
    this._stdout = CFWriteableStream((chunk) => {
      const decoded = decoder.decode(chunk);
      console.log(decoded.trimEnd());
      return Promise.resolve();
    });
    this._stderr = CFWriteableStream((chunk) => {
      const decoded = decoder.decode(chunk);
      console.error(decoded.trimEnd());
      return Promise.resolve();
    });
  }
};
var WrapperSysAbstraction = class {
  constructor(base, params) {
    this._time = base._time;
    this._stdout = base._stdout;
    this._stderr = base._stderr;
    this._idService = base._idService;
    this._randomService = base._randomService;
    this._fileSystem = base._fileSystem;
    this._systemService = base._systemService;
    if (params) {
      if (params.TimeMode) {
        this._time = TimeFactory(params.TimeMode);
      }
      if (params.Stdout) {
        this._stdout = params.Stdout;
      }
      if (params.Stderr) {
        this._stderr = params.Stderr;
      }
      if (params.IdMode) {
        this._idService = new IdService(params.IdMode);
      }
      if (params.RandomMode) {
        this._randomService = new RandomService(params.RandomMode);
      }
      if (params.FileSystem) {
        this._fileSystem = params.FileSystem;
      }
      if (params.SystemService) {
        this._systemService = params.SystemService;
      }
    }
  }
  Time() {
    return this._time;
  }
  NextId() {
    return this._idService.NextId();
  }
  Random0ToValue(value) {
    return this._randomService.Random0ToValue(value);
  }
  Stdout() {
    return this._stdout;
  }
  Stderr() {
    return this._stderr;
  }
  System() {
    return this._systemService;
  }
  FileSystem() {
    return this._fileSystem;
  }
};

// src/lru-map-set.ts
var LRUMap = class {
  constructor(c = {}) {
    this._map = /* @__PURE__ */ new Map();
    this.param = {
      maxEntries: c.maxEntries || 100,
      maxAge: c.maxAge || 0
    };
  }
  touch(key) {
    if (!this._map.has(key)) {
      throw new Error(`key not found in cache: ${key}`);
    }
    const value = this._map.get(key);
    this._map.delete(key);
    this._map.set(key, value);
    return value;
  }
  setParam(param2 = {}) {
    if (typeof param2.maxEntries === "number") {
      this.param.maxEntries = param2.maxEntries;
      if (param2.maxEntries > 0 && this._map.size > param2.maxEntries) {
        const toDelete = [];
        let cacheSize = this._map.size;
        for (const key of this._map.keys()) {
          if (cacheSize > param2.maxEntries) {
            toDelete.push(key);
            cacheSize--;
          } else {
            break;
          }
        }
        for (const key of toDelete) {
          this._map.delete(key);
        }
      }
    }
  }
  has(key) {
    return this._map.has(key);
  }
  get size() {
    return this._map.size;
  }
  async getSet(key, createFN) {
    const val = this.get(key);
    if (val) {
      return val;
    } else {
      const val2 = await createFN(key);
      this.set(key, val2);
      return val2;
    }
  }
  get(key) {
    if (this._map.has(key)) {
      return this.touch(key);
    }
    return this._map.get(key);
  }
  set(key, value) {
    this._map.delete(key);
    if (this.param.maxEntries > 0 && this._map.size >= this.param.maxEntries) {
      this._map.delete(this._map.keys().next().value);
      this._map.set(key, value);
    } else {
      this._map.set(key, value);
    }
  }
  delete(key) {
    this._map.delete(key);
  }
  clear() {
    this._map.clear();
  }
  forEach(callbackfn) {
    this._map.forEach(callbackfn);
  }
  entries() {
    return this._map.entries();
  }
  // *entries(): IterableIterator<[T, K]> {
  //   for (const x of this._cache.entries()) {
  //     yield x;
  //   }
  // }
  //   getLeastRecent(): K {
  //     return Array.from(this.cache)[0];
  //   }
  //   getMostRecent(): K {
  //     return Array.from(this.cache)[this.cache.size - 1];
  //   }
};

// src/resolve-once.ts
var ResolveOnce = class {
  constructor(ctx) {
    this._onceDone = false;
    this._onceFutures = [];
    this._onceOk = false;
    this._isPromise = false;
    this.ctx = ctx;
  }
  get ready() {
    return this._onceDone;
  }
  reset() {
    this._onceDone = false;
    this._onceOk = false;
    this._onceValue = void 0;
    this._onceError = void 0;
    if (this._inProgress) {
      const idx = this._onceFutures.findIndex((f) => f === this._inProgress);
      if (idx >= 0) {
        this._onceFutures.push(...this._onceFutures.splice(2).slice(1));
      }
    } else {
      this._onceFutures.length = 0;
    }
  }
  // T extends Option<infer U> ? U : T
  once(fn) {
    if (this._onceDone) {
      if (this._onceError) {
        if (this._isPromise) {
          return Promise.reject(this._onceError);
        } else {
          throw this._onceError;
        }
      }
      if (this._onceOk) {
        if (this._isPromise) {
          return Promise.resolve(this._onceValue);
        } else {
          return this._onceValue;
        }
      }
      throw new Error("ResolveOnce.once impossible");
    }
    const future = new Future();
    this._onceFutures.push(future);
    if (this._onceFutures.length === 1) {
      const okFn = (value) => {
        this._onceValue = value;
        this._onceOk = true;
        this._onceDone = true;
        if (this._isPromise) {
          this._onceFutures.forEach((f) => f.resolve(this._onceValue));
        }
        this._onceFutures.length = 0;
      };
      const catchFn = (e) => {
        this._onceError = e;
        this._onceOk = false;
        this._onceValue = void 0;
        this._onceDone = true;
        if (this._isPromise) {
          this._onceFutures.forEach((f) => f.reject(this._onceError));
        }
        this._onceFutures.length = 0;
      };
      this._inProgress = future;
      try {
        const ret = fn(this.ctx);
        if (typeof ret.then === "function") {
          this._isPromise = true;
          ret.then(okFn).catch(catchFn).finally(() => {
            this._inProgress = void 0;
          });
        } else {
          okFn(ret);
        }
      } catch (e) {
        catchFn(e);
      }
      if (!this._isPromise) {
        this._inProgress = void 0;
      }
    }
    if (this._isPromise) {
      return future.asPromise();
    } else {
      return this.once(fn);
    }
  }
};
var Keyed = class {
  constructor(factory, params) {
    var _a;
    this.factory = factory;
    this._map = new LRUMap((_a = params == null ? void 0 : params.lru) != null ? _a : { maxEntries: -1 });
  }
  setParam(params) {
    this._map.setParam(params.lru);
  }
  async asyncGet(key) {
    return this.get(await key());
  }
  get(key) {
    if (typeof key === "function") {
      key = key();
    }
    let keyed = this._map.get(key);
    if (!keyed) {
      keyed = this.factory(key);
      this._map.set(key, keyed);
    }
    return keyed;
  }
  unget(key) {
    const keyed = this._map.get(key);
    keyed == null ? void 0 : keyed.reset();
    this._map.delete(key);
  }
  reset() {
    this._map.forEach((keyed) => keyed.reset());
    this._map.clear();
  }
};
var KeyedResolvOnce = class extends Keyed {
  constructor(kp = {}) {
    super((key) => new ResolveOnce(key), kp);
  }
  /**
   *
   * @returns The values of the resolved keys
   */
  values() {
    return Array.from(this._map.entries()).filter(([_, v]) => v._onceDone).map(([k, v]) => {
      if (v._onceDone) {
        if (v._onceError) {
          return {
            key: k,
            value: Result.Err(v._onceError)
          };
        }
        return {
          key: k,
          value: Result.Ok(v._onceValue)
        };
      }
      throw new Error("KeyedResolvOnce.values impossible");
    });
  }
};

// src/runtime.ts
function isSet(value, ref = globalThis) {
  const [head, ...tail] = value.split(".");
  if (["object", "function"].includes(typeof ref) && ref && ["object", "function"].includes(typeof ref[head]) && ref[head]) {
    if (tail.length <= 1) {
      return true;
    }
    return isSet(tail.join("."), ref[head]);
  }
  return false;
}
function runtimeFn() {
  const gt = globalThis;
  let isReactNative = (
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    isSet("navigator.product") && typeof gt["navigator"] === "object" && gt["navigator"]["product"] === "ReactNative"
  );
  let isNodeIsh = false;
  if (!isSet("Deno")) {
    isNodeIsh = isSet("process.versions.node") && !isReactNative;
  }
  let isDeno = isSet("Deno");
  const isCFWorker = isSet("caches.default") && isSet("WebSocketPair");
  if (isCFWorker) {
    isDeno = false;
    isNodeIsh = false;
    isReactNative = false;
  }
  return {
    isNodeIsh,
    isBrowser: !(isNodeIsh || isDeno || isCFWorker || isReactNative),
    isDeno,
    isReactNative,
    isCFWorker
  };
}

// src/deno/deno-env-actions.ts
var once = new ResolveOnce();
var _deno;
var _DenoEnvActions = class _DenoEnvActions {
  constructor(opts) {
    __privateAdd(this, _deno, globalThis);
    this.opts = opts;
  }
  static new(opts) {
    return once.once(() => new _DenoEnvActions(opts));
  }
  get _env() {
    return __privateGet(this, _deno).Deno.env;
  }
  register(env) {
    for (const key of env.keys()) {
      this._env.set(key, env.get(key) || "");
    }
    return env;
  }
  active() {
    return runtimeFn().isDeno;
  }
  keys() {
    return Object.keys(this._env.toObject());
  }
  get(key) {
    return this._env.get(key);
  }
  set(key, value) {
    if (value) {
      this._env.set(key, value);
    }
  }
  delete(key) {
    this._env.delete(key);
  }
};
_deno = new WeakMap();
var DenoEnvActions = _DenoEnvActions;

// src/node/node-env-actions.ts
var once2 = new ResolveOnce();
var _node;
var _NodeEnvActions = class _NodeEnvActions {
  constructor(opts) {
    __privateAdd(this, _node, globalThis);
    this._env = this.active() ? __privateGet(this, _node).process.env : {};
    this.opts = opts;
  }
  static new(opts) {
    return once2.once(() => new _NodeEnvActions(opts));
  }
  register(env) {
    for (const key of env.keys()) {
      this._env[key] = env.get(key) || "";
    }
    return env;
  }
  active() {
    return runtimeFn().isNodeIsh;
  }
  keys() {
    return Object.keys(this._env);
  }
  get(key) {
    return this._env[key];
  }
  set(key, value) {
    if (value) {
      this._env[key] = value;
    }
  }
  delete(key) {
    delete this._env[key];
  }
};
_node = new WeakMap();
var NodeEnvActions = _NodeEnvActions;

// src/web/web-env-actions.ts
var once3 = new ResolveOnce();
var BrowserEnvActions = class _BrowserEnvActions {
  constructor(opts) {
    this.env = /* @__PURE__ */ new Map();
    this.opts = opts;
  }
  static new(opts) {
    return once3.once(() => new _BrowserEnvActions(opts));
  }
  get(key) {
    return this.env.get(key);
  }
  set(key, value) {
    if (value) {
      this.env.set(key, value);
    }
  }
  delete(key) {
    this.env.delete(key);
  }
  keys() {
    return Array.from(this.env.keys());
  }
  active() {
    return true;
  }
  register(env) {
    const sym = Symbol.for(this.opts.symbol || "CP_ENV");
    const browser = globalThis;
    browser[sym] = env;
    return env;
  }
};

// src/cf/cf-env-actions.ts
var once4 = new ResolveOnce();
var CFEnvActions = class _CFEnvActions {
  constructor(env) {
    this.injectOnRegister = {};
    this.cfEnv = new Map(Object.entries(env.presetEnv || {}));
  }
  static new(opts) {
    return once4.once(() => new _CFEnvActions(opts));
  }
  static inject(o) {
    const env = _CFEnvActions.new({});
    for (const key in o) {
      const value = o[key];
      if (typeof value === "string") {
        if (env.env) {
          env.env.set(key, value);
        } else {
          env.injectOnRegister[key] = value;
        }
      }
    }
  }
  active() {
    return runtimeFn().isCFWorker;
  }
  register(env) {
    this.env = env;
    for (const key in this.injectOnRegister) {
      env.set(key, this.injectOnRegister[key]);
    }
    return env;
  }
  get(key) {
    return this.cfEnv.get(key);
  }
  set(key, value) {
    if (value) {
      this.cfEnv.set(key, value);
    }
  }
  delete(key) {
    this.cfEnv.delete(key);
  }
  keys() {
    return Array.from(this.cfEnv.keys());
  }
};

// src/types.ts
var _Required = class {
  constructor() {
    this.type = "REQUIRED";
  }
};
var _Optional = class {
  constructor() {
    this.type = "OPTIONAL";
  }
};
var param = {
  REQUIRED: new _Required(),
  OPTIONAL: new _Optional()
};

// src/utils/get-params-result.ts
function getParamsResult(keys, getParam) {
  const keyDef = keys.flat().reduce(
    (acc, i) => {
      if (typeof i === "string") {
        acc.push({ key: i, def: void 0, isOptional: false });
      } else if (typeof i === "object") {
        acc.push(
          ...Object.keys(i).map((k) => ({
            key: k,
            def: typeof i[k] === "string" ? i[k] : void 0,
            isOptional: i[k] === param.OPTIONAL
          }))
        );
      }
      return acc;
    },
    []
  );
  const msgFn = keys.find((k) => typeof k === "function") || ((...keys2) => {
    const msg = keys2.join(",");
    return `missing parameters: ${msg}`;
  });
  const errors = [];
  const result = {};
  for (const kd of keyDef) {
    const val = getParam.getParam(kd.key);
    if (val === void 0) {
      if (typeof kd.def === "string") {
        result[kd.key] = kd.def;
      } else {
        if (!kd.isOptional) {
          errors.push(kd.key);
        }
      }
    } else {
      result[kd.key] = val;
    }
  }
  if (errors.length) {
    return Result.Err(msgFn(...errors));
  }
  return Result.Ok(result);
}

// src/sys-env.ts
var envActions = [
  { id: "cf", fn: (opts) => CFEnvActions.new(opts) },
  { id: "node", fn: (opts) => NodeEnvActions.new(opts) },
  { id: "deno", fn: (opts) => DenoEnvActions.new(opts) },
  { id: "browser", fn: (opts) => BrowserEnvActions.new(opts) }
];
var _envFactories = new KeyedResolvOnce();
function envFactory(opts = {}) {
  const found = envActions.find((fi) => fi.fn(opts).active());
  if (!found) {
    throw new Error("SysContainer:envFactory: no env available");
  }
  return _envFactories.get(found.id).once(() => {
    const action = found.fn(opts);
    const ret = new EnvImpl(action, opts);
    action.register(ret);
    return ret;
  });
}
function isIterable(obj) {
  if (obj == null) {
    return false;
  }
  return typeof obj[Symbol.iterator] === "function";
}
var EnvImpl = class {
  constructor(map, opts = {}) {
    this._onSet = [];
    this._map = map;
    this._updatePresets(opts.presetEnv);
  }
  gets(...kparams) {
    return getParamsResult(kparams, {
      getParam: (k) => this.get(k)
    });
  }
  sets(...keys) {
    keys.forEach((key) => {
      if (Array.isArray(key)) {
        if (key.length === 2) {
          const [k, v] = key;
          if (typeof k === "string" && typeof v === "string") {
            this.set(k, v);
            return;
          }
        }
        for (const item of key) {
          if (Array.isArray(item)) {
            if (item.length === 2) {
              const [k, v] = item;
              if (typeof k === "string" && typeof v === "string") {
                this.set(k, v);
              }
            }
          }
        }
      } else {
        if (isIterable(key)) {
          for (const [k, v] of key) {
            if (typeof k === "string" && typeof v === "string") {
              this.set(k, v);
            }
          }
        } else {
          const rKey = key;
          for (const k in rKey) {
            const v = rKey[k];
            if (typeof k === "string" && typeof v === "string") {
              this.set(k, v);
            }
          }
        }
      }
    });
  }
  _updatePresets(presetEnv) {
    if (!presetEnv) {
      return;
    }
    for (const [key, value] of presetEnv) {
      this._map.set(key, value);
    }
  }
  _applyOnSet(onSet, key, value) {
    onSet.forEach((item) => {
      let keys = [];
      if (key) {
        keys = [key];
      } else {
        keys = this._map.keys();
      }
      keys.filter((k) => {
        if (item.filter.size === 0) {
          return true;
        }
        if (item.filter.has(k)) {
          return true;
        }
        return false;
      }).forEach((k) => {
        let v;
        if (!key && !value) {
          v = this._map.get(k);
        } else if (key && !value) {
          v = void 0;
        } else {
          v = value;
        }
        item.fn(k, v);
      });
    });
  }
  keys() {
    return this._map.keys();
  }
  // filter is not set all sets passed
  onSet(fn, ...filter) {
    const item = { filter: new Set(filter), fn };
    this._onSet.push(item);
    this._applyOnSet([item]);
  }
  get(key) {
    return this._map.get(key);
  }
  set(key, value) {
    if (!value) {
      return;
    }
    this._map.set(key, value);
    this._applyOnSet(this._onSet, key, value);
  }
  delete(key) {
    this._map.delete(key);
    this._applyOnSet(this._onSet, key);
  }
};

// src/web/web-sys-abstraction.ts
var WebFileService = class {
  get baseDir() {
    throw new Error("basedir-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  create(fname) {
    throw new Error("create-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  readFileString(fname) {
    throw new Error("readFileString-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  writeFileString(fname, content) {
    throw new Error("writeFileString-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  abs(fname) {
    throw new Error("abs-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  join(...paths) {
    throw new Error("join-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  relative(from2, to) {
    throw new Error("relative-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  dirname(fname) {
    throw new Error("dirname-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  basename(fname) {
    throw new Error("basename-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  nodeImport(fname) {
    throw new Error("nodeImport-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isAbsolute(fname) {
    throw new Error("isAbsolute-Method not implemented.");
  }
};
var WebSystemService = class {
  Env() {
    return envFactory();
  }
  Args() {
    throw new Error("Args-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  OnExit(hdl) {
    throw new Error("OnExit-Method not implemented.");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  Exit(code) {
    throw new Error("Exit-Method not implemented.");
  }
};
var my = void 0;
function WebSysAbstraction(param2) {
  if (!my) {
    my = new BaseSysAbstraction({
      TxtEnDecoder: (param2 == null ? void 0 : param2.TxtEnDecoder) || TxtEnDecoderSingleton(),
      FileSystem: new WebFileService(),
      SystemService: new WebSystemService()
    });
  }
  return new WrapperSysAbstraction(my, param2);
}

// src/utils/relative-path.ts
var PartType = {
  Slash: 1,
  Root: 3,
  Up: 4,
  Noop: 8
  // RootUp = 0x8 /* ../ */,
};
var Path = class {
  constructor(parts = []) {
    this.parts = parts;
  }
  toString() {
    return this.parts.map((part) => {
      if (typeof part === "string") {
        return part;
      } else {
        switch (part) {
          case PartType.Slash:
          case PartType.Root:
            return "/";
          case PartType.Up:
            return "..";
          default:
            return part;
        }
      }
    }).join("");
  }
  add(part) {
    if (this.parts.includes(PartType.Root) && part === PartType.Root) {
      throw new Error("Cannot add absolute part to absolute path");
    }
    const last = this.parts[this.parts.length - 1];
    if (last & PartType.Slash && part === PartType.Slash) {
      return;
    }
    switch (part) {
      case ".":
        this.parts.push(PartType.Noop);
        return;
      case "..":
        part = PartType.Up;
    }
    if (last === PartType.Noop && part === PartType.Slash) {
      if (last === PartType.Noop) {
        this.parts.pop();
      }
      return;
    }
    this.parts.push(part);
  }
};
function splitPath(path) {
  const p = new Path();
  if (path === "") {
    return p;
  }
  for (let count = 0; path.length; count++) {
    if (path.match(/^\/+/)) {
      if (count === 0) {
        p.add(PartType.Root);
      } else {
        p.add(PartType.Slash);
      }
      path = path.replace(/^\/+/, "");
    } else {
      const part = path.replace(/\/.*$/, "");
      p.add(part);
      path = path.replace(/^[^/]+/, "");
    }
  }
  return p;
}
function pathJoin(...paths) {
  let prev = "";
  const res = [];
  for (let i = 0; i < paths.length; i++) {
    const path = paths[i];
    if (path === "") {
      continue;
    }
    if (!(prev.endsWith("/") || path.startsWith("/"))) {
      if (prev !== "") {
        res.push("/");
      }
      res.push(path);
    } else {
      res.push(path);
    }
    prev = path;
  }
  return res.join("");
}
function relativePath(path, relative) {
  const relativeParts = splitPath(relative);
  let result;
  if (relativeParts.parts[0] === PartType.Root) {
    result = relative;
  } else {
    result = pathJoin(path, relative);
  }
  const unoptPath = splitPath(result);
  const out = [];
  let topUp = false;
  for (const part of unoptPath.parts) {
    switch (part) {
      case PartType.Root:
        out.push(PartType.Root);
        break;
      case PartType.Up:
        if (out.length && !topUp) {
          const last = out.length - 1;
          if (typeof out[last] === "string" && out[last - 1] == PartType.Root) {
            out.pop();
          } else {
            out.pop();
            out.pop();
          }
          if (out.length === 0) {
            topUp = !topUp ? true : topUp;
            out.push(PartType.Up);
          }
        } else {
          out.push(PartType.Up);
        }
        break;
      case PartType.Slash:
        if (!(out[out.length - 1] & PartType.Slash)) {
          out.push(PartType.Slash);
        }
        break;
      default:
        out.push(part);
        break;
    }
  }
  return new Path(out).toString();
}

// src/utils/stripper.ts
function stripper(strip, obj) {
  const strips = Array.isArray(strip) ? strip : [strip];
  const restrips = strips.map((s) => {
    if (typeof s === "string") {
      const escaped = s.replace(/[-\\[\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\^\\$\\|]/g, "\\$&");
      return new RegExp(`^${escaped}$`);
    }
    return s;
  });
  return localStripper(void 0, restrips, obj);
}
function localStripper(path, restrips, obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map((i) => localStripper(path, restrips, i));
  }
  const ret = { ...obj };
  const matcher = (key, nextPath) => {
    for (const re of restrips) {
      if (re.test(key) || re.test(nextPath)) {
        return true;
      }
    }
    return false;
  };
  for (const key in ret) {
    if (Object.prototype.hasOwnProperty.call(ret, key)) {
      let nextPath;
      if (path) {
        nextPath = [path, key].join(".");
      } else {
        nextPath = key;
      }
      if (matcher(key, nextPath)) {
        delete ret[key];
        continue;
      }
      if (typeof ret[key] === "object") {
        if (Array.isArray(ret[key])) {
          ret[key] = ret[key].reduce((acc, v, i) => {
            const toDelete = matcher(key, `${nextPath}[${i}]`);
            if (!toDelete) {
              acc.push(localStripper(`${nextPath}[${i}]`, restrips, v));
            }
            return acc;
          }, []);
        } else {
          ret[key] = localStripper(nextPath, restrips, ret[key]);
        }
      }
    }
  }
  return ret;
}

// src/uri.ts
function match(iref, ioth) {
  const mr = {
    score: 0,
    protocol: false,
    hostname: false,
    port: false,
    pathname: false,
    pathParts: [],
    params: {}
  };
  const ref = URI.from(iref);
  const oth = URI.from(ioth);
  if (ref.protocol === oth.protocol) {
    mr.score += 1;
    mr.protocol = true;
  }
  try {
    const refH = ref.hostname;
    const refP = ref.port;
    if (refH === oth.hostname) {
      mr.score += 1;
      mr.hostname = true;
    }
    if (refP.length && refP === oth.port) {
      mr.score += 1;
      mr.port = true;
    }
  } catch (e) {
  }
  if (ref.pathname.length && ref.pathname !== "/") {
    const pref = ref.pathname.split("/").filter((p) => p.length);
    const poth = oth.pathname.split("/").filter((p) => p.length);
    for (let i = 0; i < pref.length && i < poth.length; i++) {
      if (poth[i] === pref[i]) {
        mr.score += 1;
        mr.pathname = true;
        mr.pathParts.push(pref[i]);
      }
    }
  }
  for (const [key, value] of ref.getParams) {
    if (oth.getParam(key) === value) {
      mr.score += 1;
      mr.params[key] = value;
    }
  }
  return mr;
}
function coerceKey(key, def) {
  if (typeof key === "object") {
    const keys = Object.keys(key);
    if (keys.length !== 1) {
      throw new Error(`Invalid key: ${JSON.stringify(key)}`);
    }
    return { key: keys[0], def: key[keys[0]] };
  }
  return { key, def };
}
function falsy2undef(value) {
  return value === void 0 || value === null ? void 0 : value;
}
function ensureURLWithDefaultProto(url, defaultProtocol) {
  if (!url) {
    return new MutableURL(`${defaultProtocol}//`);
  }
  if (typeof url === "string") {
    try {
      return new MutableURL(url);
    } catch (e) {
      return new MutableURL(`${defaultProtocol}//${url}`);
    }
  } else {
    return new MutableURL(url.toString());
  }
}
function isURL(value) {
  return value instanceof URL || !!value && typeof value.searchParams === "object" && typeof value.searchParams.sort === "function" && typeof value.hash === "string";
}
var MutableURL = class _MutableURL extends URL {
  constructor(urlStr) {
    super("defect://does.not.exist");
    const partedURL = urlStr.split(":");
    this._hasHostpart = hasHostPartProtocols.has(partedURL[0]);
    let hostPartUrl = ["http", ...partedURL.slice(1)].join(":");
    if (!this._hasHostpart) {
      const pathname = hostPartUrl.replace(/http:\/\/[/]*/, "").replace(/[#?].*$/, "");
      hostPartUrl = hostPartUrl.replace(/http:\/\//, `http://localhost/${pathname}`);
    }
    try {
      this._sysURL = new URL(hostPartUrl);
    } catch (ie) {
      const e = ie;
      e.message = `${e.message} for URL: ${urlStr}`;
      throw e;
    }
    this._protocol = `${partedURL[0]}:`;
    if (this._hasHostpart) {
      this._pathname = this._sysURL.pathname;
    } else {
      this._pathname = urlStr.replace(new RegExp(`^${this._protocol}//`), "").replace(/[#?].*$/, "");
    }
    this.hash = this._sysURL.hash;
  }
  clone() {
    return new _MutableURL(this.toString());
  }
  get host() {
    if (!this._hasHostpart) {
      throw new Error(
        `you can use hostname only if protocol is ${this.toString()} ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`
      );
    }
    return this._sysURL.host;
  }
  get port() {
    if (!this._hasHostpart) {
      throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
    }
    return this._sysURL.port;
  }
  set port(p) {
    if (!this._hasHostpart) {
      throw new Error(`you can use port only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
    }
    this._sysURL.port = p;
  }
  get hostname() {
    if (!this._hasHostpart) {
      throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
    }
    return this._sysURL.hostname;
  }
  set hostname(h) {
    if (!this._hasHostpart) {
      throw new Error(`you can use hostname only if protocol is ${JSON.stringify(Array.from(hasHostPartProtocols.keys()))}`);
    }
    this._sysURL.hostname = h;
  }
  set pathname(p) {
    this._pathname = p;
  }
  get pathname() {
    return this._pathname;
  }
  get protocol() {
    return this._protocol;
  }
  set protocol(p) {
    if (!p.endsWith(":")) {
      p = `${p}:`;
    }
    this._protocol = p;
  }
  get searchParams() {
    return this._sysURL.searchParams;
  }
  toString() {
    let search = "";
    if (this._sysURL.searchParams.size) {
      for (const [key, value] of Array.from(this._sysURL.searchParams.entries()).sort((a, b) => a[0].localeCompare(b[0]))) {
        search += `${!search.length ? "?" : "&"}${key}=${encodeURIComponent(value)}`;
      }
    }
    let hostpart = "";
    if (this._hasHostpart) {
      hostpart = this._sysURL.hostname;
      if (this._sysURL.port) {
        hostpart += `:${this._sysURL.port}`;
      }
      if (!this._pathname.startsWith("/")) {
        hostpart += "/";
      }
    }
    return `${this._protocol}//${hostpart}${this._pathname}${search}`;
  }
};
function from(fac, strURLUri, defaultProtocol) {
  switch (typeof falsy2undef(strURLUri)) {
    case "undefined":
      return fac(new MutableURL(`${defaultProtocol}///`));
    case "string":
      return fac(ensureURLWithDefaultProto(strURLUri, defaultProtocol));
    case "object":
      if (BuildURI.is(strURLUri)) {
        return fac(new MutableURL(strURLUri._url.toString()));
      } else if (URI.is(strURLUri)) {
        return fac(new MutableURL(strURLUri._url.toString()));
      } else if (isURL(strURLUri)) {
        return fac(new MutableURL(strURLUri.toString()));
      }
      throw new Error(`unknown object type: ${strURLUri}`);
    default:
      throw new Error(`Invalid argument: ${typeof strURLUri}`);
  }
}
function getParamResult(key, val, msgFn = (key2) => {
  return `missing parameter: ${key2}`;
}) {
  if (val === void 0) {
    return Result.Err(msgFn(key));
  }
  return Result.Ok(val);
}
var BuildURI = class _BuildURI {
  // pathname needs this
  constructor(url) {
    this._url = url;
  }
  static is(value) {
    return value instanceof _BuildURI || !!value && typeof value.delParam === "function" && typeof value.setParam === "function";
  }
  static from(strURLUri, defaultProtocol = "file:") {
    return from((url) => new _BuildURI(url), strURLUri, defaultProtocol);
  }
  match(other) {
    return match(this.URI(), URI.from(other));
  }
  port(p) {
    this._url.port = p;
    return this;
  }
  hostname(h) {
    this._url.hostname = h;
    return this;
  }
  protocol(p) {
    if (!p.endsWith(":")) {
      p = `${p}:`;
    }
    this._url.protocol = p;
    return this;
  }
  pathname(p) {
    this._url.pathname = p;
    return this;
  }
  // could pass a relative path or a full URL
  // if relative path, it will be appended to the current path
  resolve(p) {
    if (!p) {
      return this;
    }
    if (typeof p === "string") {
      if (!p.match(/^[a-zA-Z0-9]+:/)) {
        if (p.startsWith("/")) {
          this.pathname(p);
          return this;
        }
        return this.appendRelative(p);
      }
    }
    this._url = new MutableURL(p.toString());
    return this;
  }
  appendRelative(p) {
    const appendUrl = URI.from(p);
    const pathname = "./" + appendUrl.pathname;
    const basePath = this._url.pathname;
    this.pathname(relativePath(basePath, pathname));
    for (const [key, value] of appendUrl.getParams) {
      this.setParam(key, value);
    }
    return this;
  }
  cleanParams() {
    for (const key of Array.from(this._url.searchParams.keys())) {
      this._url.searchParams.delete(key);
    }
    return this;
  }
  delParam(key) {
    this._url.searchParams.delete(key);
    return this;
  }
  defParam(key, str) {
    if (!this._url.searchParams.has(key)) {
      this._url.searchParams.set(key, str);
    }
    return this;
  }
  setParam(key, str) {
    this._url.searchParams.set(key, str);
    return this;
  }
  hasParam(key) {
    return this._url.searchParams.has(key);
  }
  get getParams() {
    return this._url.searchParams.entries();
  }
  getParam(key, def) {
    const { key: k, def: d } = coerceKey(key, def);
    let val = this._url.searchParams.get(k);
    if (!falsy2undef(val) && d) {
      val = d;
    }
    return falsy2undef(val);
  }
  getParamResult(key, msgFn) {
    return getParamResult(key, this.getParam(key), msgFn);
  }
  getParamsResult(...keys) {
    return getParamsResult(keys, this);
  }
  toString() {
    this._url.searchParams.sort();
    return this._url.toString();
  }
  toJSON() {
    return this.toString();
  }
  asURL() {
    return this.URI().asURL();
  }
  asObj(...strips) {
    return this.URI().asObj(...strips);
  }
  clone() {
    return _BuildURI.from(this.toString());
  }
  URI() {
    return URI.from(this._url);
  }
};
var hasHostPartProtocols = /* @__PURE__ */ new Set(["http", "https", "ws", "wss"]);
var URI = class _URI {
  static protocolHasHostpart(protocol) {
    protocol = protocol.replace(/:$/, "");
    hasHostPartProtocols.add(protocol);
    return () => {
      hasHostPartProtocols.delete(protocol);
    };
  }
  match(other) {
    return match(this, other);
  }
  // if no protocol is provided, default to file:
  static merge(into, from2, defaultProtocol = "file:") {
    const intoUrl = BuildURI.from(into, defaultProtocol);
    const fromUrl = _URI.from(from2, defaultProtocol);
    intoUrl.protocol(fromUrl.protocol);
    const fPath = fromUrl.pathname;
    if (!(fPath.length === 0 || fPath === "/" || fPath === "./")) {
      intoUrl.pathname(fromUrl.pathname);
    }
    for (const [key, value] of fromUrl.getParams) {
      intoUrl.setParam(key, value);
    }
    return intoUrl.URI();
  }
  static is(value) {
    return value instanceof _URI || !!value && typeof value.asURL === "function" && typeof value.getParam === "function" && typeof value.hasParam === "function";
  }
  // if no protocol is provided, default to file:
  static from(strURLUri, defaultProtocol = "file:") {
    return from((url) => new _URI(url), strURLUri, defaultProtocol);
  }
  static fromResult(strURLUri, defaultProtocol = "file:") {
    return exception2Result(() => from((url) => new _URI(url), strURLUri, defaultProtocol));
  }
  constructor(url) {
    this._url = url.clone();
  }
  build() {
    return BuildURI.from(this._url);
  }
  get hostname() {
    return this._url.hostname;
  }
  // get password(): string {
  //   return this._url.password;
  // }
  get port() {
    return this._url.port;
  }
  get host() {
    return this._url.host;
  }
  // get username(): string {
  //   return this._url.username;
  // }
  // get search(): string {
  //   return this._url.search;
  // }
  get protocol() {
    return this._url.protocol;
  }
  get pathname() {
    return this._url.pathname;
  }
  // get hash(): string {
  //   return this._url.hash;
  // }
  // get host(): string {
  //   return this._url.host;
  // }
  get getParams() {
    return this._url.searchParams.entries();
  }
  hasParam(key) {
    return this._url.searchParams.has(key);
  }
  getParam(key, def) {
    const { key: k, def: d } = coerceKey(key, def);
    let val = this._url.searchParams.get(k);
    if (!falsy2undef(val) && d) {
      val = d;
    }
    return falsy2undef(val);
  }
  getParamResult(key, msgFn) {
    return getParamResult(key, this.getParam(key), msgFn);
  }
  getParamsResult(...keys) {
    return getParamsResult(keys, this);
  }
  clone() {
    return new _URI(this._url);
  }
  asURL() {
    return this._url.clone();
  }
  toString() {
    return this._url.toString();
  }
  toJSON() {
    return this.toString();
  }
  asObj(...strips) {
    const pathURI = {
      style: "path",
      protocol: this.protocol,
      pathname: this.pathname,
      searchParams: Object.fromEntries(this.getParams)
    };
    if (hasHostPartProtocols.has(this.protocol.replace(/:$/, ""))) {
      return stripper(strips, {
        ...pathURI,
        style: "host",
        hostname: this.hostname,
        port: this.port
      });
    }
    return stripper(strips, pathURI);
  }
};

// src/utils/console-write-stream.ts
var ConsoleWriterStreamDefaultWriter = class {
  constructor(stream) {
    this.stream = stream;
    this.desiredSize = null;
    this.decoder = new TextDecoder();
    this._stream = stream;
    this.ready = Promise.resolve(void 0);
    this.closed = Promise.resolve(void 0);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
  abort(reason) {
    throw new Error("Method not implemented.");
  }
  async close() {
  }
  releaseLock() {
    this._stream.locked = false;
    this.ready = Promise.resolve(void 0);
    this.closed = Promise.resolve(void 0);
  }
  write(chunk) {
    let strObj = this.decoder.decode(chunk).trimEnd();
    let output = "log";
    try {
      strObj = JSON.parse(strObj);
      output = strObj.level;
    } catch (e) {
    }
    switch (output) {
      case "error":
        console.error(strObj);
        break;
      case "warn":
        console.warn(strObj);
        break;
      default:
        console.log(strObj);
    }
    return Promise.resolve();
  }
};
var ConsoleWriterStream = class {
  constructor() {
    this.locked = false;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unused-vars
  abort(reason) {
    throw new Error("Method not implemented.");
  }
  close() {
    return Promise.resolve();
  }
  getWriter() {
    if (this.locked) {
      throw new Error("Stream is locked");
    }
    this.locked = true;
    if (!this._writer) {
      this._writer = new ConsoleWriterStreamDefaultWriter(this);
    }
    return this._writer;
  }
};

// src/log-writer-impl.ts
var LogWriterStream = class {
  constructor(out) {
    this._toFlush = [];
    this._flushIsRunning = false;
    this._flushDoneFns = [];
    this._out = out;
  }
  write(encoded) {
    const my2 = async () => {
      try {
        const writer = this._out.getWriter();
        await writer.ready;
        await writer.write(encoded);
        writer.releaseLock();
      } catch (err) {
        console.error("Chunk error:", err);
      }
    };
    this._toFlush.push(my2);
    this._flush();
  }
  _flush(toFlush = void 0, done) {
    if (done) {
      this._flushDoneFns.push(done);
    }
    if (this._toFlush.length == 0) {
      this._flushIsRunning = false;
      this._flushDoneFns.forEach((fn) => fn());
      this._flushDoneFns = [];
      return;
    }
    if (!toFlush && this._toFlush.length == 1 && !this._flushIsRunning) {
      this._flushIsRunning = true;
    } else if (!toFlush) {
      return;
    }
    const my2 = this._toFlush.shift();
    my2 == null ? void 0 : my2().catch((e) => {
      console.error("Flush error:", e);
    }).finally(() => {
      this._flush(this._toFlush);
    });
  }
};

// src/logger-impl.ts
function getLen(value, lvs) {
  if (Array.isArray(value)) {
    return logValue(() => value.length, lvs);
  } else if (typeof value === "string") {
    return logValue(() => value.length, lvs);
  } else if (typeof value === "object" && value !== null) {
    if (typeof value.size === "number") {
      return logValue(() => value.size, lvs);
    } else if (typeof value.length === "number") {
      return logValue(() => value.length, lvs);
    }
    return logValue(() => Object.keys(value).length, lvs);
  }
  return logValue(() => -1, lvs);
}
function toLogValue(lop) {
  if (lop && typeof lop.then === "function") {
    throw new Error("async logValue Not implemented");
  }
  return lop;
}
var JSONFormatter = class {
  constructor(txtEnde, space) {
    this._txtEnDe = txtEnde;
    this._space = space;
  }
  format(attr) {
    let ret;
    try {
      ret = JSON.stringify(attr, null, this._space);
    } catch (e) {
      ret = JSON.stringify({ internal: { message: e.message, stack: e.stack } });
    }
    return this._txtEnDe.encode(ret + "\n");
  }
};
function toLogValueCtx(lvh) {
  return {
    ignoreAttr: lvh.ignoreAttr
  };
}
var LoggerImpl = class _LoggerImpl {
  // readonly _id: string = "logger-" + Math.random().toString(36)
  constructor(params) {
    this._attributes = {};
    if (!params) {
      params = {};
    }
    if (!params.sys) {
      this._sys = WebSysAbstraction();
    } else {
      this._sys = params.sys;
    }
    if (!params.txtEnDe) {
      this._txtEnDe = TxtEnDecoderSingleton();
    } else {
      this._txtEnDe = params.txtEnDe;
    }
    if (!params.formatter) {
      this._formatter = new JSONFormatter(this._txtEnDe);
    } else {
      this._formatter = params.formatter;
    }
    if (params.logWriter) {
      this._logWriter = params.logWriter;
    } else {
      if (!params.out) {
        const rt = runtimeFn();
        let stream;
        if (rt.isBrowser) {
          stream = new ConsoleWriterStream();
        } else {
          if (rt.isNodeIsh || rt.isReactNative || rt.isDeno || rt.isCFWorker) {
            stream = this._sys.Stdout();
          } else {
            throw new Error("No output defined for runtime");
          }
        }
        this._logWriter = new LogWriterStream(stream);
      } else {
        this._logWriter = new LogWriterStream(params.out);
      }
    }
    if (!params.withAttributes) {
      this._withAttributes = {};
    } else {
      this._withAttributes = { ...params.withAttributes };
    }
    this._attributes = { ...this._withAttributes };
    if (params.levelHandler) {
      this.levelHandler = params.levelHandler;
    } else {
      this.levelHandler = LevelHandlerSingleton();
    }
  }
  TxtEnDe() {
    return this._txtEnDe;
  }
  Attributes() {
    return JSON.parse(JSON.stringify(this._attributes, null));
  }
  SetExposeStack(enable) {
    this.levelHandler.setExposeStack(enable);
    return this;
  }
  EnableLevel(level, ...modules) {
    this.levelHandler.enableLevel(level, ...modules);
    return this;
  }
  DisableLevel(level, ...modules) {
    this.levelHandler.disableLevel(level, ...modules);
    return this;
  }
  Module(key) {
    this._attributes["module"] = logValue(key, toLogValueCtx(this.levelHandler));
    this._withAttributes["module"] = logValue(key, toLogValueCtx(this.levelHandler));
    return this;
  }
  // if the string is "*" it will enable for all modules
  SetDebug(...modules) {
    this.levelHandler.setDebug(...modules);
    return this;
  }
  SetIgnoreAttribute(re) {
    this.levelHandler.setIgnoreAttr(re);
    return this;
  }
  SetFormatter(formatter) {
    this._formatter = formatter;
    return this;
  }
  Timestamp() {
    this._attributes["ts"] = logValue(() => this._sys.Time().Now().toISOString(), toLogValueCtx(this.levelHandler));
    return this;
  }
  Warn() {
    this._attributes["level"] = logValue(Level.WARN, toLogValueCtx(this.levelHandler));
    return this;
  }
  Log() {
    return this;
  }
  Debug() {
    this._attributes["level"] = logValue(Level.DEBUG, toLogValueCtx(this.levelHandler));
    return this;
  }
  Error() {
    this._attributes["level"] = logValue(Level.ERROR, toLogValueCtx(this.levelHandler));
    return this;
  }
  Info() {
    this._attributes["level"] = logValue(Level.INFO, toLogValueCtx(this.levelHandler));
    return this;
  }
  Err(err) {
    var _a;
    let key = "error";
    if (Result.Is(err)) {
      if (err.isOk()) {
        key = "noerror";
        err = err.Ok();
      } else {
        err = err.Err();
      }
    }
    if (err instanceof Error) {
      if (err.cause) {
        this.coerceKey(key, {
          message: err.message,
          cause: err.cause
        });
      } else {
        this._attributes[key] = logValue(err.message, toLogValueCtx(this.levelHandler));
      }
      if (this.levelHandler.isStackExposed) {
        this._attributes["stack"] = logValue(
          (_a = err.stack) == null ? void 0 : _a.split(/[\r\n]+/).map((s) => s.trim()),
          toLogValueCtx(this.levelHandler)
        );
      }
    } else {
      this.Any(key, err);
    }
    return this;
  }
  WithLevel(l) {
    this._attributes["level"] = logValue(l, toLogValueCtx(this.levelHandler));
    return this;
  }
  Ref(key, action) {
    if (typeof action === "function") {
      this._attributes[key] = logValue(action, toLogValueCtx(this.levelHandler));
    } else if (typeof action.toString === "function") {
      this._attributes[key] = logValue(() => action.toString(), toLogValueCtx(this.levelHandler));
    } else {
      this._attributes[key] = logValue("INVALID REF", toLogValueCtx(this.levelHandler));
    }
    return this;
  }
  Bool(key, value) {
    this.coerceKey(key, !!value);
    return this;
  }
  Http(...mix) {
    const key = mix.find((x) => typeof x === "string");
    mix = mix.filter((x) => typeof x !== "string");
    const resErrors = mix.filter((x) => Result.Is(x) && x.isErr());
    if (resErrors.length) {
      this.Err(resErrors.map((x) => x.Err().message).join("\n"));
      return this;
    }
    const req = mix.map((reqOrResult) => Result.Is(reqOrResult) ? reqOrResult.Ok() : reqOrResult).find((req2) => typeof req2.status !== "number");
    const res = mix.map((resOrResult) => Result.Is(resOrResult) ? resOrResult.Ok() : resOrResult).find((res2) => typeof res2.status === "number");
    let reqAndOrres;
    if (res && req) {
      reqAndOrres = { res, req };
    } else if (!res && !req) {
      reqAndOrres = void 0;
    } else if (res) {
      reqAndOrres = res;
    } else if (req) {
      reqAndOrres = req;
    }
    if (reqAndOrres) {
      this.Any(key || "Http", reqAndOrres);
    }
    return this;
  }
  Pair(x) {
    for (const key of Object.keys(x)) {
      const value = x[key];
      if (value instanceof LogValue) {
        this._attributes[key] = value;
        continue;
      }
      if (Result.Is(value)) {
        this.Result(key, value);
        continue;
      }
      this.Any(key, value);
    }
    return this;
  }
  Result(key, res) {
    if (res.isOk()) {
      this._attributes[key] = logValue(res.Ok(), toLogValueCtx(this.levelHandler));
    } else {
      this.Err(res.Err());
    }
    return this;
  }
  Len(value, key = "len") {
    this._attributes[key] = getLen(value, toLogValueCtx(this.levelHandler));
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  Hash(value, key = "hash") {
    throw new Error("Not implemented");
  }
  Url(url, key = "url") {
    this.Ref(key, () => URI.from(url).toString());
    return this;
  }
  coerceKey(key, value) {
    if (typeof key === "string") {
      this._attributes[key] = logValue(value, toLogValueCtx(this.levelHandler));
    } else {
      this.Pair(key);
    }
  }
  Str(key, value) {
    this.coerceKey(key, value);
    return this;
  }
  Any(key, value) {
    this.coerceKey(key, value);
    return this;
  }
  Dur(key, nsec) {
    this._attributes[key] = logValue(`${nsec}ms`, toLogValueCtx(this.levelHandler));
    return this;
  }
  Uint64(key, value) {
    this.coerceKey(key, value);
    return this;
  }
  Int(key, value) {
    return this.Uint64(key, value);
  }
  async Flush() {
    return new Promise((resolve) => {
      this._logWriter._flush(void 0, resolve);
    });
  }
  With() {
    return new WithLoggerBuilder(
      new _LoggerImpl({
        logWriter: this._logWriter,
        sys: this._sys,
        levelHandler: this.levelHandler,
        formatter: this._formatter,
        withAttributes: {
          module: this._attributes["module"],
          ...this._withAttributes
        }
      })
    );
  }
  _resetAttributes(fn) {
    const ret = fn();
    Object.keys(this._attributes).forEach((key) => {
      delete this._attributes[key];
    });
    Object.assign(this._attributes, this._withAttributes);
    return ret;
  }
  Msg(...args) {
    const fnError = this._resetAttributes(() => {
      var _a, _b;
      const doWrite = this.levelHandler.isEnabled(
        (_a = toLogValue(this._attributes["level"])) == null ? void 0 : _a.value(),
        (_b = toLogValue(this._attributes["module"])) == null ? void 0 : _b.value()
      );
      this._attributes["msg"] = logValue(args.join(" "), toLogValueCtx(this.levelHandler));
      const msg = this._attributes["msg"].value();
      if (typeof msg === "string" && !msg.trim().length) {
        delete this._attributes["msg"];
      }
      let fnRet = () => this._formatter.format({ ...this._attributes });
      if (doWrite) {
        const encoded = fnRet();
        this._logWriter.write(encoded);
        fnRet = () => encoded;
      }
      return fnRet;
    });
    const asError = () => new Error(this._txtEnDe.decode(fnError()));
    return {
      ResultError: () => Result.Err(asError()),
      AsError: asError
    };
  }
};
var WithLoggerBuilder = class {
  constructor(li) {
    this._li = li;
    this.levelHandler = li.levelHandler;
  }
  TxtEnDe() {
    return this._li.TxtEnDe();
  }
  Logger() {
    Object.assign(this._li._withAttributes, this._li._attributes);
    return this._li;
  }
  Attributes() {
    return { ...this._li._attributes };
  }
  SetExposeStack(enable) {
    this._li.levelHandler.setExposeStack(enable);
    return this;
  }
  SetIgnoreAttribute(re) {
    this._li.levelHandler.setIgnoreAttr(re);
    return this;
  }
  SetFormatter(fmt) {
    this._li.SetFormatter(fmt);
    return this;
  }
  EnableLevel(level, ...modules) {
    this._li.levelHandler.enableLevel(level, ...modules);
    return this;
  }
  DisableLevel(level, ...modules) {
    this._li.levelHandler.enableLevel(level, ...modules);
    return this;
  }
  Module(key) {
    this._li.Module(key);
    return this;
  }
  SetDebug(...modules) {
    this._li.SetDebug(...modules);
    return this;
  }
  Http(...mix) {
    this._li.Http(...mix);
    return this;
  }
  Pair(x) {
    this._li.Pair(x);
    return this;
  }
  Str(key, value) {
    this._li.Str(key, value);
    return this;
  }
  Len(value, key) {
    this._li.Len(value, key);
    return this;
  }
  Hash(value, key) {
    this._li.Hash(value, key);
    return this;
  }
  Ref(key, action) {
    this._li.Ref(key, action);
    return this;
  }
  Bool(key, value) {
    this._li.Bool(key, value);
    return this;
  }
  Result(key, res) {
    this._li.Result(key, res);
    return this;
  }
  Url(url, key) {
    this._li.Url(url, key);
    return this;
  }
  Int(key, value) {
    this._li.Int(key, value);
    return this;
  }
  Log() {
    this._li.Log();
    return this;
  }
  WithLevel(level) {
    this._li.WithLevel(level);
    return this;
  }
  Error() {
    this._li.Error();
    return this;
  }
  Warn() {
    this._li.Error();
    return this;
  }
  Debug() {
    this._li.Debug();
    return this;
  }
  Err(err) {
    this._li.Err(err);
    return this;
  }
  Info() {
    this._li.Info();
    return this;
  }
  Timestamp() {
    this._li.Timestamp();
    return this;
  }
  Any(key, value) {
    this._li.Any(key, value);
    return this;
  }
  Dur(key, nsec) {
    this._li.Dur(key, nsec);
    return this;
  }
  Uint64(key, value) {
    this._li.Uint64(key, value);
    return this;
  }
};

// src/test/mock-logger.ts
function MockLogger(params) {
  const lc = new LogCollector(params == null ? void 0 : params.pass);
  let modNames = ["MockLogger"];
  if (typeof (params == null ? void 0 : params.moduleName) === "string") {
    modNames = [params == null ? void 0 : params.moduleName];
  } else if (Array.isArray(params == null ? void 0 : params.moduleName)) {
    modNames = [...params.moduleName, ...modNames];
  }
  const logger = new LoggerImpl({
    out: lc,
    sys: params == null ? void 0 : params.sys,
    levelHandler: new LevelHandlerImpl()
  }).With().Module(modNames[0]).Logger();
  if (!(params == null ? void 0 : params.disableDebug)) {
    logger.SetDebug(...modNames);
  }
  return {
    logCollector: lc,
    logger
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  LogCollector,
  LogWriteStream,
  MockLogger
});
//# sourceMappingURL=index.cjs.map