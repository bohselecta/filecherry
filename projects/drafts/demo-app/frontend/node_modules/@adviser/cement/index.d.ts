import { S as SysAbstraction, T as Time } from './sys-abstraction-B0x6IE7r.js';
export { D as Duration, E as Env, c as EnvActions, i as EnvFactoryFn, e as EnvFactoryOpts, d as EnvImpl, h as EnvMap, g as EnvTuple, F as FileService, I as IDMode, N as NamedWritableStream, O as OnSetItem, R as RandomMode, f as String2TimeMode, b as SystemService, a as TimeMode, l as TimeUnit, k as TimeUnits, V as VoidFunc, j as envFactory, r as registerEnvAction } from './sys-abstraction-B0x6IE7r.js';
import { L as LogFormatter, a as LogSerializable, b as LevelHandler, c as Logger, d as Level, F as FnSerialized, H as HttpType, C as CoerceURI, W as WithLogger, A as AsError, O as Option, e as Future } from './index-BhmvYS_t.js';
export { B as BuildURI, v as HostURIObject, I as IsLogger, k as Lengthed, p as LogCollector, f as LogValue, h as LogValueArg, i as LogValueState, o as LogWriteStream, n as LoggerInterface, t as MatchResult, q as MockLogger, M as MockLoggerReturn, x as MutableURL, N as None, P as PathURIObject, S as Serialized, m as SizeOrLength, j as Sized, r as Some, D as URI, U as URIInterface, u as URIObject, s as WithoutOption, g as asyncLogValue, z as hasHostPartProtocols, y as isCoerceURI, w as isURL, l as logValue } from './index-BhmvYS_t.js';
import { T as TxtEnDecoder, R as Result, f as ToEnDecoder, h as AsyncToEnDecoder } from './get-params-result-4xHM5s4_.js';
export { k as ResultError, j as ResultOK, i as TxtEnDecoderSingleton, W as WithoutResult, l as exception2Result, p as param } from './get-params-result-4xHM5s4_.js';
export { c as BaseSysAbstraction, B as BaseSysAbstractionParams, C as ConstTime, a as ExitHandler, E as ExitService, I as IdService, R as RandomService, b as StepTime, S as SysTime, T as TimeFactory, d as WrapperSysAbstraction, W as WrapperSysAbstractionParams } from './base-sys-abstraction-BnBZ6zd0.js';
export { i as utils } from './index-CMLb7JSe.js';
import './stripper-BpBUUZ9p.js';

declare class LogWriterStream {
    readonly _out: WritableStream<Uint8Array>;
    readonly _toFlush: (() => Promise<void>)[];
    constructor(out: WritableStream<Uint8Array>);
    write(encoded: Uint8Array): void;
    _flushIsRunning: boolean;
    _flushDoneFns: (() => void)[];
    _flush(toFlush?: (() => Promise<void>)[] | undefined, done?: () => void): void;
}

declare class JSONFormatter implements LogFormatter {
    private readonly _txtEnDe;
    private readonly _space?;
    constructor(txtEnde: TxtEnDecoder, space?: number);
    format(attr: LogSerializable): Uint8Array;
}
declare class YAMLFormatter implements LogFormatter {
    private readonly _txtEnDe;
    private readonly _space?;
    constructor(txtEnde: TxtEnDecoder, space?: number);
    format(attr: LogSerializable): Uint8Array;
}
interface LoggerImplParams {
    readonly out?: WritableStream<Uint8Array>;
    readonly logWriter?: LogWriterStream;
    readonly sys?: SysAbstraction;
    readonly withAttributes?: LogSerializable;
    readonly levelHandler?: LevelHandler;
    readonly txtEnDe?: TxtEnDecoder;
    readonly formatter?: LogFormatter;
}
declare class LoggerImpl implements Logger {
    readonly _sys: SysAbstraction;
    readonly _attributes: LogSerializable;
    readonly _withAttributes: LogSerializable;
    readonly _logWriter: LogWriterStream;
    readonly levelHandler: LevelHandler;
    readonly _txtEnDe: TxtEnDecoder;
    _formatter: LogFormatter;
    constructor(params?: LoggerImplParams);
    TxtEnDe(): TxtEnDecoder;
    Attributes(): Record<string, unknown>;
    SetExposeStack(enable?: boolean): Logger;
    EnableLevel(level: Level, ...modules: string[]): Logger;
    DisableLevel(level: Level, ...modules: string[]): Logger;
    Module(key: string): Logger;
    SetDebug(...modules: (string | string[])[]): Logger;
    SetIgnoreAttribute(re?: RegExp): Logger;
    SetFormatter(formatter: LogFormatter): Logger;
    Timestamp(): Logger;
    Warn(): Logger;
    Log(): Logger;
    Debug(): Logger;
    Error(): Logger;
    Info(): Logger;
    Err<T>(err: T | Result<T> | Error): Logger;
    WithLevel(l: Level): Logger;
    Ref(key: string, action: {
        toString: () => string;
    } | FnSerialized): Logger;
    Bool(key: string | Record<string, unknown>, value: unknown): Logger;
    Http(...mix: (HttpType | string)[]): Logger;
    Pair(x: Record<string, unknown>): Logger;
    Result<T>(key: string, res: Result<T, Error>): Logger;
    Len(value: unknown, key?: string): Logger;
    Hash(value: unknown, key?: string): Logger;
    Url(url: CoerceURI, key?: string): Logger;
    private coerceKey;
    Str(key: string | Record<string, string>, value?: string): Logger;
    Any(key: string | Record<string, unknown>, value?: unknown): Logger;
    Dur(key: string, nsec: number): Logger;
    Uint64(key: string | Record<string, number>, value?: number): Logger;
    Int(key: string | Record<string, number>, value?: number): Logger;
    Flush(): Promise<void>;
    With(): WithLogger;
    _resetAttributes(fn: () => () => Uint8Array): () => Uint8Array;
    Msg(...args: string[]): AsError;
}

declare class LevelHandlerImpl implements LevelHandler {
    readonly _globalLevels: Set<Level>;
    readonly _modules: Map<string, Set<Level>>;
    ignoreAttr: Option<RegExp>;
    isStackExposed: boolean;
    enableLevel(level: Level, ...modules: string[]): void;
    disableLevel(level: Level, ...modules: string[]): void;
    setExposeStack(enable?: boolean): void;
    setIgnoreAttr(re?: RegExp): void;
    forModules(level: Level, fnAction: (p: string) => void, ...modules: (string | string[])[]): void;
    setDebug(...modules: (string | string[])[]): void;
    isEnabled(ilevel: unknown, module: unknown): boolean;
}
declare function LevelHandlerSingleton(): LevelHandler;

type TraceCtx = {
    readonly spanId: string;
    readonly time: Time;
    readonly parent: TraceNode;
    readonly metrics: Map<string, Metric<unknown>>;
    readonly logger?: Logger;
} & Record<string, unknown>;
type CleanCtx = {
    readonly spanId: string;
} & Record<string, unknown>;
type TraceCtxParam = {
    readonly spanId: string;
} & Partial<{
    readonly time: Time;
    readonly parent: TraceNode;
    readonly logger: Logger;
}> & Record<string, unknown>;
declare class Metric<T> {
    value?: T;
    readonly path: string;
    constructor(path: string);
    set(value: T): void;
    add<R extends number | ArrayLike<T>>(value: R): void;
}
type MetricMap = Map<string, Metric<unknown>>;
declare class Metrics {
    readonly tracenode: TraceNode;
    private readonly map;
    readonly spanRefs: MetricMap;
    constructor(tracenode: TraceNode);
    toJSON(): Record<string, unknown>;
    get<T>(ipath: string): Metric<T>;
}
interface Invokaction {
    readonly result: "success" | "error";
    readonly start: number;
    readonly end: number;
    readonly metrics?: Metrics;
}
type TraceNodeMap = Map<string, TraceNode>;
declare class TraceNode {
    readonly childs: TraceNodeMap;
    readonly invokations: Invokaction[];
    readonly spanId: string;
    readonly ctx: TraceCtx;
    readonly metrics: Metrics;
    static root(time: Time, logger?: Logger): TraceNode;
    constructor(ctx: TraceCtx);
    getRootPath(rpath?: string[]): string;
    invokes(): {
        ctx: CleanCtx;
        invokations: Invokaction[];
    };
    ctxWith(spanId: string, logger?: Logger): TraceCtxParam;
    span<V extends (trace: TraceNode) => Promise<T> | T, T>(inSpanId: string | TraceCtxParam, fn: V): ReturnType<V>;
}

interface LRUParam {
    readonly maxEntries: number;
    readonly maxAge: number;
}
declare class LRUSet<T> {
    private readonly _lruMap;
    constructor(param?: Partial<LRUParam>);
    setParam(param?: Partial<LRUParam>): void;
    get size(): number;
    has(key: T): boolean;
    add(key: T): void;
    delete(key: T): void;
    clear(): void;
    forEach(callbackfn: (value: T, key: T) => void): void;
    entries(): IterableIterator<[T, T]>;
}
declare class LRUMap<T, K> {
    private _map;
    private param;
    constructor(c?: Partial<LRUParam>);
    private touch;
    setParam(param?: Partial<LRUParam>): void;
    has(key: T): boolean;
    get size(): number;
    getSet(key: T, createFN: (key: T) => Promise<K>): Promise<K | undefined>;
    get(key: T): K | undefined;
    set(key: T, value: K): void;
    delete(key: T): void;
    clear(): void;
    forEach(callbackfn: (value: K, key: T, map: Map<T, K>) => void): void;
    entries(): IterableIterator<[T, K]>;
}

interface ResolveSeqItem<T, C> {
    readonly future: Future<T>;
    readonly fn: (c: C) => Promise<T>;
    readonly id?: number;
}
declare class ResolveSeq<T, C = void> {
    readonly ctx: C;
    constructor(ctx?: C);
    reset(): void;
    readonly _flushWaiting: Future<void>[];
    flush(): Promise<void>;
    _step(item?: ResolveSeqItem<T, C>): Promise<void>;
    readonly _seqFutures: ResolveSeqItem<T, C>[];
    add(fn: (c: C) => Promise<T>, id?: number): Promise<T>;
}
declare class ResolveOnce<T, CTX = void> {
    _onceDone: boolean;
    readonly _onceFutures: Future<T>[];
    _onceOk: boolean;
    _onceValue?: T;
    _onceError?: Error;
    _isPromise: boolean;
    _inProgress?: Future<T>;
    readonly ctx: CTX;
    constructor(ctx?: CTX);
    get ready(): boolean;
    reset(): void;
    once<R>(fn: (c: CTX) => R): R;
}
interface KeyedParam {
    readonly lru: Partial<LRUParam>;
}
declare class Keyed<T extends {
    reset: () => void;
}, K = string> {
    protected readonly _map: LRUMap<K, T>;
    readonly factory: (key: K) => T;
    constructor(factory: (key: K) => T, params: Partial<KeyedParam>);
    setParam(params: KeyedParam): void;
    asyncGet(key: () => Promise<K>): Promise<T>;
    get(key: K | (() => K)): T;
    unget(key: K): void;
    reset(): void;
}
declare class KeyedResolvOnce<T, K = string> extends Keyed<ResolveOnce<T, K>, K> {
    constructor(kp?: Partial<KeyedParam>);
    values(): {
        key: K;
        value: Result<T>;
    }[];
}
declare class KeyedResolvSeq<T, K = string> extends Keyed<ResolveSeq<T, K>, K> {
    constructor(kp?: Partial<KeyedParam>);
}

interface Runtime {
    isNodeIsh: boolean;
    isBrowser: boolean;
    isDeno: boolean;
    isReactNative: boolean;
    isCFWorker: boolean;
}
declare function runtimeFn(): Runtime;

interface CTJsonWebKey {
    alg?: string;
    crv?: string;
    d?: string;
    dp?: string;
    dq?: string;
    e?: string;
    ext?: boolean;
    k?: string;
    key_ops?: string[];
    kty?: string;
    n?: string;
    oth?: RsaOtherPrimesInfo[];
    p?: string;
    q?: string;
    qi?: string;
    use?: string;
    x?: string;
    y?: string;
}
type CTKeyFormat = "jwk" | "pkcs8" | "raw" | "spki";
type CTKeyUsage = "decrypt" | "deriveBits" | "deriveKey" | "encrypt" | "sign" | "unwrapKey" | "verify" | "wrapKey";
interface CTAlgorithm {
    name: string;
}
type CTAlgorithmIdentifier = CTAlgorithm | string;
interface CTRsaHashedImportParams extends CTAlgorithm {
    hash: CTAlgorithmIdentifier;
}
type CTNamedCurve = string;
interface CTEcKeyImportParams extends CTAlgorithm {
    namedCurve: CTNamedCurve;
}
interface CTHmacImportParams extends CTAlgorithm {
    hash: CTAlgorithmIdentifier;
    length?: number;
}
interface CTAesKeyAlgorithm extends CTAlgorithm {
    length: number;
}
type CTKeyType = "private" | "public" | "secret";
interface CTCryptoKey {
    readonly algorithm: CTAlgorithm;
    readonly extractable: boolean;
    readonly type: CTKeyType;
    readonly usages: CTKeyUsage[];
}
interface CTArrayBufferTypes {
    ArrayBuffer: ArrayBuffer;
}
type CTArrayBufferLike = CTArrayBufferTypes[keyof CTArrayBufferTypes];
interface CTArrayBufferView {
    buffer: CTArrayBufferLike;
    byteLength: number;
    byteOffset: number;
}
type CTBufferSource = CTArrayBufferView | ArrayBuffer | Uint8Array;
interface CryptoRuntime {
    importKey(format: CTKeyFormat, keyData: CTJsonWebKey | CTBufferSource, algorithm: CTAlgorithmIdentifier | CTRsaHashedImportParams | CTEcKeyImportParams | CTHmacImportParams | CTAesKeyAlgorithm, extractable: boolean, keyUsages: CTKeyUsage[]): Promise<CTCryptoKey>;
    exportKey(format: CTKeyFormat, key: CTCryptoKey): Promise<CTJsonWebKey | ArrayBuffer>;
    decrypt(algo: {
        name: string;
        iv: Uint8Array;
        tagLength: number;
    }, key: CTCryptoKey, data: Uint8Array): Promise<ArrayBuffer>;
    encrypt(algo: {
        name: string;
        iv: Uint8Array;
        tagLength: number;
    }, key: CTCryptoKey, data: Uint8Array): Promise<ArrayBuffer>;
    digestSHA256(data: Uint8Array): Promise<ArrayBuffer>;
    randomBytes(size: number): Uint8Array;
}
declare function toCryptoRuntime(cryptoOpts?: Partial<CryptoRuntime>): CryptoRuntime;

declare function bin2text(hex: ArrayBufferView, lineFn: (line: string) => void, size?: number): void;
declare function bin2string(hex: ArrayBufferView, size?: number): string;

declare const VERSION: string;

declare class HeadersImpl extends Headers {
    readonly _headers: Map<string, string>;
    constructor(init: Map<string, string>);
    [Symbol.iterator](): IterableIterator<[string, string]>;
    entries(): IterableIterator<[string, string]>;
    keys(): IterableIterator<string>;
    values(): IterableIterator<string>;
    append(key: string, value: string | string[] | undefined): HeadersImpl;
}
declare class HttpHeader {
    readonly _headers: Map<string, string[]>;
    static from(headers?: HeadersInit | Headers | HttpHeader): HttpHeader;
    _asStringString(): Map<string, string>;
    _key(key: string): string;
    Values(key: string): string[];
    Get(key: string): string | undefined;
    Set(key: string, valueOr: string | string[]): HttpHeader;
    Add(key: string, value: string | string[] | undefined): HttpHeader;
    Del(ey: string): HttpHeader;
    Items(): [string, string[]][];
    SortItems(): [string, string[]][];
    Clone(): HttpHeader;
    AsRecordStringStringArray(): Record<string, string[]>;
    AsRecordStringString(): Record<string, string>;
    AsHeaderInit(): HeadersInit;
    AsHeaders(): Headers;
    Merge(other?: HttpHeader): HttpHeader;
}

interface PathOps {
    join(...args: string[]): string;
    dirname(path: string): string;
    basename(path: string): string;
}
declare const pathOps: PathOps;

interface JSONEnDecoder {
    stringify<T>(input: Result<T> | T, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string;
    asyncStringify<T>(input: Promise<Result<T> | T>, replacer?: (this: any, key: string, value: any) => any, space?: string | number): Promise<string>;
    uint8ify<T>(input: Result<T> | T, replacer?: (this: any, key: string, value: any) => any, space?: string | number): Uint8Array;
    asyncUint8ify<T>(input: Promise<Result<T> | T>, replacer?: (this: any, key: string, value: any) => any, space?: string | number): Promise<Uint8Array>;
    parse<T>(input: ToEnDecoder, reviver?: (this: any, key: string, value: any) => any): Result<T>;
    asyncParse<T>(input: AsyncToEnDecoder, reviver?: (this: any, key: string, value: any) => any): Promise<Result<T>>;
}
declare function JSONEnDecoderSingleton(txtEnde?: TxtEnDecoder): JSONEnDecoder;

export { AsError, AsyncToEnDecoder, type CTAesKeyAlgorithm, type CTAlgorithm, type CTAlgorithmIdentifier, type CTArrayBufferView, type CTBufferSource, type CTCryptoKey, type CTEcKeyImportParams, type CTHmacImportParams, type CTJsonWebKey, type CTKeyFormat, type CTKeyType, type CTKeyUsage, type CTNamedCurve, type CTRsaHashedImportParams, type CleanCtx, CoerceURI, type CryptoRuntime, FnSerialized, Future, HeadersImpl, HttpHeader, HttpType, type Invokaction, type JSONEnDecoder, JSONEnDecoderSingleton, JSONFormatter, Keyed, type KeyedParam, KeyedResolvOnce, KeyedResolvSeq, LRUMap, type LRUParam, LRUSet, Level, LevelHandler, LevelHandlerImpl, LevelHandlerSingleton, LogFormatter, LogSerializable, Logger, LoggerImpl, type LoggerImplParams, Metric, type MetricMap, Metrics, Option, type PathOps, ResolveOnce, ResolveSeq, Result, type Runtime, SysAbstraction, Time, ToEnDecoder, type TraceCtx, type TraceCtxParam, TraceNode, type TraceNodeMap, TxtEnDecoder, VERSION, WithLogger, YAMLFormatter, bin2string, bin2text, pathOps, runtimeFn, toCryptoRuntime };
