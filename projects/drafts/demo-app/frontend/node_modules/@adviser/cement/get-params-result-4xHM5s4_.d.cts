declare abstract class Result<T, E = Error> {
    static Ok<T = void>(t: T): Result<T, Error>;
    static Err<T, E extends Error = Error>(t: E | string | Result<unknown, E>): Result<T, E>;
    static Is<T>(t: unknown): t is Result<T>;
    isOk(): boolean;
    isErr(): boolean;
    Ok(): T;
    Err(): E;
    abstract is_ok(): boolean;
    abstract is_err(): boolean;
    abstract unwrap(): T;
    abstract unwrap_err(): E;
}
declare class ResultOK<T> extends Result<T, Error> {
    private _t;
    constructor(t: T);
    is_ok(): boolean;
    is_err(): boolean;
    unwrap_err(): Error;
    unwrap(): T;
}
declare class ResultError<T extends Error> extends Result<never, T> {
    private _error;
    constructor(t: T);
    is_ok(): boolean;
    is_err(): boolean;
    unwrap(): never;
    unwrap_err(): T;
}
type WithoutResult<T> = T extends Result<infer U> ? U : T;
type WithResult<T> = T extends Promise<infer U> ? Promise<Result<U>> : Result<T>;
declare function exception2Result<FN extends () => Promise<T> | T, T>(fn: FN): WithResult<ReturnType<FN>>;

type ToUInt8Plain = Uint8Array | ArrayBuffer | ArrayBufferView;
type ToUInt8Async = ToUInt8Plain | Blob;
type ToUInt8 = ToUInt8Plain | Result<ToUInt8Plain>;
type AsyncToUInt8 = ToUInt8Async | Result<ToUInt8Async> | Promise<ToUInt8Async> | Promise<Result<ToUInt8Async>>;
declare function coerceIntoUint8(raw: ToUInt8): Result<Uint8Array>;
declare function asyncCoerceIntoUint8(raw: AsyncToUInt8): Promise<Result<Uint8Array>>;

type ToEnDecoder = ToUInt8 | string | Result<string>;
type AsyncToEnDecoder = ToEnDecoder | Blob | Promise<ToEnDecoder | Blob>;
interface TxtEnDecoder {
    encode(input: string): Uint8Array;
    decode(input: ToEnDecoder): string;
    asyncDecode(input: AsyncToEnDecoder): Promise<string>;
}
declare function TxtEnDecoderSingleton(): TxtEnDecoder;

interface IType {
    readonly type: string;
}
declare class _Required implements IType {
    readonly type = "REQUIRED";
}
declare class _Optional implements IType {
    readonly type = "OPTIONAL";
}
declare const param: {
    REQUIRED: _Required;
    OPTIONAL: _Optional;
};
type param = (typeof param)[keyof typeof param];

type MsgFn = (...keys: string[]) => string;
type KeysParam = (string | MsgFn | Record<string, param | number | string | boolean | undefined | null>)[];
declare function getParamsResult(keys: KeysParam, getParam: {
    getParam: (key: string) => string | undefined;
}): Result<Record<string, string>>;

export { type AsyncToUInt8 as A, type KeysParam as K, type MsgFn as M, Result as R, type TxtEnDecoder as T, type WithoutResult as W, type ToUInt8 as a, type ToUInt8Async as b, type ToUInt8Plain as c, asyncCoerceIntoUint8 as d, coerceIntoUint8 as e, type ToEnDecoder as f, getParamsResult as g, type AsyncToEnDecoder as h, TxtEnDecoderSingleton as i, ResultOK as j, ResultError as k, exception2Result as l, param as p };
