{"version":3,"sources":["../../../src/deno/index.ts","../../../src/sys-abstraction.ts","../../../src/time.ts","../../../src/base-sys-abstraction.ts","../../../src/future.ts","../../../src/lru-map-set.ts","../../../src/result.ts","../../../src/resolve-once.ts","../../../src/runtime.ts","../../../src/deno/deno-env-actions.ts","../../../src/node/node-env-actions.ts","../../../src/web/web-env-actions.ts","../../../src/cf/cf-env-actions.ts","../../../src/types.ts","../../../src/utils/get-params-result.ts","../../../src/sys-env.ts","../../../src/utils/coerce-uint8.ts","../../../src/txt-en-decoder.ts","../../../src/deno/deno-file-service.ts","../../../src/deno/deno-sys-abstraction.ts"],"sourcesContent":["export * from \"./deno-sys-abstraction.js\";\nexport * from \"./deno-file-service.js\";\n","import { FileService } from \"./file-service.js\";\nimport { Env } from \"./sys-env.js\";\nimport { Time } from \"./time.js\";\n\nexport const TimeMode = {\n  REAL: \"real\",\n  CONST: \"const\",\n  STEP: \"step\",\n};\nexport type TimeMode = (typeof TimeMode)[keyof typeof TimeMode];\n\nexport const RandomMode = {\n  CONST: \"const\",\n  STEP: \"step\",\n  RANDOM: \"random\",\n};\nexport type RandomMode = (typeof RandomMode)[keyof typeof RandomMode];\n\nexport const IDMode = {\n  UUID: \"uuid\",\n  CONST: \"const\",\n  STEP: \"step\",\n};\nexport type IDMode = (typeof IDMode)[keyof typeof IDMode];\n\nexport function String2TimeMode(s?: string): TimeMode {\n  switch (s?.toLowerCase()) {\n    case \"real\":\n      return TimeMode.REAL;\n    case \"const\":\n      return TimeMode.CONST;\n    case \"step\":\n      return TimeMode.STEP;\n    default:\n      return TimeMode.REAL;\n  }\n}\n\nexport type VoidFunc = () => void | Promise<void>;\n\nexport interface SystemService {\n  Env(): Env;\n  Args(): string[];\n  OnExit(hdl: VoidFunc): VoidFunc;\n  Exit(code: number): void;\n}\n\nexport interface SysAbstraction {\n  Time(): Time;\n  Stdout(): WritableStream<Uint8Array>;\n  Stderr(): WritableStream<Uint8Array>;\n  NextId(): string;\n  Random0ToValue(value: number): number;\n  System(): SystemService;\n  FileSystem(): FileService;\n}\n","export abstract class Time {\n  abstract Now(add?: number): Date;\n  abstract Sleep(duration: Duration): Promise<void>;\n  TimeSince(start: Date): Duration {\n    const now = this.Now();\n    return now.getTime() - start.getTime();\n  }\n}\n\nexport type Duration = number;\n\nexport const TimeUnits = {\n  Microsecond: 1,\n  Second: 1000 * 1, //Microsecond,\n  Minute: 60 * 1000 * 1, //Second,\n  Hour: 60 * 60 * 1000 * 1, // Minute,\n};\nexport type TimeUnit = keyof typeof TimeUnits;\n","import { FileService } from \"./file-service.js\";\nimport { TimeMode, RandomMode, IDMode, SystemService, VoidFunc, SysAbstraction } from \"./sys-abstraction.js\";\nimport { Time } from \"./time.js\";\nimport { TxtEnDecoder } from \"./txt-en-decoder.js\";\n\nexport class SysTime extends Time {\n  Now(): Date {\n    return new Date();\n  }\n  Sleep(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        resolve();\n      }, duration);\n    });\n  }\n}\n\nexport class ConstTime extends Time {\n  Now(): Date {\n    return new Date(2021, 1, 1, 0, 0, 0, 0);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  Sleep(duration: number): Promise<void> {\n    return Promise.resolve();\n  }\n}\n\nexport class StepTime extends Time {\n  _step: Date;\n  readonly _start: Date;\n  constructor() {\n    super();\n    this._step = new ConstTime().Now();\n    this._start = this._step;\n  }\n  Now(steps = 1): Date {\n    // if (this._step.getTime() === 0) {\n    //   this._step = new ConstTime().Now();\n    //   return this._step;\n    // }\n    for (let i = 0; steps > 0 && i < steps; i++) {\n      this._step = new Date(this._step.getTime() + 1000);\n    }\n    if (steps < 1) {\n      this._step = new Date(this._start.getTime() + steps * -1000);\n    }\n    // this._step = new Date(this._step.getTime() + 1000);\n    return this._step;\n  }\n  Sleep(duration: number): Promise<void> {\n    this._step = new Date(this._step.getTime() + duration);\n    return Promise.resolve();\n  }\n}\n\nexport function TimeFactory(timeMode: TimeMode): Time {\n  switch (timeMode) {\n    case TimeMode.REAL:\n      return new SysTime();\n    case TimeMode.CONST:\n      return new ConstTime();\n    case TimeMode.STEP:\n      return new StepTime();\n  }\n  return new SysTime();\n}\n\nexport class RandomService {\n  readonly _mode: RandomMode;\n  _step = 0;\n  constructor(mode: RandomMode) {\n    this._mode = mode;\n  }\n  Random0ToValue(value: number): number {\n    switch (this._mode) {\n      case RandomMode.CONST:\n        return 0.5 * value;\n      case RandomMode.STEP:\n        this._step += 0.0001;\n        return this._step * value;\n      case RandomMode.RANDOM:\n        return Math.random() * value;\n      default:\n        throw new Error(\"Unknown RandomMode\");\n    }\n  }\n}\n\nexport class IdService {\n  readonly _mode: IDMode;\n  _step = 0;\n  constructor(mode?: IDMode) {\n    if (!mode) {\n      mode = IDMode.UUID;\n    }\n    this._mode = mode;\n  }\n  NextId(): string {\n    switch (this._mode) {\n      case IDMode.UUID:\n        return crypto.randomUUID();\n      case IDMode.CONST:\n        return \"VeryUniqueID\";\n      case IDMode.STEP:\n        return `STEPId-${this._step++}`;\n      default:\n        throw new Error(\"Unknown IDMode\");\n    }\n  }\n}\n\nexport interface BaseSysAbstractionParams {\n  readonly TxtEnDecoder: TxtEnDecoder;\n  readonly FileSystem: FileService;\n  readonly SystemService: SystemService;\n}\n\nexport interface ExitHandler {\n  readonly hdl: VoidFunc;\n  readonly id: string;\n}\n\nexport interface ExitService {\n  injectExitHandlers(hdls: ExitHandler[]): void;\n  exit(code: number): void;\n}\n\n// some black magic to make it work with CF workers\nfunction consumeReadableStream(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n  writeFn: (chunk: Uint8Array) => Promise<void>,\n): void {\n  reader\n    .read()\n    .then(({ done, value }) => {\n      if (done) {\n        return;\n      }\n      writeFn(value)\n        .then(() => {\n          consumeReadableStream(reader, writeFn);\n        })\n        .catch((e) => {\n          // eslint-disable-next-line no-console\n          console.error(\"consumeReadableStream:writeFn\", e);\n        });\n    })\n    .catch((e) => {\n      // eslint-disable-next-line no-console\n      console.error(\"consumeReadableStream:read\", e);\n    });\n}\n\nfunction CFWriteableStream(writeFn: (chunk: Uint8Array) => Promise<void>): WritableStream<Uint8Array> {\n  const ts = new TransformStream<Uint8Array, Uint8Array>();\n  consumeReadableStream(ts.readable.getReader(), writeFn);\n  return ts.writable;\n}\n\nexport class BaseSysAbstraction {\n  readonly _time: SysTime = new SysTime();\n  readonly _stdout: WritableStream<Uint8Array>;\n  readonly _stderr: WritableStream<Uint8Array>;\n\n  readonly _idService: IdService = new IdService();\n  readonly _randomService: RandomService = new RandomService(RandomMode.RANDOM);\n  readonly _fileSystem: FileService;\n  readonly _systemService: SystemService;\n  readonly _txtEnDe: TxtEnDecoder;\n\n  constructor(params: BaseSysAbstractionParams) {\n    this._fileSystem = params.FileSystem;\n    this._systemService = params.SystemService;\n    this._txtEnDe = params.TxtEnDecoder;\n    const decoder = this._txtEnDe;\n    this._stdout = CFWriteableStream((chunk) => {\n      const decoded = decoder.decode(chunk);\n      // eslint-disable-next-line no-console\n      console.log(decoded.trimEnd());\n      return Promise.resolve();\n    });\n    this._stderr = CFWriteableStream((chunk) => {\n      const decoded = decoder.decode(chunk);\n      // eslint-disable-next-line no-console\n      console.error(decoded.trimEnd());\n      return Promise.resolve();\n    });\n    /* this is not CF worker compatible\n    this._stdout = new WritableStream({\n      write(chunk): Promise<void> {\n        return new Promise((resolve) => {\n          const decoded = decoder.decode(chunk);\n          // eslint-disable-next-line no-console\n          console.log(decoded.trimEnd());\n          resolve();\n        });\n      },\n    });\n    this._stderr = new WritableStream({\n      write(chunk): Promise<void> {\n        return new Promise((resolve) => {\n          const decoded = decoder.decode(chunk);\n          // eslint-disable-next-line no-console\n          console.error(decoded.trimEnd());\n          resolve();\n        });\n      },\n    });\n    */\n  }\n}\n\nexport interface WrapperSysAbstractionParams {\n  readonly TimeMode?: TimeMode;\n  readonly IdMode?: IDMode;\n  readonly Stdout?: WritableStream<Uint8Array>;\n  readonly Stderr?: WritableStream<Uint8Array>;\n  readonly RandomMode?: RandomMode;\n  readonly FileSystem?: FileService;\n  readonly SystemService?: SystemService;\n  readonly TxtEnDecoder?: TxtEnDecoder;\n}\n\nexport class WrapperSysAbstraction implements SysAbstraction {\n  readonly _time: Time;\n  readonly _stdout: WritableStream<Uint8Array>;\n  readonly _stderr: WritableStream<Uint8Array>;\n  readonly _idService: IdService;\n  readonly _randomService: RandomService;\n  readonly _fileSystem: FileService;\n  readonly _systemService: SystemService;\n  constructor(base: BaseSysAbstraction, params?: WrapperSysAbstractionParams) {\n    this._time = base._time;\n    this._stdout = base._stdout;\n    this._stderr = base._stderr;\n    this._idService = base._idService;\n    this._randomService = base._randomService;\n    this._fileSystem = base._fileSystem;\n    this._systemService = base._systemService;\n    if (params) {\n      if (params.TimeMode) {\n        this._time = TimeFactory(params.TimeMode);\n      }\n      if (params.Stdout) {\n        this._stdout = params.Stdout;\n      }\n      if (params.Stderr) {\n        this._stderr = params.Stderr;\n      }\n      if (params.IdMode) {\n        this._idService = new IdService(params.IdMode);\n      }\n      if (params.RandomMode) {\n        this._randomService = new RandomService(params.RandomMode);\n      }\n      if (params.FileSystem) {\n        this._fileSystem = params.FileSystem;\n      }\n      if (params.SystemService) {\n        this._systemService = params.SystemService;\n      }\n    }\n  }\n  Time(): Time {\n    return this._time;\n  }\n  NextId(): string {\n    return this._idService.NextId();\n  }\n  Random0ToValue(value: number): number {\n    return this._randomService.Random0ToValue(value);\n  }\n  Stdout(): WritableStream {\n    return this._stdout;\n  }\n  Stderr(): WritableStream {\n    return this._stderr;\n  }\n\n  System(): SystemService {\n    return this._systemService;\n  }\n  FileSystem(): FileService {\n    return this._fileSystem;\n  }\n}\n// export const BaseSysAbstraction = new BaseSysAbstractionImpl()\n","export class Future<T> {\n  readonly #promise: Promise<T>;\n  #resolveFn: (value: T) => void = () => {\n    throw new Error(\"This Promise is not working as expected.\");\n  };\n  #rejectFn: (reason: unknown) => void = () => {\n    throw new Error(\"This Promise is not working as expected.\");\n  };\n\n  constructor() {\n    this.#promise = new Promise<T>((resolve, reject) => {\n      this.#resolveFn = resolve;\n      this.#rejectFn = reject;\n    });\n  }\n\n  async asPromise(): Promise<T> {\n    return this.#promise;\n  }\n\n  resolve(value: T): void {\n    this.#resolveFn(value);\n  }\n  reject(reason: unknown): void {\n    this.#rejectFn(reason);\n  }\n}\n","export interface LRUParam {\n  readonly maxEntries: number;\n  readonly maxAge: number; // not implemented\n}\n\nexport class LRUSet<T> {\n  private readonly _lruMap: LRUMap<T, T>;\n\n  constructor(param: Partial<LRUParam> = {}) {\n    this._lruMap = new LRUMap<T, T>(param);\n  }\n\n  setParam(param: Partial<LRUParam> = {}): void {\n    this._lruMap.setParam(param);\n  }\n\n  get size(): number {\n    return this._lruMap.size;\n  }\n\n  has(key: T): boolean {\n    return this._lruMap.has(key);\n  }\n\n  add(key: T): void {\n    this._lruMap.set(key, key);\n  }\n\n  delete(key: T): void {\n    this._lruMap.delete(key);\n  }\n\n  clear(): void {\n    this._lruMap.clear();\n  }\n\n  forEach(callbackfn: (value: T, key: T) => void): void {\n    this._lruMap.forEach((value) => callbackfn(value, value));\n  }\n\n  entries(): IterableIterator<[T, T]> {\n    return this._lruMap.entries();\n  }\n}\n\nexport class LRUMap<T, K> {\n  private _map: Map<T, K> = new Map<T, K>();\n  private param: LRUParam;\n\n  constructor(c: Partial<LRUParam> = {}) {\n    this.param = {\n      maxEntries: c.maxEntries || 100,\n      maxAge: c.maxAge || 0,\n    };\n  }\n\n  private touch(key: T): K {\n    if (!this._map.has(key)) {\n      throw new Error(`key not found in cache: ${key as unknown as string}`);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const value = this._map.get(key)!;\n    this._map.delete(key);\n    this._map.set(key, value);\n    return value;\n  }\n\n  setParam(param: Partial<LRUParam> = {}): void {\n    if (typeof param.maxEntries === \"number\") {\n      (this.param as { maxEntries: number }).maxEntries = param.maxEntries;\n      if (param.maxEntries > 0 && this._map.size > param.maxEntries) {\n        const toDelete: T[] = [];\n        let cacheSize = this._map.size;\n        for (const key of this._map.keys()) {\n          if (cacheSize > param.maxEntries) {\n            toDelete.push(key);\n            cacheSize--;\n          } else {\n            break;\n          }\n        }\n        for (const key of toDelete) {\n          this._map.delete(key);\n        }\n      }\n    }\n  }\n\n  has(key: T): boolean {\n    return this._map.has(key);\n  }\n\n  get size(): number {\n    return this._map.size;\n  }\n\n  async getSet(key: T, createFN: (key: T) => Promise<K>): Promise<K | undefined> {\n    const val = this.get(key);\n    if (val) {\n      return val;\n    } else {\n      const val = await createFN(key);\n      this.set(key, val as K);\n      return val;\n    }\n  }\n\n  get(key: T): K | undefined {\n    if (this._map.has(key)) {\n      return this.touch(key);\n    }\n    return this._map.get(key);\n  }\n\n  set(key: T, value: K): void {\n    this._map.delete(key);\n    if (this.param.maxEntries > 0 && this._map.size >= this.param.maxEntries) {\n      // delete the least recently accessed\n      // const key = Array.from(this.cache.keys())[0];\n      // this.cache.delete(key) or\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this._map.delete(this._map.keys().next().value!);\n      this._map.set(key, value);\n    } else {\n      this._map.set(key, value);\n    }\n  }\n\n  delete(key: T): void {\n    this._map.delete(key);\n  }\n\n  clear(): void {\n    this._map.clear();\n  }\n\n  forEach(callbackfn: (value: K, key: T, map: Map<T, K>) => void): void {\n    this._map.forEach(callbackfn);\n  }\n\n  entries(): IterableIterator<[T, K]> {\n    return this._map.entries();\n  }\n  // *entries(): IterableIterator<[T, K]> {\n  //   for (const x of this._cache.entries()) {\n  //     yield x;\n  //   }\n  // }\n\n  //   getLeastRecent(): K {\n  //     return Array.from(this.cache)[0];\n  //   }\n\n  //   getMostRecent(): K {\n  //     return Array.from(this.cache)[this.cache.size - 1];\n  //   }\n}\n","export abstract class Result<T, E = Error> {\n  static Ok<T = void>(t: T): Result<T, Error> {\n    return new ResultOK(t);\n  }\n  static Err<T, E extends Error = Error>(t: E | string | Result<unknown, E>): Result<T, E> {\n    if (typeof t === \"string\") {\n      return new ResultError(new Error(t) as E);\n    }\n    if (Result.Is(t)) {\n      if (t.is_ok()) {\n        return new ResultError(new Error(\"Result Error is Ok\") as E);\n      }\n      return t as Result<T, E>;\n    }\n    return new ResultError(t);\n  }\n  static Is<T>(t: unknown): t is Result<T> {\n    if (!t) {\n      return false;\n    }\n    if (t instanceof Result) {\n      return true;\n    }\n    const rt = t as Result<T>;\n    if ([typeof rt.is_ok, typeof rt.is_err, typeof rt.unwrap, typeof rt.unwrap_err].every((x) => x === \"function\")) {\n      return true;\n    }\n    return false;\n  }\n\n  isOk(): boolean {\n    return this.is_ok();\n  }\n  isErr(): boolean {\n    return this.is_err();\n  }\n\n  Ok(): T {\n    return this.unwrap();\n  }\n  Err(): E {\n    return this.unwrap_err();\n  }\n\n  abstract is_ok(): boolean;\n  abstract is_err(): boolean;\n  abstract unwrap(): T;\n  abstract unwrap_err(): E;\n}\n\nexport class ResultOK<T> extends Result<T, Error> {\n  private _t: T;\n  constructor(t: T) {\n    super();\n    this._t = t;\n  }\n  is_ok(): boolean {\n    return true;\n  }\n  is_err(): boolean {\n    return false;\n  }\n  unwrap_err(): Error {\n    throw new Error(\"Result is Ok\");\n  }\n  unwrap(): T {\n    return this._t;\n  }\n}\n\nexport class ResultError<T extends Error> extends Result<never, T> {\n  private _error: T;\n  constructor(t: T) {\n    super();\n    this._error = t;\n  }\n  is_ok(): boolean {\n    return false;\n  }\n  is_err(): boolean {\n    return true;\n  }\n  unwrap(): never {\n    throw new Error(`Result is Err: ${this._error}`);\n  }\n  unwrap_err(): T {\n    return this._error;\n  }\n}\n\nexport type WithoutResult<T> = T extends Result<infer U> ? U : T;\n\n// type WithoutPromise<T> = T extends Promise<infer U> ? U : T;\ntype WithResult<T> = T extends Promise<infer U> ? Promise<Result<U>> : Result<T>;\n\nexport function exception2Result<FN extends () => Promise<T> | T, T>(fn: FN): WithResult<ReturnType<FN>> {\n  try {\n    const res = fn();\n    if (res instanceof Promise) {\n      return res.then((value) => Result.Ok(value)).catch((e) => Result.Err(e)) as WithResult<ReturnType<FN>>;\n    }\n    return Result.Ok(res) as WithResult<ReturnType<FN>>;\n  } catch (e) {\n    return Result.Err(e as Error) as WithResult<ReturnType<FN>>;\n  }\n}\n\n/*\n\ntype FinalizedResult<T> = {\n  result: T;\n  scopeResult?: Result<void>;\n  finally: () => Promise<void>;\n}\n\ntype exection2ResultParam<T> = {\n  init: () => Promise<T>;\n  inScope?: (t: T) => Promise<void>;\n  cleanup: (t: T) => Promise<void>;\n\n}\n\nasync function expection2Result<T>({fn, inScope, cleanup}: exection2ResultParam<T>): Promise<Result<FinalizedResult<T>>> {\n  try {\n    const res = await fn();\n    if (inScope) {\n      try {\n        await inScope?.(res)\n      } catch (err) {\n        return Result.Err(err as Error)\n      }\n      await cleanup(res)\n      return Result.Ok({\n        result: res,\n        finally: async () => { }\n      })\n    }\n    return Result.Ok({\n      result: res ,\n      finally: async () => {\n        return cleanup(res)\n      }\n    })\n  } catch (err) {\n    return Result.Err(err as Error)\n  }\n}\n*/\n\n// await expection2Result({\n//   init: openDB,\n//   inScope: (res) => {\n//     res.query()\n//   },\n//   cleanup: async (y) => {\n//     await y.close()\n//  }\n// })\n// async function openDB() {\n//   try {\n//     const opendb = await openDB()\n//     return Result.Ok({\n//       openDB,\n//       finally: async () => {\n//         await opendb.close()\n//     }})\n//   } catch (err) {\n//     return Result.Err(err)\n//   }\n// }\n// }\n","import { Future } from \"./future.js\";\nimport { LRUMap, LRUParam } from \"./lru-map-set.js\";\nimport { Result } from \"./result.js\";\n\ninterface ResolveSeqItem<T, C> {\n  readonly future: Future<T>;\n  readonly fn: (c: C) => Promise<T>;\n  readonly id?: number;\n}\n\nexport class ResolveSeq<T, C = void> {\n  readonly ctx: C;\n  constructor(ctx?: C) {\n    this.ctx = ctx as C;\n  }\n  reset(): void {\n    /* noop */\n  }\n\n  readonly _flushWaiting: Future<void>[] = [];\n  flush(): Promise<void> {\n    if (this._seqFutures.length > 0) {\n      const waitForFlush = new Future<void>();\n      this._flushWaiting?.push(waitForFlush);\n      return waitForFlush.asPromise();\n    }\n    return Promise.resolve();\n  }\n  _step(item?: ResolveSeqItem<T, C>): Promise<void> {\n    if (!item) {\n      // done\n      this._flushWaiting.forEach((f) => f.resolve());\n      this._flushWaiting?.splice(0, this._flushWaiting.length);\n      return Promise.resolve();\n    }\n    item\n      .fn(this.ctx)\n      .then((value) => item.future.resolve(value))\n      .catch((e) => item.future.reject(e as Error))\n      .finally(() => {\n        this._seqFutures.shift();\n        void this._step(this._seqFutures[0]);\n      });\n    return Promise.resolve();\n  }\n  readonly _seqFutures: ResolveSeqItem<T, C>[] = [];\n  async add(fn: (c: C) => Promise<T>, id?: number): Promise<T> {\n    const future = new Future<T>();\n    this._seqFutures.push({ future, fn, id });\n    if (this._seqFutures.length === 1) {\n      void this._step(this._seqFutures[0]);\n    }\n    return future.asPromise();\n  }\n}\n\nexport class ResolveOnce<T, CTX = void> {\n  _onceDone = false;\n  readonly _onceFutures: Future<T>[] = [];\n  _onceOk = false;\n  _onceValue?: T;\n  _onceError?: Error;\n  _isPromise = false;\n  _inProgress?: Future<T>;\n\n  readonly ctx: CTX;\n\n  constructor(ctx?: CTX) {\n    this.ctx = ctx as CTX;\n  }\n\n  get ready(): boolean {\n    return this._onceDone;\n  }\n\n  reset(): void {\n    this._onceDone = false;\n    this._onceOk = false;\n    this._onceValue = undefined;\n    this._onceError = undefined;\n    if (this._inProgress) {\n      const idx = this._onceFutures.findIndex((f) => f === this._inProgress);\n      if (idx >= 0) {\n        // leave the current in progress future\n        this._onceFutures.push(...this._onceFutures.splice(2).slice(1));\n      }\n    } else {\n      this._onceFutures.length = 0;\n    }\n  }\n\n  // T extends Option<infer U> ? U : T\n  once<R>(fn: (c: CTX) => R): R {\n    if (this._onceDone) {\n      if (this._onceError) {\n        if (this._isPromise) {\n          return Promise.reject(this._onceError) as unknown as R;\n        } else {\n          throw this._onceError;\n        }\n      }\n      if (this._onceOk) {\n        if (this._isPromise) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          return Promise.resolve(this._onceValue!) as unknown as R;\n        } else {\n          return this._onceValue as unknown as R;\n        }\n      }\n      throw new Error(\"ResolveOnce.once impossible\");\n    }\n    const future = new Future<T>();\n    this._onceFutures.push(future);\n    if (this._onceFutures.length === 1) {\n      const okFn = (value: T): void => {\n        this._onceValue = value;\n        this._onceOk = true;\n        this._onceDone = true;\n        if (this._isPromise) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          this._onceFutures.forEach((f) => f.resolve(this._onceValue!));\n        }\n        this._onceFutures.length = 0;\n      };\n      const catchFn = (e: Error): void => {\n        this._onceError = e;\n        this._onceOk = false;\n        this._onceValue = undefined;\n        this._onceDone = true;\n        if (this._isPromise) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          this._onceFutures.forEach((f) => f.reject(this._onceError!));\n        }\n        this._onceFutures.length = 0;\n      };\n      this._inProgress = future;\n      // let inCriticalSection = false;\n      try {\n        const ret = fn(this.ctx);\n        if (typeof (ret as Promise<T>).then === \"function\") {\n          this._isPromise = true;\n          // inCriticalSection = true;\n          (ret as Promise<T>)\n            .then(okFn)\n            .catch(catchFn)\n            .finally(() => {\n              this._inProgress = undefined;\n            });\n        } else {\n          okFn(ret as unknown as T);\n        }\n      } catch (e) {\n        catchFn(e as Error);\n      }\n      if (!this._isPromise) {\n        this._inProgress = undefined;\n      }\n    }\n    if (this._isPromise) {\n      return future.asPromise() as unknown as R;\n    } else {\n      // abit funky but i don't want to impl the return just once\n      return this.once(fn);\n    }\n  }\n}\n\nexport interface KeyedParam {\n  readonly lru: Partial<LRUParam>;\n}\n\nexport class Keyed<T extends { reset: () => void }, K = string> {\n  protected readonly _map: LRUMap<K, T>;\n\n  readonly factory: (key: K) => T;\n  constructor(factory: (key: K) => T, params: Partial<KeyedParam>) {\n    this.factory = factory;\n    this._map = new LRUMap<K, T>(params?.lru ?? { maxEntries: -1 });\n  }\n\n  setParam(params: KeyedParam): void {\n    this._map.setParam(params.lru);\n  }\n\n  async asyncGet(key: () => Promise<K>): Promise<T> {\n    return this.get(await key());\n  }\n\n  get(key: K | (() => K)): T {\n    if (typeof key === \"function\") {\n      key = (key as () => K)();\n    }\n    let keyed = this._map.get(key);\n    if (!keyed) {\n      keyed = this.factory(key);\n      this._map.set(key, keyed);\n    }\n    return keyed;\n  }\n\n  unget(key: K): void {\n    const keyed = this._map.get(key);\n    keyed?.reset();\n    this._map.delete(key);\n  }\n\n  reset(): void {\n    this._map.forEach((keyed) => keyed.reset());\n    this._map.clear();\n  }\n}\n\nexport class KeyedResolvOnce<T, K = string> extends Keyed<ResolveOnce<T, K>, K> {\n  constructor(kp: Partial<KeyedParam> = {}) {\n    super((key) => new ResolveOnce<T, K>(key), kp);\n  }\n\n  /**\n   *\n   * @returns The values of the resolved keys\n   */\n  values(): { key: K; value: Result<T> }[] {\n    return (\n      Array.from(this._map.entries())\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        .filter(([_, v]) => v._onceDone)\n        .map(([k, v]) => {\n          if (v._onceDone) {\n            if (v._onceError) {\n              return {\n                key: k,\n                value: Result.Err(v._onceError),\n              };\n            }\n            return {\n              key: k,\n              value: Result.Ok(v._onceValue as T),\n            };\n          }\n          throw new Error(\"KeyedResolvOnce.values impossible\");\n        })\n    );\n  }\n}\n\nexport class KeyedResolvSeq<T, K = string> extends Keyed<ResolveSeq<T, K>, K> {\n  constructor(kp: Partial<KeyedParam> = {}) {\n    super((key) => new ResolveSeq<T, K>(key), kp);\n  }\n}\n","export interface Runtime {\n  isNodeIsh: boolean;\n  isBrowser: boolean;\n  isDeno: boolean;\n  isReactNative: boolean;\n  isCFWorker: boolean;\n}\n\nfunction isSet(value: string, ref: Record<string, unknown> = globalThis): boolean {\n  const [head, ...tail] = value.split(\".\");\n  if ([\"object\", \"function\"].includes(typeof ref) && ref && [\"object\", \"function\"].includes(typeof ref[head]) && ref[head]) {\n    if (tail.length <= 1) {\n      return true;\n    }\n    return isSet(tail.join(\".\"), ref[head] as Record<string, unknown>);\n  }\n  return false;\n}\n\n// caches.default or WebSocketPair\n\nexport function runtimeFn(): Runtime {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const gt: any = globalThis;\n  let isReactNative =\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    isSet(\"navigator.product\") && typeof gt[\"navigator\"] === \"object\" && gt[\"navigator\"][\"product\"] === \"ReactNative\";\n  let isNodeIsh = false;\n  if (!isSet(\"Deno\")) {\n    isNodeIsh = isSet(\"process.versions.node\") && !isReactNative;\n  }\n  let isDeno = isSet(\"Deno\");\n  const isCFWorker = isSet(\"caches.default\") && isSet(\"WebSocketPair\");\n  if (isCFWorker) {\n    isDeno = false;\n    isNodeIsh = false;\n    isReactNative = false;\n  }\n  return {\n    isNodeIsh,\n    isBrowser: !(isNodeIsh || isDeno || isCFWorker || isReactNative),\n    isDeno,\n    isReactNative,\n    isCFWorker,\n  };\n}\n","import { ResolveOnce } from \"../resolve-once.js\";\nimport { runtimeFn } from \"../runtime.js\";\nimport { Env, EnvActions, EnvFactoryOpts } from \"../sys-env.js\";\n\ninterface DenoEnv {\n  get: (key: string) => string | undefined;\n  toObject: () => Record<string, string>;\n  set: (key: string, value: string) => void;\n  has: (key: string) => boolean;\n  delete: (key: string) => void;\n}\n\nconst once = new ResolveOnce<DenoEnvActions>();\nexport class DenoEnvActions implements EnvActions {\n  readonly #deno = globalThis as unknown as {\n    Deno: {\n      env: DenoEnv;\n    };\n  };\n\n  static new(opts: Partial<EnvFactoryOpts>): EnvActions {\n    return once.once(() => new DenoEnvActions(opts));\n  }\n\n  get _env(): DenoEnv {\n    return this.#deno.Deno.env;\n  }\n\n  readonly opts: Partial<EnvFactoryOpts>;\n  private constructor(opts: Partial<EnvFactoryOpts>) {\n    this.opts = opts;\n  }\n\n  register(env: Env): Env {\n    for (const key of env.keys()) {\n      this._env.set(key, env.get(key) || \"\");\n    }\n    return env;\n  }\n  active(): boolean {\n    return runtimeFn().isDeno;\n  }\n  keys(): string[] {\n    return Object.keys(this._env.toObject());\n  }\n  get(key: string): string | undefined {\n    return this._env.get(key);\n  }\n  set(key: string, value?: string): void {\n    if (value) {\n      this._env.set(key, value);\n    }\n  }\n  delete(key: string): void {\n    this._env.delete(key);\n  }\n}\n","import { ResolveOnce } from \"../resolve-once.js\";\nimport { runtimeFn } from \"../runtime.js\";\nimport { Env, EnvActions, EnvFactoryOpts } from \"../sys-env.js\";\n\nconst once = new ResolveOnce<NodeEnvActions>();\nexport class NodeEnvActions implements EnvActions {\n  readonly #node = globalThis as unknown as { process: { env: Record<string, string> } };\n\n  static new(opts: Partial<EnvFactoryOpts>): EnvActions {\n    return once.once(() => new NodeEnvActions(opts));\n  }\n\n  readonly opts: Partial<EnvFactoryOpts>;\n  private constructor(opts: Partial<EnvFactoryOpts>) {\n    this.opts = opts;\n  }\n\n  register(env: Env): Env {\n    for (const key of env.keys()) {\n      this._env[key] = env.get(key) || \"\";\n    }\n    return env;\n  }\n\n  active(): boolean {\n    return runtimeFn().isNodeIsh;\n    // typeof this.#node === \"object\" && typeof this.#node.process === \"object\" && typeof this.#node.process.env === \"object\";\n  }\n  readonly _env: Record<string, string> = this.active() ? this.#node.process.env : {};\n  keys(): string[] {\n    return Object.keys(this._env);\n  }\n  get(key: string): string | undefined {\n    return this._env[key];\n  }\n  set(key: string, value?: string): void {\n    if (value) {\n      this._env[key] = value;\n    }\n  }\n  delete(key: string): void {\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    delete this._env[key];\n  }\n}\n","import { ResolveOnce } from \"../resolve-once.js\";\nimport { EnvActions, EnvFactoryOpts, Env } from \"../sys-env.js\";\n\nconst once = new ResolveOnce<BrowserEnvActions>();\nexport class BrowserEnvActions implements EnvActions {\n  readonly env: Map<string, string> = new Map<string, string>();\n  readonly opts: Partial<EnvFactoryOpts>;\n\n  static new(opts: Partial<EnvFactoryOpts>): EnvActions {\n    return once.once(() => new BrowserEnvActions(opts));\n  }\n\n  private constructor(opts: Partial<EnvFactoryOpts>) {\n    this.opts = opts;\n  }\n\n  get(key: string): string | undefined {\n    return this.env.get(key);\n  }\n  set(key: string, value?: string): void {\n    if (value) {\n      this.env.set(key, value);\n    }\n  }\n  delete(key: string): void {\n    this.env.delete(key);\n  }\n  keys(): string[] {\n    return Array.from(this.env.keys());\n  }\n  active(): boolean {\n    return true; // that should work on every runtime\n  }\n\n  register(env: Env): Env {\n    const sym = Symbol.for(this.opts.symbol || \"CP_ENV\");\n    const browser = globalThis as unknown as Record<symbol, Env>;\n    browser[sym] = env;\n    return env;\n  }\n}\n","import { ResolveOnce } from \"../resolve-once.js\";\nimport { runtimeFn } from \"../runtime.js\";\nimport { EnvActions, EnvImpl, EnvFactoryOpts, Env } from \"../sys-env.js\";\n\nconst once = new ResolveOnce<CFEnvActions>();\nexport class CFEnvActions implements EnvActions {\n  readonly injectOnRegister: Record<string, string> = {};\n  readonly cfEnv: Map<string, string>;\n  env?: EnvImpl;\n  static new(opts: Partial<EnvFactoryOpts>): EnvActions {\n    return once.once(() => new CFEnvActions(opts));\n  }\n  static inject(o: Record<string, string>): void {\n    const env = CFEnvActions.new({}) as CFEnvActions;\n    for (const key in o) {\n      const value = o[key];\n      if (typeof value === \"string\") {\n        if (env.env) {\n          env.env.set(key, value);\n        } else {\n          env.injectOnRegister[key] = value;\n        }\n      }\n    }\n  }\n  private constructor(env: Partial<EnvFactoryOpts>) {\n    this.cfEnv = new Map<string, string>(Object.entries(env.presetEnv || {}));\n  }\n  active(): boolean {\n    return runtimeFn().isCFWorker;\n  }\n  register(env: Env): Env {\n    this.env = env as EnvImpl;\n    for (const key in this.injectOnRegister) {\n      env.set(key, this.injectOnRegister[key]);\n    }\n    return env;\n  }\n  get(key: string): string | undefined {\n    return this.cfEnv.get(key);\n  }\n  set(key: string, value?: string): void {\n    if (value) {\n      this.cfEnv.set(key, value);\n    }\n  }\n  delete(key: string): void {\n    this.cfEnv.delete(key);\n  }\n  keys(): string[] {\n    return Array.from(this.cfEnv.keys());\n  }\n}\n","interface IType {\n  readonly type: string;\n}\nclass _Required implements IType {\n  readonly type = \"REQUIRED\";\n}\n\nclass _Optional implements IType {\n  readonly type = \"OPTIONAL\";\n}\n\nexport const param: {\n  REQUIRED: _Required;\n  OPTIONAL: _Optional;\n} = {\n  REQUIRED: new _Required(),\n  OPTIONAL: new _Optional(),\n};\nexport type param = (typeof param)[keyof typeof param];\n","import { Result } from \"../result.js\";\nimport { param } from \"../types.js\";\n\nexport type MsgFn = (...keys: string[]) => string;\nexport type KeysParam = (string | MsgFn | Record<string, param | number | string | boolean | undefined | null>)[];\n\nexport function getParamsResult(\n  keys: KeysParam,\n  getParam: { getParam: (key: string) => string | undefined },\n): Result<Record<string, string>> {\n  const keyDef = keys.flat().reduce(\n    (acc, i) => {\n      if (typeof i === \"string\") {\n        acc.push({ key: i, def: undefined, isOptional: false });\n      } else if (typeof i === \"object\") {\n        acc.push(\n          ...Object.keys(i).map((k) => ({\n            key: k,\n            def: typeof i[k] === \"string\" ? i[k] : undefined,\n            isOptional: i[k] === param.OPTIONAL,\n          })),\n        );\n      }\n      return acc;\n    },\n    [] as { key: string; def?: string; isOptional: boolean }[],\n  );\n  //.filter((k) => typeof k === \"string\");\n  const msgFn =\n    keys.find((k) => typeof k === \"function\") ||\n    ((...keys: string[]): string => {\n      const msg = keys.join(\",\");\n      return `missing parameters: ${msg}`;\n    });\n  const errors: string[] = [];\n  const result: Record<string, string> = {};\n  for (const kd of keyDef) {\n    const val = getParam.getParam(kd.key);\n    if (val === undefined) {\n      if (typeof kd.def === \"string\") {\n        result[kd.key] = kd.def;\n      } else {\n        if (!kd.isOptional) {\n          errors.push(kd.key);\n        }\n      }\n    } else {\n      result[kd.key] = val;\n    }\n  }\n  if (errors.length) {\n    return Result.Err(msgFn(...errors));\n  }\n  return Result.Ok(result);\n}\n","import { DenoEnvActions } from \"./deno/deno-env-actions.js\";\nimport { NodeEnvActions } from \"./node/node-env-actions.js\";\nimport { BrowserEnvActions } from \"./web/web-env-actions.js\";\nimport { CFEnvActions } from \"./cf/cf-env-actions.js\";\nimport { KeyedResolvOnce } from \"./resolve-once.js\";\nimport { Result } from \"./result.js\";\nimport { getParamsResult, KeysParam } from \"./utils/get-params-result.js\";\n\nexport type EnvTuple = ([string, string] | [string, string][] | Record<string, string> | Iterator<[string, string]>)[];\n\nexport interface EnvMap {\n  get(key: string): string | undefined;\n  set(key: string, value?: string): void;\n  delete(key: string): void;\n  keys(): string[];\n}\nexport interface EnvActions extends EnvMap {\n  active(): boolean;\n  register(env: Env): Env;\n}\n\nexport interface EnvFactoryOpts {\n  readonly symbol: string; // default \"CP_ENV\" used by BrowserEnvActions\n  readonly presetEnv: Map<string, string>;\n}\n\ntype OnSetFn = (key: string, value?: string) => void;\nexport interface OnSetItem {\n  readonly filter: Set<string>;\n  readonly fn: OnSetFn;\n}\n\nexport interface Env extends EnvMap {\n  onSet(fn: OnSetFn, ...filter: string[]): void;\n\n  gets(...kparams: KeysParam): Result<Record<string, string>>;\n  sets(...keys: EnvTuple): void;\n}\n\nexport type EnvFactoryFn = (opts: Partial<EnvFactoryOpts>) => EnvActions;\n\nconst envActions: { id: string; fn: EnvFactoryFn }[] = [\n  { id: \"cf\", fn: (opts: Partial<EnvFactoryOpts>): EnvActions => CFEnvActions.new(opts) },\n  { id: \"node\", fn: (opts: Partial<EnvFactoryOpts>): EnvActions => NodeEnvActions.new(opts) },\n  { id: \"deno\", fn: (opts: Partial<EnvFactoryOpts>): EnvActions => DenoEnvActions.new(opts) },\n  { id: \"browser\", fn: (opts: Partial<EnvFactoryOpts>): EnvActions => BrowserEnvActions.new(opts) },\n];\n\nexport function registerEnvAction(fn: EnvFactoryFn): () => void {\n  const id = `id-${Math.random()}`;\n  envActions.unshift({ id, fn });\n  // rerun envFactory\n  _envFactories.unget(id);\n  return () => {\n    const index = envActions.findIndex((i) => i.id === id);\n    if (index >= 0) {\n      envActions.splice(index, 1);\n    }\n  };\n}\n\nconst _envFactories = new KeyedResolvOnce<Env>();\nexport function envFactory(opts: Partial<EnvFactoryOpts> = {}): Env {\n  const found = envActions.find((fi) => fi.fn(opts).active());\n  if (!found) {\n    throw new Error(\"SysContainer:envFactory: no env available\");\n  }\n  return _envFactories.get(found.id).once(() => {\n    const action = found.fn(opts);\n    const ret = new EnvImpl(action, opts);\n    action.register(ret);\n    return ret;\n  });\n}\n\nfunction isIterable(obj: unknown): obj is Iterable<[string, string]> {\n  // checks for null and undefined\n  if (obj == null) {\n    return false;\n  }\n  return typeof (obj as Record<symbol, unknown>)[Symbol.iterator] === \"function\";\n}\n\nexport class EnvImpl implements Env {\n  readonly _map: EnvMap;\n  constructor(map: EnvMap, opts: Partial<EnvFactoryOpts> = {}) {\n    this._map = map;\n    this._updatePresets(opts.presetEnv);\n  }\n  gets(...kparams: KeysParam): Result<Record<string, string>> {\n    return getParamsResult(kparams, {\n      getParam: (k) => this.get(k),\n    });\n  }\n  sets(...keys: EnvTuple): void {\n    keys.forEach((key) => {\n      if (Array.isArray(key)) {\n        if (key.length === 2) {\n          const [k, v] = key;\n          if (typeof k === \"string\" && typeof v === \"string\") {\n            this.set(k, v);\n            return;\n          }\n        }\n        for (const item of key) {\n          if (Array.isArray(item)) {\n            // [string, string]\n            if (item.length === 2) {\n              const [k, v] = item;\n              if (typeof k === \"string\" && typeof v === \"string\") {\n                this.set(k, v);\n              }\n            }\n          }\n        }\n      } else {\n        if (isIterable(key)) {\n          for (const [k, v] of key) {\n            if (typeof k === \"string\" && typeof v === \"string\") {\n              this.set(k, v);\n            }\n          }\n        } else {\n          const rKey = key as Record<string, string>;\n          for (const k in rKey) {\n            const v = rKey[k];\n            if (typeof k === \"string\" && typeof v === \"string\") {\n              this.set(k, v);\n            }\n          }\n        }\n      }\n    });\n  }\n  _updatePresets(presetEnv?: Map<string, string>): void {\n    if (!presetEnv) {\n      return;\n    }\n    for (const [key, value] of presetEnv) {\n      this._map.set(key, value);\n    }\n  }\n  _applyOnSet(onSet: OnSetItem[], key?: string, value?: string): void {\n    onSet.forEach((item) => {\n      let keys: string[] = [];\n      if (key) {\n        keys = [key];\n      } else {\n        keys = this._map.keys();\n      }\n      keys\n        .filter((k) => {\n          if (item.filter.size === 0) {\n            return true;\n          }\n          if (item.filter.has(k)) {\n            return true;\n          }\n          return false;\n        })\n        .forEach((k) => {\n          let v;\n          if (!key && !value) {\n            // init\n            v = this._map.get(k);\n          } else if (key && !value) {\n            // del\n            v = undefined;\n          } else {\n            // set\n            v = value;\n          }\n          item.fn(k, v);\n        });\n    });\n  }\n  readonly _onSet: OnSetItem[] = [];\n  keys(): string[] {\n    return this._map.keys();\n  }\n  // filter is not set all sets passed\n  onSet(fn: OnSetFn, ...filter: string[]): void {\n    const item: OnSetItem = { filter: new Set(filter), fn };\n    this._onSet.push(item);\n    this._applyOnSet([item]);\n  }\n  get(key: string): string | undefined {\n    return this._map.get(key);\n  }\n  set(key: string, value?: string): void {\n    if (!value) {\n      return;\n    }\n    this._map.set(key, value);\n    this._applyOnSet(this._onSet, key, value);\n  }\n  delete(key: string): void {\n    this._map.delete(key);\n    this._applyOnSet(this._onSet, key);\n  }\n}\n\n// export const envImpl = new EnvImpl();\n","import { Result } from \"../result.js\";\n\n// Tested in txt-en-decoder.test.ts\n\ninterface GlobalBuffer {\n  Buffer?: {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    isBuffer: (obj: any) => obj is {\n      buffer: ArrayBufferLike;\n      byteOffset: number;\n      byteLength: number;\n    };\n  };\n}\nconst globalBuffer = globalThis as GlobalBuffer;\n\nexport type ToUInt8Plain = Uint8Array | ArrayBuffer | ArrayBufferView;\nexport type ToUInt8Async = ToUInt8Plain | Blob;\nexport type ToUInt8 = ToUInt8Plain | Result<ToUInt8Plain>;\nexport type AsyncToUInt8 = ToUInt8Async | Result<ToUInt8Async> | Promise<ToUInt8Async> | Promise<Result<ToUInt8Async>>;\n\nexport function coerceIntoUint8(raw: ToUInt8): Result<Uint8Array> {\n  if (raw instanceof ArrayBuffer) {\n    return Result.Ok(new Uint8Array(raw));\n  }\n  if (ArrayBuffer.isView(raw)) {\n    return Result.Ok(new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength));\n  }\n  if (raw instanceof Blob) {\n    return Result.Err(\"Blob not supported\");\n  }\n  if (globalBuffer.Buffer && globalBuffer.Buffer.isBuffer(raw)) {\n    return Result.Ok(new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength));\n  }\n  if (raw instanceof Uint8Array) {\n    return Result.Ok(raw);\n  }\n  if (Result.Is(raw)) {\n    if (raw.isErr()) {\n      return Result.Err(raw);\n    }\n    return coerceIntoUint8(raw.unwrap());\n  }\n  return Result.Err(\"Not a Uint8Array\");\n}\n\nexport async function asyncCoerceIntoUint8(raw: AsyncToUInt8): Promise<Result<Uint8Array>> {\n  let resolved = await raw;\n  if (resolved instanceof Blob) {\n    resolved = await resolved.arrayBuffer();\n  }\n  return coerceIntoUint8(resolved as ToUInt8);\n}\n","import { Result } from \"./result.js\";\nimport { coerceIntoUint8, ToUInt8 } from \"./utils/coerce-uint8.js\";\n\nexport type ToEnDecoder = ToUInt8 | string | Result<string>;\nexport type AsyncToEnDecoder = ToEnDecoder | Blob | Promise<ToEnDecoder | Blob>;\n\nexport interface TxtEnDecoder {\n  encode(input: string): Uint8Array;\n  decode(input: ToEnDecoder): string;\n  asyncDecode(input: AsyncToEnDecoder): Promise<string>;\n}\n\nclass TxtOps implements TxtEnDecoder {\n  readonly encoder = new TextEncoder();\n  readonly decoder = new TextDecoder();\n\n  encode(str: string): Uint8Array {\n    return this.encoder.encode(str);\n  }\n  decode(data: ToEnDecoder): string {\n    if (Result.Is(data)) {\n      if (data.isErr()) {\n        throw data.Err();\n      }\n      // only for string let do coerceInto the work\n      const unwrapped = data.unwrap();\n      if (typeof unwrapped === \"string\") {\n        return this.decode(unwrapped);\n      }\n    }\n    if (typeof data === \"string\") {\n      return data;\n    }\n    return this.decoder.decode(coerceIntoUint8(data as ToUInt8).Ok());\n  }\n\n  async asyncDecode(data: AsyncToEnDecoder): Promise<string> {\n    let resolved = await data;\n    if (resolved instanceof Blob) {\n      resolved = await resolved.arrayBuffer();\n    }\n    return this.decode(resolved);\n  }\n}\n\nlet txtEnDecoder: TxtEnDecoder;\nexport function TxtEnDecoderSingleton(): TxtEnDecoder {\n  txtEnDecoder = txtEnDecoder ?? new TxtOps();\n  return txtEnDecoder;\n}\n","import * as path from \"node:path\";\nimport { FileService, NamedWritableStream } from \"../file-service.js\";\nimport { TxtEnDecoder, TxtEnDecoderSingleton } from \"../txt-en-decoder.js\";\n\nconst Deno = (globalThis as unknown as { Deno: unknown }).Deno as {\n  cwd(): string;\n  readFile(fname: string): Promise<Uint8Array>;\n  mkdir(base: string, options: { recursive: boolean }): Promise<void>;\n  open(fname: string, options: { write: boolean; create: boolean; truncate: boolean }): Promise<WritableStream<Uint8Array>>;\n};\n\nexport class DenoFileService implements FileService {\n  readonly baseDir: string;\n  readonly txtEnde: TxtEnDecoder;\n  constructor(baseDir: string = Deno.cwd(), txtEnde: TxtEnDecoder = TxtEnDecoderSingleton()) {\n    this.baseDir = this.abs(baseDir);\n    this.txtEnde = txtEnde;\n  }\n\n  // nodeImport(fname: string): string {\n  //   // console.log('nodeImport:'+ fname);\n  //   if (path.isAbsolute(fname)) {\n  //     return fname;\n  //   } else {\n  //     return \"./\" + path.normalize(fname);\n  //   }\n  // }\n\n  async readFileString(fname: string): Promise<string> {\n    return this.txtEnde.decode(await Deno.readFile(fname));\n  }\n\n  dirname(fname: string): string {\n    return path.dirname(fname);\n  }\n  basename(fname: string): string {\n    return path.basename(fname);\n  }\n\n  join(...paths: string[]): string {\n    return path.join(...paths);\n  }\n\n  relative(from: string, to?: string): string {\n    if (to === undefined) {\n      to = from;\n      from = Deno.cwd();\n    }\n    const ret = path.relative(from, to);\n    // console.log('relative:'+ from + \" -> \" + to +   \"= \" + ret);\n    return ret;\n  }\n\n  abs(fname: string): string {\n    if (path.isAbsolute(fname)) {\n      return fname;\n    } else {\n      const cwd = Deno.cwd();\n      return path.resolve(cwd, fname);\n    }\n  }\n\n  isAbsolute(fname: string): boolean {\n    return path.isAbsolute(fname);\n  }\n\n  async writeFileString(fname: string, content: string, ende: TxtEnDecoder = TxtEnDecoderSingleton()): Promise<void> {\n    const o = await this.create(fname);\n    const wr = o.stream.getWriter();\n    await wr.write(ende.encode(content));\n    await wr.close();\n  }\n\n  async create(fname: string): Promise<NamedWritableStream> {\n    let oName = fname;\n    if (!path.isAbsolute(fname)) {\n      oName = this.abs(fname);\n    }\n\n    const base = path.dirname(oName);\n    await Deno.mkdir(base, { recursive: true });\n    const out = await Deno.open(oName, {\n      write: true,\n      create: true,\n      truncate: true,\n    });\n    return {\n      name: oName,\n      stream: out,\n    };\n  }\n}\n","import {\n  ExitService,\n  ExitHandler,\n  BaseSysAbstraction,\n  WrapperSysAbstractionParams,\n  WrapperSysAbstraction,\n} from \"../base-sys-abstraction.js\";\nimport { SysAbstraction, SystemService, VoidFunc } from \"../sys-abstraction.js\";\nimport { Env, envFactory } from \"../sys-env.js\";\nimport { TxtEnDecoderSingleton } from \"../txt-en-decoder.js\";\n// import * as process from \"node:process\";\nimport { DenoFileService } from \"./deno-file-service.js\";\n\nconst Deno = (globalThis as unknown as { Deno: unknown }).Deno as {\n  addSignalListener(sig: string, hdl: () => void): void;\n  exit(code?: number): void;\n  args: string[];\n};\n\nexport class DenoExitServiceImpl implements ExitService {\n  constructor() {\n    globalThis.addEventListener(\"unhandledrejection\", (e) => {\n      e.preventDefault();\n      this.exit(19);\n    });\n    globalThis.addEventListener(\"error\", () => {\n      this.exit(19);\n    });\n    globalThis.addEventListener(\"uncaughtException\", () => {\n      this.exit(19);\n    });\n\n    // process.on(\"close\", () => {\n    //   this.exit(0);\n    // });\n    globalThis.addEventListener(\"unload\", () => {\n      this.exit(0);\n      // console.log('goodbye!');\n    });\n\n    // process.on(\"exit\", () => {\n    // });\n    Deno.addSignalListener(\"SIGQUIT\", () => {\n      this.exit(3);\n    });\n    Deno.addSignalListener(\"SIGINT\", () => {\n      this.exit(2);\n    });\n    Deno.addSignalListener(\"SIGTERM\", () => {\n      this.exit(9);\n    });\n  }\n  _exitHandlers: ExitHandler[] = [];\n  injectExitHandlers(hdls: ExitHandler[]): void {\n    // console.log(\"ExitService: injecting exit handlers\", hdls)\n    this._exitHandlers = hdls;\n  }\n  invoked = false;\n  readonly _handleExit = async (): Promise<void> => {\n    if (this.invoked) {\n      // console.error(\"ExitService: already invoked\");\n      return;\n    }\n    this.invoked = true;\n    for (const h of this._exitHandlers) {\n      try {\n        // console.log(`ExitService: calling handler ${h.id}`)\n        const ret = h.hdl();\n        // console.log(`ExitService: called handler ${h.id}`, ret)\n        if (typeof (ret as Promise<void>).then === \"function\") {\n          await ret;\n        }\n      } finally {\n        // ignore\n      }\n    }\n  };\n\n  exit(code: number): void {\n    // console.log(\"ExitService: exit called\", code)\n    this._handleExit()\n      .then(() => {\n        Deno.exit(code);\n      })\n      .catch((err) => {\n        // eslint-disable-next-line no-console\n        console.error(\"ExitService: failed to handle exit\", err);\n        Deno.exit(code);\n      });\n  }\n}\n\nexport class DenoSystemService implements SystemService {\n  static readonly _exitHandlers: ExitHandler[] = [];\n  readonly _exitService: ExitService = new DenoExitServiceImpl();\n  constructor() {\n    this._exitService.injectExitHandlers(DenoSystemService._exitHandlers);\n  }\n\n  Env(): Env {\n    return envFactory();\n  }\n\n  Args(): string[] {\n    return Deno.args;\n  }\n\n  OnExit(hdl: VoidFunc): VoidFunc {\n    const id = crypto.randomUUID();\n    DenoSystemService._exitHandlers.push({ hdl, id });\n    return () => {\n      const idx = DenoSystemService._exitHandlers.findIndex((h) => h.id === id);\n      if (idx >= 0) {\n        DenoSystemService._exitHandlers.splice(idx, 1);\n      }\n    };\n  }\n\n  Exit(code: number): void {\n    this._exitService.exit(code);\n  }\n}\n\nlet my: BaseSysAbstraction | undefined = undefined;\nexport function DenoSysAbstraction(param?: WrapperSysAbstractionParams): SysAbstraction {\n  if (!my) {\n    my = new BaseSysAbstraction({\n      TxtEnDecoder: param?.TxtEnDecoder || TxtEnDecoderSingleton(),\n      FileSystem: new DenoFileService(),\n      SystemService: new DenoSystemService(),\n    });\n  }\n  return new WrapperSysAbstraction(my, param);\n}\n"],"mappings":"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","names":["resolve","resolve","param","val","once","once","once","keys","Deno","param"]}