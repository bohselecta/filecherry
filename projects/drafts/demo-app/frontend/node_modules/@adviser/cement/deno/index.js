import {
  BaseSysAbstraction,
  WrapperSysAbstraction,
  envFactory
} from "../chunk-23MCJYE6.js";
import {
  TxtEnDecoderSingleton
} from "../chunk-LXTKPZ6M.js";

// src/deno/deno-file-service.ts
import * as path from "node:path";
var Deno = globalThis.Deno;
var DenoFileService = class {
  constructor(baseDir = Deno.cwd(), txtEnde = TxtEnDecoderSingleton()) {
    this.baseDir = this.abs(baseDir);
    this.txtEnde = txtEnde;
  }
  // nodeImport(fname: string): string {
  //   // console.log('nodeImport:'+ fname);
  //   if (path.isAbsolute(fname)) {
  //     return fname;
  //   } else {
  //     return "./" + path.normalize(fname);
  //   }
  // }
  async readFileString(fname) {
    return this.txtEnde.decode(await Deno.readFile(fname));
  }
  dirname(fname) {
    return path.dirname(fname);
  }
  basename(fname) {
    return path.basename(fname);
  }
  join(...paths) {
    return path.join(...paths);
  }
  relative(from, to) {
    if (to === void 0) {
      to = from;
      from = Deno.cwd();
    }
    const ret = path.relative(from, to);
    return ret;
  }
  abs(fname) {
    if (path.isAbsolute(fname)) {
      return fname;
    } else {
      const cwd = Deno.cwd();
      return path.resolve(cwd, fname);
    }
  }
  isAbsolute(fname) {
    return path.isAbsolute(fname);
  }
  async writeFileString(fname, content, ende = TxtEnDecoderSingleton()) {
    const o = await this.create(fname);
    const wr = o.stream.getWriter();
    await wr.write(ende.encode(content));
    await wr.close();
  }
  async create(fname) {
    let oName = fname;
    if (!path.isAbsolute(fname)) {
      oName = this.abs(fname);
    }
    const base = path.dirname(oName);
    await Deno.mkdir(base, { recursive: true });
    const out = await Deno.open(oName, {
      write: true,
      create: true,
      truncate: true
    });
    return {
      name: oName,
      stream: out
    };
  }
};

// src/deno/deno-sys-abstraction.ts
var Deno2 = globalThis.Deno;
var DenoExitServiceImpl = class {
  constructor() {
    this._exitHandlers = [];
    this.invoked = false;
    this._handleExit = async () => {
      if (this.invoked) {
        return;
      }
      this.invoked = true;
      for (const h of this._exitHandlers) {
        try {
          const ret = h.hdl();
          if (typeof ret.then === "function") {
            await ret;
          }
        } finally {
        }
      }
    };
    globalThis.addEventListener("unhandledrejection", (e) => {
      e.preventDefault();
      this.exit(19);
    });
    globalThis.addEventListener("error", () => {
      this.exit(19);
    });
    globalThis.addEventListener("uncaughtException", () => {
      this.exit(19);
    });
    globalThis.addEventListener("unload", () => {
      this.exit(0);
    });
    Deno2.addSignalListener("SIGQUIT", () => {
      this.exit(3);
    });
    Deno2.addSignalListener("SIGINT", () => {
      this.exit(2);
    });
    Deno2.addSignalListener("SIGTERM", () => {
      this.exit(9);
    });
  }
  injectExitHandlers(hdls) {
    this._exitHandlers = hdls;
  }
  exit(code) {
    this._handleExit().then(() => {
      Deno2.exit(code);
    }).catch((err) => {
      console.error("ExitService: failed to handle exit", err);
      Deno2.exit(code);
    });
  }
};
var _DenoSystemService = class _DenoSystemService {
  constructor() {
    this._exitService = new DenoExitServiceImpl();
    this._exitService.injectExitHandlers(_DenoSystemService._exitHandlers);
  }
  Env() {
    return envFactory();
  }
  Args() {
    return Deno2.args;
  }
  OnExit(hdl) {
    const id = crypto.randomUUID();
    _DenoSystemService._exitHandlers.push({ hdl, id });
    return () => {
      const idx = _DenoSystemService._exitHandlers.findIndex((h) => h.id === id);
      if (idx >= 0) {
        _DenoSystemService._exitHandlers.splice(idx, 1);
      }
    };
  }
  Exit(code) {
    this._exitService.exit(code);
  }
};
_DenoSystemService._exitHandlers = [];
var DenoSystemService = _DenoSystemService;
var my = void 0;
function DenoSysAbstraction(param) {
  if (!my) {
    my = new BaseSysAbstraction({
      TxtEnDecoder: (param == null ? void 0 : param.TxtEnDecoder) || TxtEnDecoderSingleton(),
      FileSystem: new DenoFileService(),
      SystemService: new DenoSystemService()
    });
  }
  return new WrapperSysAbstraction(my, param);
}
export {
  DenoExitServiceImpl,
  DenoFileService,
  DenoSysAbstraction,
  DenoSystemService
};
//# sourceMappingURL=index.js.map