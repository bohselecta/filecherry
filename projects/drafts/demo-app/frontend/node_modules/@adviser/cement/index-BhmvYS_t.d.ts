import { R as Result, K as KeysParam, T as TxtEnDecoder } from './get-params-result-4xHM5s4_.js';
import { S as StripCommand } from './stripper-BpBUUZ9p.js';
import { S as SysAbstraction } from './sys-abstraction-B0x6IE7r.js';

declare abstract class Option<T> {
    static Some<T>(t: T): Option<T>;
    static None<T>(): Option<T>;
    static Is<T>(t: unknown): t is Option<T>;
    static From<T>(t?: T): Option<T>;
    IsNone(): boolean;
    IsSome(): boolean;
    Unwrap(): T;
    abstract is_none(): boolean;
    abstract is_some(): boolean;
    abstract unwrap(): T;
}
declare class Some<T> extends Option<T> {
    private _t;
    constructor(_t: T);
    is_none(): boolean;
    is_some(): boolean;
    unwrap(): T;
}
declare class None<T> extends Option<T> {
    is_none(): boolean;
    is_some(): boolean;
    unwrap(): T;
}
type WithoutOption<T> = T extends Option<infer U> ? U : T;

type NullOrUndef = null | undefined;
type OneKey<K extends string, V = string> = Record<K, V>;
interface URIInterface<R extends URIInterface<R>> {
    readonly getParams: Iterable<[string, string]>;
    hasParam(key: string): boolean;
    getParam<T extends string | undefined>(key: string | OneKey<string>, def?: T): T extends string ? string : string | undefined;
    getParamResult(key: string, msgFn?: (key: string) => string): Result<string>;
    getParamsResult(...keys: KeysParam): Result<Record<string, string>>;
    match(other: CoerceURI): MatchResult;
    clone(): R;
    asURL(): URL;
    toString(): string;
    toJSON(): string;
    asObj(...strips: StripCommand[]): Partial<HostURIObject | PathURIObject>;
}
interface MatchResult {
    readonly score: number;
    readonly protocol: boolean;
    readonly hostname: boolean;
    readonly port: boolean;
    readonly pathname: boolean;
    readonly pathParts: string[];
    readonly params: Record<string, string>;
}
interface URIObject {
    readonly style: "host" | "path";
    readonly protocol: string;
    readonly pathname: string;
    readonly searchParams: Record<string, string>;
}
interface PathURIObject extends URIObject {
    readonly style: "path";
}
interface HostURIObject extends URIObject {
    readonly style: "host";
    readonly hostname: string;
    readonly port: string;
}
declare function isURL(value: unknown): value is URL;
declare class MutableURL extends URL {
    private readonly _sysURL;
    private _protocol;
    private _pathname;
    private _hasHostpart;
    readonly hash: string;
    constructor(urlStr: string);
    clone(): MutableURL;
    get host(): string;
    get port(): string;
    set port(p: string);
    get hostname(): string;
    set hostname(h: string);
    set pathname(p: string);
    get pathname(): string;
    get protocol(): string;
    set protocol(p: string);
    get searchParams(): URLSearchParams;
    toString(): string;
}
declare class BuildURI implements URIInterface<BuildURI> {
    _url: MutableURL;
    private constructor();
    static is(value: unknown): value is BuildURI;
    static from(strURLUri?: CoerceURI, defaultProtocol?: string): BuildURI;
    match(other: CoerceURI): MatchResult;
    port(p: string): BuildURI;
    hostname(h: string): BuildURI;
    protocol(p: string): BuildURI;
    pathname(p: string): BuildURI;
    resolve(p: CoerceURI): BuildURI;
    appendRelative(p: CoerceURI): BuildURI;
    cleanParams(): BuildURI;
    delParam(key: string): BuildURI;
    defParam(key: string, str: string): BuildURI;
    setParam(key: string, str: string): BuildURI;
    hasParam(key: string): boolean;
    get getParams(): Iterable<[string, string]>;
    getParam<T extends string | undefined>(key: string | OneKey<string>, def?: T): T extends string ? string : string | undefined;
    getParamResult(key: string, msgFn?: (key: string) => string): Result<string>;
    getParamsResult(...keys: KeysParam): Result<Record<string, string>>;
    toString(): string;
    toJSON(): string;
    asURL(): URL;
    asObj(...strips: StripCommand[]): Partial<HostURIObject | PathURIObject>;
    clone(): BuildURI;
    URI(): URI;
}
type CoerceURI = string | URI | MutableURL | URL | BuildURI | NullOrUndef;
declare function isCoerceURI(value: unknown): value is CoerceURI;
declare const hasHostPartProtocols: Set<string>;
declare class URI implements URIInterface<URI> {
    static protocolHasHostpart(protocol: string): () => void;
    match(other: CoerceURI): MatchResult;
    static merge(into: CoerceURI, from: CoerceURI, defaultProtocol?: string): URI;
    static is(value: unknown): value is URI;
    static from(strURLUri?: CoerceURI, defaultProtocol?: string): URI;
    static fromResult(strURLUri?: CoerceURI, defaultProtocol?: string): Result<URI>;
    readonly _url: MutableURL;
    private constructor();
    build(): BuildURI;
    get hostname(): string;
    get port(): string;
    get host(): string;
    get protocol(): string;
    get pathname(): string;
    get getParams(): Iterable<[string, string]>;
    hasParam(key: string): boolean;
    getParam<T extends string | undefined>(key: string | OneKey<string>, def?: T): T extends string ? string : string | undefined;
    getParamResult(key: string, msgFn?: (key: string) => string): Result<string>;
    getParamsResult(...keys: KeysParam): Result<Record<string, string>>;
    clone(): URI;
    asURL(): URL;
    toString(): string;
    toJSON(): string;
    asObj(...strips: StripCommand[]): Partial<HostURIObject | PathURIObject>;
}

declare const Level: {
    WARN: string;
    DEBUG: string;
    INFO: string;
    ERROR: string;
};
type Level = (typeof Level)[keyof typeof Level];
type Serialized = string | number | boolean;
type FnSerialized = () => Serialized | Serialized[];
declare class LogValue {
    readonly fn: FnSerialized;
    constructor(fn: FnSerialized);
    value(): Serialized | Serialized[];
    toJSON(): Serialized | Serialized[];
}
type LogSerializable = Record<string, LogValue | Promise<LogValue>>;
declare function asyncLogValue(val: () => Promise<Serialized>): Promise<LogValue>;
type LogValueArg = LogValue | Serialized | Serialized[] | FnSerialized | undefined | null;
interface LogValueState {
    readonly state?: Set<unknown>;
    readonly ignoreAttr: Option<RegExp>;
}
declare function logValue(val: LogValueArg, ctx: LogValueState): LogValue;
interface Sized {
    size: number;
}
interface Lengthed {
    length: number;
}
type SizeOrLength = Sized | Lengthed;
interface LogFormatter {
    format(attr: LogSerializable): Uint8Array;
}
interface LevelHandler {
    enableLevel(level: Level, ...modules: string[]): void;
    disableLevel(level: Level, ...modules: string[]): void;
    setExposeStack(enable?: boolean): void;
    setIgnoreAttr(re?: RegExp): void;
    ignoreAttr: Option<RegExp>;
    isStackExposed: boolean;
    setDebug(...modules: (string | string[])[]): void;
    isEnabled(ilevel: unknown, module: unknown): boolean;
}
type HttpType = Response | Result<Response> | Request | Result<Request>;
interface LoggerInterface<R> {
    readonly levelHandler: LevelHandler;
    TxtEnDe(): TxtEnDecoder;
    Module(key: string): R;
    EnableLevel(level: Level, ...modules: string[]): R;
    DisableLevel(level: Level, ...modules: string[]): R;
    Attributes(): Record<string, unknown>;
    SetDebug(...modules: (string | string[])[]): R;
    SetIgnoreAttribute(re?: RegExp): R;
    SetExposeStack(enable?: boolean): R;
    SetFormatter(fmt: LogFormatter): R;
    Ref(key: string, action: {
        toString: () => string;
    } | FnSerialized): R;
    Result<T>(key: string, res: Result<T>): R;
    Url(url: CoerceURI, key?: string): R;
    Len(value: unknown, key?: string): R;
    Hash(value: unknown, key?: string): R;
    Str<T extends string | Record<string, string>>(key: T, value?: T extends string ? string : undefined): R;
    Uint64<T extends string | Record<string, number>>(key: T, value?: T extends string ? number : undefined): R;
    Int<T extends string | Record<string, number>>(key: T, value?: T extends string ? number : undefined): R;
    Bool<T extends string | Record<string, unknown>>(key: T, value?: T extends string ? unknown : undefined): R;
    Any<T extends string | Record<string, unknown>>(key: T, value?: T extends string ? unknown : undefined): R;
    Http(...mix: (HttpType | string)[]): R;
    Pair(x: Record<string, unknown>): R;
    Error(): R;
    Warn(): R;
    Debug(): R;
    Log(): R;
    WithLevel(level: Level): R;
    Err<T>(err: T | Result<T> | Error): R;
    Info(): R;
    Timestamp(): R;
    Dur(key: string, nsec: number): R;
}
declare function IsLogger(obj: unknown): obj is Logger;
interface WithLogger extends LoggerInterface<WithLogger> {
    Logger(): Logger;
}
interface AsError {
    AsError(): Error;
    ResultError<T>(): Result<T>;
}
interface Logger extends LoggerInterface<Logger> {
    With(): WithLogger;
    Msg(...args: string[]): AsError;
    Flush(): Promise<void>;
}

declare class Future<T> {
    #private;
    constructor();
    asPromise(): Promise<T>;
    resolve(value: T): void;
    reject(reason: unknown): void;
}

declare class LogWriteStream implements WritableStreamDefaultWriter<Uint8Array> {
    private readonly _bufferArr;
    constructor(bufferArr: Uint8Array[]);
    readonly _resolveClosed: Future<undefined>;
    readonly closed: Promise<undefined>;
    readonly desiredSize: number | null;
    readonly ready: Promise<undefined>;
    abort(reason?: any): Promise<void>;
    close(): Promise<void>;
    releaseLock(): void;
    write(chunk?: Uint8Array): Promise<void>;
}
declare class LogCollector implements WritableStream<Uint8Array> {
    readonly locked: boolean;
    private _writer?;
    private readonly _pass?;
    private readonly _bufferArr;
    private readonly _txtEnDe;
    constructor(pass?: WritableStreamDefaultWriter<Uint8Array>, txtEnDe?: TxtEnDecoder);
    abort(reason?: Uint8Array): Promise<void>;
    close(): Promise<void>;
    getWriter(): WritableStreamDefaultWriter<Uint8Array>;
    Logs(notJsonLine?: boolean): any[];
}

interface MockLoggerReturn {
    readonly logger: Logger;
    readonly logCollector: LogCollector;
}
declare function MockLogger(params?: {
    readonly sys?: SysAbstraction;
    readonly pass?: WritableStreamDefaultWriter<Uint8Array>;
    moduleName?: string | string[];
    readonly disableDebug?: boolean;
}): MockLoggerReturn;

export { type AsError as A, BuildURI as B, type CoerceURI as C, URI as D, type FnSerialized as F, type HttpType as H, IsLogger as I, type LogFormatter as L, type MockLoggerReturn as M, None as N, Option as O, type PathURIObject as P, type Serialized as S, type URIInterface as U, type WithLogger as W, type LogSerializable as a, type LevelHandler as b, type Logger as c, Level as d, Future as e, LogValue as f, asyncLogValue as g, type LogValueArg as h, type LogValueState as i, type Sized as j, type Lengthed as k, logValue as l, type SizeOrLength as m, type LoggerInterface as n, LogWriteStream as o, LogCollector as p, MockLogger as q, Some as r, type WithoutOption as s, type MatchResult as t, type URIObject as u, type HostURIObject as v, isURL as w, MutableURL as x, isCoerceURI as y, hasHostPartProtocols as z };
