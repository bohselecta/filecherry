import { K as KeysParam, R as Result } from './get-params-result-4xHM5s4_.js';

interface NamedWritableStream {
    readonly name: string;
    readonly stream: WritableStream<Uint8Array>;
}
interface FileService {
    readonly baseDir: string;
    create(fname: string): Promise<NamedWritableStream>;
    readFileString(fname: string): Promise<string>;
    writeFileString(fname: string, content: string): Promise<void>;
    abs(fname: string): string;
    join(...paths: string[]): string;
    relative(from: string, to?: string): string;
    dirname(fname: string): string;
    basename(fname: string): string;
    isAbsolute(fname: string): boolean;
}

type EnvTuple = ([string, string] | [string, string][] | Record<string, string> | Iterator<[string, string]>)[];
interface EnvMap {
    get(key: string): string | undefined;
    set(key: string, value?: string): void;
    delete(key: string): void;
    keys(): string[];
}
interface EnvActions extends EnvMap {
    active(): boolean;
    register(env: Env): Env;
}
interface EnvFactoryOpts {
    readonly symbol: string;
    readonly presetEnv: Map<string, string>;
}
type OnSetFn = (key: string, value?: string) => void;
interface OnSetItem {
    readonly filter: Set<string>;
    readonly fn: OnSetFn;
}
interface Env extends EnvMap {
    onSet(fn: OnSetFn, ...filter: string[]): void;
    gets(...kparams: KeysParam): Result<Record<string, string>>;
    sets(...keys: EnvTuple): void;
}
type EnvFactoryFn = (opts: Partial<EnvFactoryOpts>) => EnvActions;
declare function registerEnvAction(fn: EnvFactoryFn): () => void;
declare function envFactory(opts?: Partial<EnvFactoryOpts>): Env;
declare class EnvImpl implements Env {
    readonly _map: EnvMap;
    constructor(map: EnvMap, opts?: Partial<EnvFactoryOpts>);
    gets(...kparams: KeysParam): Result<Record<string, string>>;
    sets(...keys: EnvTuple): void;
    _updatePresets(presetEnv?: Map<string, string>): void;
    _applyOnSet(onSet: OnSetItem[], key?: string, value?: string): void;
    readonly _onSet: OnSetItem[];
    keys(): string[];
    onSet(fn: OnSetFn, ...filter: string[]): void;
    get(key: string): string | undefined;
    set(key: string, value?: string): void;
    delete(key: string): void;
}

declare abstract class Time {
    abstract Now(add?: number): Date;
    abstract Sleep(duration: Duration): Promise<void>;
    TimeSince(start: Date): Duration;
}
type Duration = number;
declare const TimeUnits: {
    Microsecond: number;
    Second: number;
    Minute: number;
    Hour: number;
};
type TimeUnit = keyof typeof TimeUnits;

declare const TimeMode: {
    REAL: string;
    CONST: string;
    STEP: string;
};
type TimeMode = (typeof TimeMode)[keyof typeof TimeMode];
declare const RandomMode: {
    CONST: string;
    STEP: string;
    RANDOM: string;
};
type RandomMode = (typeof RandomMode)[keyof typeof RandomMode];
declare const IDMode: {
    UUID: string;
    CONST: string;
    STEP: string;
};
type IDMode = (typeof IDMode)[keyof typeof IDMode];
declare function String2TimeMode(s?: string): TimeMode;
type VoidFunc = () => void | Promise<void>;
interface SystemService {
    Env(): Env;
    Args(): string[];
    OnExit(hdl: VoidFunc): VoidFunc;
    Exit(code: number): void;
}
interface SysAbstraction {
    Time(): Time;
    Stdout(): WritableStream<Uint8Array>;
    Stderr(): WritableStream<Uint8Array>;
    NextId(): string;
    Random0ToValue(value: number): number;
    System(): SystemService;
    FileSystem(): FileService;
}

export { type Duration as D, type Env as E, type FileService as F, IDMode as I, type NamedWritableStream as N, type OnSetItem as O, RandomMode as R, type SysAbstraction as S, Time as T, type VoidFunc as V, TimeMode as a, type SystemService as b, type EnvActions as c, EnvImpl as d, type EnvFactoryOpts as e, String2TimeMode as f, type EnvTuple as g, type EnvMap as h, type EnvFactoryFn as i, envFactory as j, TimeUnits as k, type TimeUnit as l, registerEnvAction as r };
