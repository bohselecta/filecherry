var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// src/result.ts
var Result = class _Result {
  static Ok(t) {
    return new ResultOK(t);
  }
  static Err(t) {
    if (typeof t === "string") {
      return new ResultError(new Error(t));
    }
    if (_Result.Is(t)) {
      if (t.is_ok()) {
        return new ResultError(new Error("Result Error is Ok"));
      }
      return t;
    }
    return new ResultError(t);
  }
  static Is(t) {
    if (!t) {
      return false;
    }
    if (t instanceof _Result) {
      return true;
    }
    const rt = t;
    if ([typeof rt.is_ok, typeof rt.is_err, typeof rt.unwrap, typeof rt.unwrap_err].every((x) => x === "function")) {
      return true;
    }
    return false;
  }
  isOk() {
    return this.is_ok();
  }
  isErr() {
    return this.is_err();
  }
  Ok() {
    return this.unwrap();
  }
  Err() {
    return this.unwrap_err();
  }
};
var ResultOK = class extends Result {
  constructor(t) {
    super();
    this._t = t;
  }
  is_ok() {
    return true;
  }
  is_err() {
    return false;
  }
  unwrap_err() {
    throw new Error("Result is Ok");
  }
  unwrap() {
    return this._t;
  }
};
var ResultError = class extends Result {
  constructor(t) {
    super();
    this._error = t;
  }
  is_ok() {
    return false;
  }
  is_err() {
    return true;
  }
  unwrap() {
    throw new Error(`Result is Err: ${this._error}`);
  }
  unwrap_err() {
    return this._error;
  }
};
function exception2Result(fn) {
  try {
    const res = fn();
    if (res instanceof Promise) {
      return res.then((value) => Result.Ok(value)).catch((e) => Result.Err(e));
    }
    return Result.Ok(res);
  } catch (e) {
    return Result.Err(e);
  }
}

// src/types.ts
var _Required = class {
  constructor() {
    this.type = "REQUIRED";
  }
};
var _Optional = class {
  constructor() {
    this.type = "OPTIONAL";
  }
};
var param = {
  REQUIRED: new _Required(),
  OPTIONAL: new _Optional()
};

// src/utils/get-params-result.ts
function getParamsResult(keys, getParam) {
  const keyDef = keys.flat().reduce(
    (acc, i) => {
      if (typeof i === "string") {
        acc.push({ key: i, def: void 0, isOptional: false });
      } else if (typeof i === "object") {
        acc.push(
          ...Object.keys(i).map((k) => ({
            key: k,
            def: typeof i[k] === "string" ? i[k] : void 0,
            isOptional: i[k] === param.OPTIONAL
          }))
        );
      }
      return acc;
    },
    []
  );
  const msgFn = keys.find((k) => typeof k === "function") || ((...keys2) => {
    const msg = keys2.join(",");
    return `missing parameters: ${msg}`;
  });
  const errors = [];
  const result = {};
  for (const kd of keyDef) {
    const val = getParam.getParam(kd.key);
    if (val === void 0) {
      if (typeof kd.def === "string") {
        result[kd.key] = kd.def;
      } else {
        if (!kd.isOptional) {
          errors.push(kd.key);
        }
      }
    } else {
      result[kd.key] = val;
    }
  }
  if (errors.length) {
    return Result.Err(msgFn(...errors));
  }
  return Result.Ok(result);
}

// src/utils/coerce-uint8.ts
var globalBuffer = globalThis;
function coerceIntoUint8(raw) {
  if (raw instanceof ArrayBuffer) {
    return Result.Ok(new Uint8Array(raw));
  }
  if (ArrayBuffer.isView(raw)) {
    return Result.Ok(new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength));
  }
  if (raw instanceof Blob) {
    return Result.Err("Blob not supported");
  }
  if (globalBuffer.Buffer && globalBuffer.Buffer.isBuffer(raw)) {
    return Result.Ok(new Uint8Array(raw.buffer, raw.byteOffset, raw.byteLength));
  }
  if (raw instanceof Uint8Array) {
    return Result.Ok(raw);
  }
  if (Result.Is(raw)) {
    if (raw.isErr()) {
      return Result.Err(raw);
    }
    return coerceIntoUint8(raw.unwrap());
  }
  return Result.Err("Not a Uint8Array");
}
async function asyncCoerceIntoUint8(raw) {
  let resolved = await raw;
  if (resolved instanceof Blob) {
    resolved = await resolved.arrayBuffer();
  }
  return coerceIntoUint8(resolved);
}

// src/txt-en-decoder.ts
var TxtOps = class {
  constructor() {
    this.encoder = new TextEncoder();
    this.decoder = new TextDecoder();
  }
  encode(str) {
    return this.encoder.encode(str);
  }
  decode(data) {
    if (Result.Is(data)) {
      if (data.isErr()) {
        throw data.Err();
      }
      const unwrapped = data.unwrap();
      if (typeof unwrapped === "string") {
        return this.decode(unwrapped);
      }
    }
    if (typeof data === "string") {
      return data;
    }
    return this.decoder.decode(coerceIntoUint8(data).Ok());
  }
  async asyncDecode(data) {
    let resolved = await data;
    if (resolved instanceof Blob) {
      resolved = await resolved.arrayBuffer();
    }
    return this.decode(resolved);
  }
};
var txtEnDecoder;
function TxtEnDecoderSingleton() {
  txtEnDecoder = txtEnDecoder != null ? txtEnDecoder : new TxtOps();
  return txtEnDecoder;
}

export {
  __export,
  __privateGet,
  __privateAdd,
  __privateSet,
  __privateMethod,
  Result,
  ResultOK,
  ResultError,
  exception2Result,
  param,
  getParamsResult,
  coerceIntoUint8,
  asyncCoerceIntoUint8,
  TxtEnDecoderSingleton
};
//# sourceMappingURL=chunk-LXTKPZ6M.js.map