import {
  BaseSysAbstraction,
  WrapperSysAbstraction,
  envFactory
} from "../chunk-23MCJYE6.js";
import {
  TxtEnDecoderSingleton
} from "../chunk-LXTKPZ6M.js";

// src/node/node-file-service.ts
import path from "node:path";
import fs from "node:fs";
import process from "node:process";
var NodeFileService = class {
  constructor(baseDir = process.cwd()) {
    this.baseDir = this.abs(baseDir);
  }
  // nodeImport(fname: string): string {
  //   // console.log('nodeImport:'+ fname);
  //   if (path.isAbsolute(fname)) {
  //     return fname;
  //   } else {
  //     return "./" + path.normalize(fname);
  //   }
  // }
  readFileString(fname) {
    return fs.promises.readFile(fname, { encoding: "utf-8" });
  }
  dirname(fname) {
    return path.dirname(fname);
  }
  basename(fname) {
    return path.basename(fname);
  }
  join(...paths) {
    return path.join(...paths);
  }
  relative(from, to) {
    if (to === void 0) {
      to = from;
      from = process.cwd();
    }
    const ret = path.relative(from, to);
    return ret;
  }
  abs(fname) {
    if (path.isAbsolute(fname)) {
      return fname;
    } else {
      const cwd = process.cwd();
      return path.resolve(cwd, fname);
    }
  }
  isAbsolute(fname) {
    return path.isAbsolute(fname);
  }
  async writeFileString(fname, content, ende = TxtEnDecoderSingleton()) {
    const o = await this.create(fname);
    const wr = o.stream.getWriter();
    await wr.write(ende.encode(content));
    await wr.close();
  }
  async create(fname) {
    let oName = fname;
    if (!path.isAbsolute(fname)) {
      oName = this.abs(fname);
    }
    const base = path.dirname(oName);
    await fs.promises.mkdir(base, { recursive: true });
    const out = fs.createWriteStream(oName);
    return {
      name: oName,
      stream: new WritableStream({
        write(chunk) {
          out.write(chunk);
        },
        close() {
          out.close();
        },
        abort() {
          throw new Error("not implemented");
        }
      })
    };
  }
};

// src/node/node-sys-abstraction.ts
import process2 from "node:process";
var NodeExitServiceImpl = class {
  constructor() {
    this._exitHandlers = [];
    this.invoked = false;
    this._handleExit = async () => {
      if (this.invoked) {
        return;
      }
      this.invoked = true;
      for (const h of this._exitHandlers) {
        try {
          const ret = h.hdl();
          if (typeof ret.then === "function") {
            await ret;
          }
        } finally {
        }
      }
    };
    process2.on("unhandledRejection", (reason, p) => {
      this.exit(19);
    });
    process2.on("uncaughtException", (error) => {
      this.exit(18);
    });
    process2.on("close", () => {
      this.exit(0);
    });
    process2.on("exit", () => {
      this.exit(0);
    });
    process2.on("SIGQUIT", () => {
      this.exit(3);
    });
    process2.on("SIGINT", () => {
      this.exit(2);
    });
    process2.on("SIGTERM", () => {
      this.exit(9);
    });
  }
  injectExitHandlers(hdls) {
    this._exitHandlers = hdls;
  }
  exit(code) {
    this._handleExit().then(() => {
      process2.exit(code);
    }).catch((err) => {
      console.error("ExitService: failed to handle exit", err);
      process2.exit(code);
    });
  }
};
var _NodeSystemService = class _NodeSystemService {
  constructor() {
    this._exitService = new NodeExitServiceImpl();
    this._exitService.injectExitHandlers(_NodeSystemService._exitHandlers);
  }
  Env() {
    return envFactory();
  }
  Args() {
    return process2.argv;
  }
  OnExit(hdl) {
    const id = crypto.randomUUID();
    _NodeSystemService._exitHandlers.push({ hdl, id });
    return () => {
      const idx = _NodeSystemService._exitHandlers.findIndex((h) => h.id === id);
      if (idx >= 0) {
        _NodeSystemService._exitHandlers.splice(idx, 1);
      }
    };
  }
  Exit(code) {
    this._exitService.exit(code);
  }
};
_NodeSystemService._exitHandlers = [];
var NodeSystemService = _NodeSystemService;
var my = void 0;
function NodeSysAbstraction(param) {
  if (!my) {
    my = new BaseSysAbstraction({
      TxtEnDecoder: (param == null ? void 0 : param.TxtEnDecoder) || TxtEnDecoderSingleton(),
      FileSystem: new NodeFileService(),
      SystemService: new NodeSystemService()
    });
  }
  return new WrapperSysAbstraction(my, param);
}

// src/node/mock-file-service.ts
var MockFileService = class extends NodeFileService {
  constructor() {
    super(...arguments);
    this.files = {};
  }
  // override abs(fname: string): string {
  //   return this.join("/mock/", fname);
  // }
  create(fname) {
    let oName = fname;
    if (!this.isAbsolute(fname)) {
      oName = this.abs(fname);
    }
    const fc = {
      name: oName,
      content: ""
    };
    this.files[oName] = fc;
    this.files[fname] = fc;
    const decoder = new TextDecoder();
    return Promise.resolve({
      name: oName,
      stream: new WritableStream({
        write(chunk) {
          fc.content = fc.content + decoder.decode(chunk);
        },
        close() {
        },
        abort() {
          throw new Error("not implemented");
        }
      })
    });
  }
};
export {
  MockFileService,
  NodeExitServiceImpl,
  NodeFileService,
  NodeSysAbstraction,
  NodeSystemService
};
//# sourceMappingURL=index.js.map