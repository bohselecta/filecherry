import {
  Result,
  __privateAdd,
  __privateGet,
  __privateSet,
  getParamsResult
} from "./chunk-LXTKPZ6M.js";

// src/sys-abstraction.ts
var TimeMode = {
  REAL: "real",
  CONST: "const",
  STEP: "step"
};
var RandomMode = {
  CONST: "const",
  STEP: "step",
  RANDOM: "random"
};
var IDMode = {
  UUID: "uuid",
  CONST: "const",
  STEP: "step"
};
function String2TimeMode(s) {
  switch (s == null ? void 0 : s.toLowerCase()) {
    case "real":
      return TimeMode.REAL;
    case "const":
      return TimeMode.CONST;
    case "step":
      return TimeMode.STEP;
    default:
      return TimeMode.REAL;
  }
}

// src/time.ts
var Time = class {
  TimeSince(start) {
    const now = this.Now();
    return now.getTime() - start.getTime();
  }
};
var TimeUnits = {
  Microsecond: 1,
  Second: 1e3 * 1,
  //Microsecond,
  Minute: 60 * 1e3 * 1,
  //Second,
  Hour: 60 * 60 * 1e3 * 1
  // Minute,
};

// src/base-sys-abstraction.ts
var SysTime = class extends Time {
  Now() {
    return /* @__PURE__ */ new Date();
  }
  Sleep(duration) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, duration);
    });
  }
};
var ConstTime = class extends Time {
  Now() {
    return new Date(2021, 1, 1, 0, 0, 0, 0);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  Sleep(duration) {
    return Promise.resolve();
  }
};
var StepTime = class extends Time {
  constructor() {
    super();
    this._step = new ConstTime().Now();
    this._start = this._step;
  }
  Now(steps = 1) {
    for (let i = 0; steps > 0 && i < steps; i++) {
      this._step = new Date(this._step.getTime() + 1e3);
    }
    if (steps < 1) {
      this._step = new Date(this._start.getTime() + steps * -1e3);
    }
    return this._step;
  }
  Sleep(duration) {
    this._step = new Date(this._step.getTime() + duration);
    return Promise.resolve();
  }
};
function TimeFactory(timeMode) {
  switch (timeMode) {
    case TimeMode.REAL:
      return new SysTime();
    case TimeMode.CONST:
      return new ConstTime();
    case TimeMode.STEP:
      return new StepTime();
  }
  return new SysTime();
}
var RandomService = class {
  constructor(mode) {
    this._step = 0;
    this._mode = mode;
  }
  Random0ToValue(value) {
    switch (this._mode) {
      case RandomMode.CONST:
        return 0.5 * value;
      case RandomMode.STEP:
        this._step += 1e-4;
        return this._step * value;
      case RandomMode.RANDOM:
        return Math.random() * value;
      default:
        throw new Error("Unknown RandomMode");
    }
  }
};
var IdService = class {
  constructor(mode) {
    this._step = 0;
    if (!mode) {
      mode = IDMode.UUID;
    }
    this._mode = mode;
  }
  NextId() {
    switch (this._mode) {
      case IDMode.UUID:
        return crypto.randomUUID();
      case IDMode.CONST:
        return "VeryUniqueID";
      case IDMode.STEP:
        return `STEPId-${this._step++}`;
      default:
        throw new Error("Unknown IDMode");
    }
  }
};
function consumeReadableStream(reader, writeFn) {
  reader.read().then(({ done, value }) => {
    if (done) {
      return;
    }
    writeFn(value).then(() => {
      consumeReadableStream(reader, writeFn);
    }).catch((e) => {
      console.error("consumeReadableStream:writeFn", e);
    });
  }).catch((e) => {
    console.error("consumeReadableStream:read", e);
  });
}
function CFWriteableStream(writeFn) {
  const ts = new TransformStream();
  consumeReadableStream(ts.readable.getReader(), writeFn);
  return ts.writable;
}
var BaseSysAbstraction = class {
  constructor(params) {
    this._time = new SysTime();
    this._idService = new IdService();
    this._randomService = new RandomService(RandomMode.RANDOM);
    this._fileSystem = params.FileSystem;
    this._systemService = params.SystemService;
    this._txtEnDe = params.TxtEnDecoder;
    const decoder = this._txtEnDe;
    this._stdout = CFWriteableStream((chunk) => {
      const decoded = decoder.decode(chunk);
      console.log(decoded.trimEnd());
      return Promise.resolve();
    });
    this._stderr = CFWriteableStream((chunk) => {
      const decoded = decoder.decode(chunk);
      console.error(decoded.trimEnd());
      return Promise.resolve();
    });
  }
};
var WrapperSysAbstraction = class {
  constructor(base, params) {
    this._time = base._time;
    this._stdout = base._stdout;
    this._stderr = base._stderr;
    this._idService = base._idService;
    this._randomService = base._randomService;
    this._fileSystem = base._fileSystem;
    this._systemService = base._systemService;
    if (params) {
      if (params.TimeMode) {
        this._time = TimeFactory(params.TimeMode);
      }
      if (params.Stdout) {
        this._stdout = params.Stdout;
      }
      if (params.Stderr) {
        this._stderr = params.Stderr;
      }
      if (params.IdMode) {
        this._idService = new IdService(params.IdMode);
      }
      if (params.RandomMode) {
        this._randomService = new RandomService(params.RandomMode);
      }
      if (params.FileSystem) {
        this._fileSystem = params.FileSystem;
      }
      if (params.SystemService) {
        this._systemService = params.SystemService;
      }
    }
  }
  Time() {
    return this._time;
  }
  NextId() {
    return this._idService.NextId();
  }
  Random0ToValue(value) {
    return this._randomService.Random0ToValue(value);
  }
  Stdout() {
    return this._stdout;
  }
  Stderr() {
    return this._stderr;
  }
  System() {
    return this._systemService;
  }
  FileSystem() {
    return this._fileSystem;
  }
};

// src/future.ts
var _promise, _resolveFn, _rejectFn;
var Future = class {
  constructor() {
    __privateAdd(this, _promise);
    __privateAdd(this, _resolveFn, () => {
      throw new Error("This Promise is not working as expected.");
    });
    __privateAdd(this, _rejectFn, () => {
      throw new Error("This Promise is not working as expected.");
    });
    __privateSet(this, _promise, new Promise((resolve, reject) => {
      __privateSet(this, _resolveFn, resolve);
      __privateSet(this, _rejectFn, reject);
    }));
  }
  async asPromise() {
    return __privateGet(this, _promise);
  }
  resolve(value) {
    __privateGet(this, _resolveFn).call(this, value);
  }
  reject(reason) {
    __privateGet(this, _rejectFn).call(this, reason);
  }
};
_promise = new WeakMap();
_resolveFn = new WeakMap();
_rejectFn = new WeakMap();

// src/lru-map-set.ts
var LRUSet = class {
  constructor(param = {}) {
    this._lruMap = new LRUMap(param);
  }
  setParam(param = {}) {
    this._lruMap.setParam(param);
  }
  get size() {
    return this._lruMap.size;
  }
  has(key) {
    return this._lruMap.has(key);
  }
  add(key) {
    this._lruMap.set(key, key);
  }
  delete(key) {
    this._lruMap.delete(key);
  }
  clear() {
    this._lruMap.clear();
  }
  forEach(callbackfn) {
    this._lruMap.forEach((value) => callbackfn(value, value));
  }
  entries() {
    return this._lruMap.entries();
  }
};
var LRUMap = class {
  constructor(c = {}) {
    this._map = /* @__PURE__ */ new Map();
    this.param = {
      maxEntries: c.maxEntries || 100,
      maxAge: c.maxAge || 0
    };
  }
  touch(key) {
    if (!this._map.has(key)) {
      throw new Error(`key not found in cache: ${key}`);
    }
    const value = this._map.get(key);
    this._map.delete(key);
    this._map.set(key, value);
    return value;
  }
  setParam(param = {}) {
    if (typeof param.maxEntries === "number") {
      this.param.maxEntries = param.maxEntries;
      if (param.maxEntries > 0 && this._map.size > param.maxEntries) {
        const toDelete = [];
        let cacheSize = this._map.size;
        for (const key of this._map.keys()) {
          if (cacheSize > param.maxEntries) {
            toDelete.push(key);
            cacheSize--;
          } else {
            break;
          }
        }
        for (const key of toDelete) {
          this._map.delete(key);
        }
      }
    }
  }
  has(key) {
    return this._map.has(key);
  }
  get size() {
    return this._map.size;
  }
  async getSet(key, createFN) {
    const val = this.get(key);
    if (val) {
      return val;
    } else {
      const val2 = await createFN(key);
      this.set(key, val2);
      return val2;
    }
  }
  get(key) {
    if (this._map.has(key)) {
      return this.touch(key);
    }
    return this._map.get(key);
  }
  set(key, value) {
    this._map.delete(key);
    if (this.param.maxEntries > 0 && this._map.size >= this.param.maxEntries) {
      this._map.delete(this._map.keys().next().value);
      this._map.set(key, value);
    } else {
      this._map.set(key, value);
    }
  }
  delete(key) {
    this._map.delete(key);
  }
  clear() {
    this._map.clear();
  }
  forEach(callbackfn) {
    this._map.forEach(callbackfn);
  }
  entries() {
    return this._map.entries();
  }
  // *entries(): IterableIterator<[T, K]> {
  //   for (const x of this._cache.entries()) {
  //     yield x;
  //   }
  // }
  //   getLeastRecent(): K {
  //     return Array.from(this.cache)[0];
  //   }
  //   getMostRecent(): K {
  //     return Array.from(this.cache)[this.cache.size - 1];
  //   }
};

// src/resolve-once.ts
var ResolveSeq = class {
  constructor(ctx) {
    this._flushWaiting = [];
    this._seqFutures = [];
    this.ctx = ctx;
  }
  reset() {
  }
  flush() {
    var _a;
    if (this._seqFutures.length > 0) {
      const waitForFlush = new Future();
      (_a = this._flushWaiting) == null ? void 0 : _a.push(waitForFlush);
      return waitForFlush.asPromise();
    }
    return Promise.resolve();
  }
  _step(item) {
    var _a;
    if (!item) {
      this._flushWaiting.forEach((f) => f.resolve());
      (_a = this._flushWaiting) == null ? void 0 : _a.splice(0, this._flushWaiting.length);
      return Promise.resolve();
    }
    item.fn(this.ctx).then((value) => item.future.resolve(value)).catch((e) => item.future.reject(e)).finally(() => {
      this._seqFutures.shift();
      void this._step(this._seqFutures[0]);
    });
    return Promise.resolve();
  }
  async add(fn, id) {
    const future = new Future();
    this._seqFutures.push({ future, fn, id });
    if (this._seqFutures.length === 1) {
      void this._step(this._seqFutures[0]);
    }
    return future.asPromise();
  }
};
var ResolveOnce = class {
  constructor(ctx) {
    this._onceDone = false;
    this._onceFutures = [];
    this._onceOk = false;
    this._isPromise = false;
    this.ctx = ctx;
  }
  get ready() {
    return this._onceDone;
  }
  reset() {
    this._onceDone = false;
    this._onceOk = false;
    this._onceValue = void 0;
    this._onceError = void 0;
    if (this._inProgress) {
      const idx = this._onceFutures.findIndex((f) => f === this._inProgress);
      if (idx >= 0) {
        this._onceFutures.push(...this._onceFutures.splice(2).slice(1));
      }
    } else {
      this._onceFutures.length = 0;
    }
  }
  // T extends Option<infer U> ? U : T
  once(fn) {
    if (this._onceDone) {
      if (this._onceError) {
        if (this._isPromise) {
          return Promise.reject(this._onceError);
        } else {
          throw this._onceError;
        }
      }
      if (this._onceOk) {
        if (this._isPromise) {
          return Promise.resolve(this._onceValue);
        } else {
          return this._onceValue;
        }
      }
      throw new Error("ResolveOnce.once impossible");
    }
    const future = new Future();
    this._onceFutures.push(future);
    if (this._onceFutures.length === 1) {
      const okFn = (value) => {
        this._onceValue = value;
        this._onceOk = true;
        this._onceDone = true;
        if (this._isPromise) {
          this._onceFutures.forEach((f) => f.resolve(this._onceValue));
        }
        this._onceFutures.length = 0;
      };
      const catchFn = (e) => {
        this._onceError = e;
        this._onceOk = false;
        this._onceValue = void 0;
        this._onceDone = true;
        if (this._isPromise) {
          this._onceFutures.forEach((f) => f.reject(this._onceError));
        }
        this._onceFutures.length = 0;
      };
      this._inProgress = future;
      try {
        const ret = fn(this.ctx);
        if (typeof ret.then === "function") {
          this._isPromise = true;
          ret.then(okFn).catch(catchFn).finally(() => {
            this._inProgress = void 0;
          });
        } else {
          okFn(ret);
        }
      } catch (e) {
        catchFn(e);
      }
      if (!this._isPromise) {
        this._inProgress = void 0;
      }
    }
    if (this._isPromise) {
      return future.asPromise();
    } else {
      return this.once(fn);
    }
  }
};
var Keyed = class {
  constructor(factory, params) {
    var _a;
    this.factory = factory;
    this._map = new LRUMap((_a = params == null ? void 0 : params.lru) != null ? _a : { maxEntries: -1 });
  }
  setParam(params) {
    this._map.setParam(params.lru);
  }
  async asyncGet(key) {
    return this.get(await key());
  }
  get(key) {
    if (typeof key === "function") {
      key = key();
    }
    let keyed = this._map.get(key);
    if (!keyed) {
      keyed = this.factory(key);
      this._map.set(key, keyed);
    }
    return keyed;
  }
  unget(key) {
    const keyed = this._map.get(key);
    keyed == null ? void 0 : keyed.reset();
    this._map.delete(key);
  }
  reset() {
    this._map.forEach((keyed) => keyed.reset());
    this._map.clear();
  }
};
var KeyedResolvOnce = class extends Keyed {
  constructor(kp = {}) {
    super((key) => new ResolveOnce(key), kp);
  }
  /**
   *
   * @returns The values of the resolved keys
   */
  values() {
    return Array.from(this._map.entries()).filter(([_, v]) => v._onceDone).map(([k, v]) => {
      if (v._onceDone) {
        if (v._onceError) {
          return {
            key: k,
            value: Result.Err(v._onceError)
          };
        }
        return {
          key: k,
          value: Result.Ok(v._onceValue)
        };
      }
      throw new Error("KeyedResolvOnce.values impossible");
    });
  }
};
var KeyedResolvSeq = class extends Keyed {
  constructor(kp = {}) {
    super((key) => new ResolveSeq(key), kp);
  }
};

// src/runtime.ts
function isSet(value, ref = globalThis) {
  const [head, ...tail] = value.split(".");
  if (["object", "function"].includes(typeof ref) && ref && ["object", "function"].includes(typeof ref[head]) && ref[head]) {
    if (tail.length <= 1) {
      return true;
    }
    return isSet(tail.join("."), ref[head]);
  }
  return false;
}
function runtimeFn() {
  const gt = globalThis;
  let isReactNative = (
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    isSet("navigator.product") && typeof gt["navigator"] === "object" && gt["navigator"]["product"] === "ReactNative"
  );
  let isNodeIsh = false;
  if (!isSet("Deno")) {
    isNodeIsh = isSet("process.versions.node") && !isReactNative;
  }
  let isDeno = isSet("Deno");
  const isCFWorker = isSet("caches.default") && isSet("WebSocketPair");
  if (isCFWorker) {
    isDeno = false;
    isNodeIsh = false;
    isReactNative = false;
  }
  return {
    isNodeIsh,
    isBrowser: !(isNodeIsh || isDeno || isCFWorker || isReactNative),
    isDeno,
    isReactNative,
    isCFWorker
  };
}

// src/cf/cf-env-actions.ts
var once = new ResolveOnce();
var CFEnvActions = class _CFEnvActions {
  constructor(env) {
    this.injectOnRegister = {};
    this.cfEnv = new Map(Object.entries(env.presetEnv || {}));
  }
  static new(opts) {
    return once.once(() => new _CFEnvActions(opts));
  }
  static inject(o) {
    const env = _CFEnvActions.new({});
    for (const key in o) {
      const value = o[key];
      if (typeof value === "string") {
        if (env.env) {
          env.env.set(key, value);
        } else {
          env.injectOnRegister[key] = value;
        }
      }
    }
  }
  active() {
    return runtimeFn().isCFWorker;
  }
  register(env) {
    this.env = env;
    for (const key in this.injectOnRegister) {
      env.set(key, this.injectOnRegister[key]);
    }
    return env;
  }
  get(key) {
    return this.cfEnv.get(key);
  }
  set(key, value) {
    if (value) {
      this.cfEnv.set(key, value);
    }
  }
  delete(key) {
    this.cfEnv.delete(key);
  }
  keys() {
    return Array.from(this.cfEnv.keys());
  }
};

// src/deno/deno-env-actions.ts
var once2 = new ResolveOnce();
var _deno;
var _DenoEnvActions = class _DenoEnvActions {
  constructor(opts) {
    __privateAdd(this, _deno, globalThis);
    this.opts = opts;
  }
  static new(opts) {
    return once2.once(() => new _DenoEnvActions(opts));
  }
  get _env() {
    return __privateGet(this, _deno).Deno.env;
  }
  register(env) {
    for (const key of env.keys()) {
      this._env.set(key, env.get(key) || "");
    }
    return env;
  }
  active() {
    return runtimeFn().isDeno;
  }
  keys() {
    return Object.keys(this._env.toObject());
  }
  get(key) {
    return this._env.get(key);
  }
  set(key, value) {
    if (value) {
      this._env.set(key, value);
    }
  }
  delete(key) {
    this._env.delete(key);
  }
};
_deno = new WeakMap();
var DenoEnvActions = _DenoEnvActions;

// src/node/node-env-actions.ts
var once3 = new ResolveOnce();
var _node;
var _NodeEnvActions = class _NodeEnvActions {
  constructor(opts) {
    __privateAdd(this, _node, globalThis);
    this._env = this.active() ? __privateGet(this, _node).process.env : {};
    this.opts = opts;
  }
  static new(opts) {
    return once3.once(() => new _NodeEnvActions(opts));
  }
  register(env) {
    for (const key of env.keys()) {
      this._env[key] = env.get(key) || "";
    }
    return env;
  }
  active() {
    return runtimeFn().isNodeIsh;
  }
  keys() {
    return Object.keys(this._env);
  }
  get(key) {
    return this._env[key];
  }
  set(key, value) {
    if (value) {
      this._env[key] = value;
    }
  }
  delete(key) {
    delete this._env[key];
  }
};
_node = new WeakMap();
var NodeEnvActions = _NodeEnvActions;

// src/web/web-env-actions.ts
var once4 = new ResolveOnce();
var BrowserEnvActions = class _BrowserEnvActions {
  constructor(opts) {
    this.env = /* @__PURE__ */ new Map();
    this.opts = opts;
  }
  static new(opts) {
    return once4.once(() => new _BrowserEnvActions(opts));
  }
  get(key) {
    return this.env.get(key);
  }
  set(key, value) {
    if (value) {
      this.env.set(key, value);
    }
  }
  delete(key) {
    this.env.delete(key);
  }
  keys() {
    return Array.from(this.env.keys());
  }
  active() {
    return true;
  }
  register(env) {
    const sym = Symbol.for(this.opts.symbol || "CP_ENV");
    const browser = globalThis;
    browser[sym] = env;
    return env;
  }
};

// src/sys-env.ts
var envActions = [
  { id: "cf", fn: (opts) => CFEnvActions.new(opts) },
  { id: "node", fn: (opts) => NodeEnvActions.new(opts) },
  { id: "deno", fn: (opts) => DenoEnvActions.new(opts) },
  { id: "browser", fn: (opts) => BrowserEnvActions.new(opts) }
];
function registerEnvAction(fn) {
  const id = `id-${Math.random()}`;
  envActions.unshift({ id, fn });
  _envFactories.unget(id);
  return () => {
    const index = envActions.findIndex((i) => i.id === id);
    if (index >= 0) {
      envActions.splice(index, 1);
    }
  };
}
var _envFactories = new KeyedResolvOnce();
function envFactory(opts = {}) {
  const found = envActions.find((fi) => fi.fn(opts).active());
  if (!found) {
    throw new Error("SysContainer:envFactory: no env available");
  }
  return _envFactories.get(found.id).once(() => {
    const action = found.fn(opts);
    const ret = new EnvImpl(action, opts);
    action.register(ret);
    return ret;
  });
}
function isIterable(obj) {
  if (obj == null) {
    return false;
  }
  return typeof obj[Symbol.iterator] === "function";
}
var EnvImpl = class {
  constructor(map, opts = {}) {
    this._onSet = [];
    this._map = map;
    this._updatePresets(opts.presetEnv);
  }
  gets(...kparams) {
    return getParamsResult(kparams, {
      getParam: (k) => this.get(k)
    });
  }
  sets(...keys) {
    keys.forEach((key) => {
      if (Array.isArray(key)) {
        if (key.length === 2) {
          const [k, v] = key;
          if (typeof k === "string" && typeof v === "string") {
            this.set(k, v);
            return;
          }
        }
        for (const item of key) {
          if (Array.isArray(item)) {
            if (item.length === 2) {
              const [k, v] = item;
              if (typeof k === "string" && typeof v === "string") {
                this.set(k, v);
              }
            }
          }
        }
      } else {
        if (isIterable(key)) {
          for (const [k, v] of key) {
            if (typeof k === "string" && typeof v === "string") {
              this.set(k, v);
            }
          }
        } else {
          const rKey = key;
          for (const k in rKey) {
            const v = rKey[k];
            if (typeof k === "string" && typeof v === "string") {
              this.set(k, v);
            }
          }
        }
      }
    });
  }
  _updatePresets(presetEnv) {
    if (!presetEnv) {
      return;
    }
    for (const [key, value] of presetEnv) {
      this._map.set(key, value);
    }
  }
  _applyOnSet(onSet, key, value) {
    onSet.forEach((item) => {
      let keys = [];
      if (key) {
        keys = [key];
      } else {
        keys = this._map.keys();
      }
      keys.filter((k) => {
        if (item.filter.size === 0) {
          return true;
        }
        if (item.filter.has(k)) {
          return true;
        }
        return false;
      }).forEach((k) => {
        let v;
        if (!key && !value) {
          v = this._map.get(k);
        } else if (key && !value) {
          v = void 0;
        } else {
          v = value;
        }
        item.fn(k, v);
      });
    });
  }
  keys() {
    return this._map.keys();
  }
  // filter is not set all sets passed
  onSet(fn, ...filter) {
    const item = { filter: new Set(filter), fn };
    this._onSet.push(item);
    this._applyOnSet([item]);
  }
  get(key) {
    return this._map.get(key);
  }
  set(key, value) {
    if (!value) {
      return;
    }
    this._map.set(key, value);
    this._applyOnSet(this._onSet, key, value);
  }
  delete(key) {
    this._map.delete(key);
    this._applyOnSet(this._onSet, key);
  }
};

export {
  TimeMode,
  RandomMode,
  IDMode,
  String2TimeMode,
  Time,
  TimeUnits,
  SysTime,
  ConstTime,
  StepTime,
  TimeFactory,
  RandomService,
  IdService,
  BaseSysAbstraction,
  WrapperSysAbstraction,
  Future,
  LRUSet,
  LRUMap,
  ResolveSeq,
  ResolveOnce,
  Keyed,
  KeyedResolvOnce,
  KeyedResolvSeq,
  runtimeFn,
  CFEnvActions,
  registerEnvAction,
  envFactory,
  EnvImpl
};
//# sourceMappingURL=chunk-23MCJYE6.js.map