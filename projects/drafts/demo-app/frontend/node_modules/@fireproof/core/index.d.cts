import { Future, Logger, ResolveOnce, URI, Result, ResolveSeq, CoerceURI, CryptoRuntime, CTCryptoKey, EnvFactoryOpts, Env, runtimeFn } from '@adviser/cement';
export { Logger, Result } from '@adviser/cement';
import { EventLink } from '@fireproof/vendor/@web3-storage/pail/clock/api';
import { Operation } from '@fireproof/vendor/@web3-storage/pail/crdt/api';
import { ByteView, ArrayBufferView, Version, Block as Block$1, Link, CID, BlockView, MultihashHasher } from 'multiformats';
import { MemoryBlockstore } from '@fireproof/vendor/@web3-storage/pail/block';
import { BlockFetcher as BlockFetcher$1 } from '@fireproof/vendor/@web3-storage/pail/api';
import { CarReader } from '@fireproof/vendor/@ipld/car/reader';
import { EventBlock } from '@fireproof/vendor/@web3-storage/pail/clock';
import { PathLike, MakeDirectoryOptions, Stats } from 'fs';
import { ProllyNode as ProllyNode$1 } from 'prolly-trees/db-index';
import { SuperThis as SuperThis$1 } from '@fireproof/core';
import { Block as Block$2 } from 'multiformats/block';

interface BlockEncoder<Code extends number, T> {
    name: string;
    code: Code;
    encode(data: T): ByteView<T> | PromiseLike<ByteView<T>>;
}
interface BlockDecoder<Code extends number, T> {
    code: Code;
    decode(bytes: ByteView<T> | ArrayBufferView<T>): T | PromiseLike<T>;
}
interface BlockCodec<Code extends number, T> extends BlockEncoder<Code, T>, BlockDecoder<Code, T> {
}

declare const codecInterface_ArrayBufferView: typeof ArrayBufferView;
type codecInterface_BlockCodec<Code extends number, T> = BlockCodec<Code, T>;
type codecInterface_BlockDecoder<Code extends number, T> = BlockDecoder<Code, T>;
type codecInterface_BlockEncoder<Code extends number, T> = BlockEncoder<Code, T>;
declare const codecInterface_ByteView: typeof ByteView;
declare namespace codecInterface {
  export { codecInterface_ArrayBufferView as ArrayBufferView, type codecInterface_BlockCodec as BlockCodec, type codecInterface_BlockDecoder as BlockDecoder, type codecInterface_BlockEncoder as BlockEncoder, codecInterface_ByteView as ByteView };
}

type QueueFunction<T = void> = () => Promise<T>;
declare class CommitQueue<T = void> {
    readonly queue: QueueFunction<void>[];
    processing: boolean;
    readonly _waitIdleItems: Set<Future<void>>;
    waitIdle(): Promise<void>;
    enqueue(fn: QueueFunction<T>): Promise<T>;
    processNext(): void;
}

declare class KeyBag {
    readonly rt: KeyBagRuntime;
    readonly logger: Logger;
    constructor(rt: KeyBagRuntime);
    readonly _warnOnce: ResolveOnce<void>;
    subtleKey(key: string): Promise<CryptoKey>;
    ensureKeyFromUrl(url: URI, keyFactory: () => string): Promise<Result<URI>>;
    toKeyWithFingerPrint(keyStr: string): Promise<Result<KeyWithFingerPrint>>;
    readonly _seq: ResolveSeq<Result<KeyWithFingerPrint>>;
    setNamedKey(name: string, key: string): Promise<Result<KeyWithFingerPrint>>;
    _setNamedKey(name: string, key: string): Promise<Result<KeyWithFingerPrint>>;
    getNamedExtractableKey(name: string, failIfNotFound?: boolean): Promise<Result<KeyWithFingerExtract>>;
    getNamedKey(name: string, failIfNotFound?: boolean): Promise<Result<KeyWithFingerPrint>>;
}
interface KeyItem {
    readonly name: string;
    readonly key: string;
}
type KeyBagFile = Record<string, KeyItem>;
interface KeyBagOpts {
    readonly url: CoerceURI;
    readonly crypto: CryptoRuntime;
    readonly keyLength: number;
    readonly keyRuntime: KeyBagRuntime;
}
interface KeyBagProvider {
    get(id: string): Promise<KeyItem | undefined>;
    set(id: string, item: KeyItem): Promise<void>;
}
interface KeyBagRuntime {
    readonly url: URI;
    readonly crypto: CryptoRuntime;
    readonly logger: Logger;
    readonly sthis: SuperThis;
    readonly keyLength: number;
    getBag(): Promise<KeyBagProvider>;
    id(): string;
}
type KeyBackProviderFactory = (url: URI, sthis: SuperThis) => Promise<KeyBagProvider>;
interface KeyBagProviderFactoryItem {
    readonly protocol: string;
    readonly override?: boolean;
    readonly factory: KeyBackProviderFactory;
}
declare function registerKeyBagProviderFactory(item: KeyBagProviderFactoryItem): void;
declare function defaultKeyBagUrl(sthis: SuperThis): URI;
declare function getKeyBag(sthis: SuperThis, kbo?: Partial<KeyBagOpts>): Promise<KeyBag>;

type keyBag_KeyBackProviderFactory = KeyBackProviderFactory;
type keyBag_KeyBag = KeyBag;
declare const keyBag_KeyBag: typeof KeyBag;
type keyBag_KeyBagFile = KeyBagFile;
type keyBag_KeyBagOpts = KeyBagOpts;
type keyBag_KeyBagProvider = KeyBagProvider;
type keyBag_KeyBagProviderFactoryItem = KeyBagProviderFactoryItem;
type keyBag_KeyBagRuntime = KeyBagRuntime;
type keyBag_KeyItem = KeyItem;
declare const keyBag_defaultKeyBagUrl: typeof defaultKeyBagUrl;
declare const keyBag_getKeyBag: typeof getKeyBag;
declare const keyBag_registerKeyBagProviderFactory: typeof registerKeyBagProviderFactory;
declare namespace keyBag {
  export { type keyBag_KeyBackProviderFactory as KeyBackProviderFactory, keyBag_KeyBag as KeyBag, type keyBag_KeyBagFile as KeyBagFile, type keyBag_KeyBagOpts as KeyBagOpts, type keyBag_KeyBagProvider as KeyBagProvider, type keyBag_KeyBagProviderFactoryItem as KeyBagProviderFactoryItem, type keyBag_KeyBagRuntime as KeyBagRuntime, type keyBag_KeyItem as KeyItem, keyBag_defaultKeyBagUrl as defaultKeyBagUrl, keyBag_getKeyBag as getKeyBag, keyBag_registerKeyBagProviderFactory as registerKeyBagProviderFactory };
}

declare class TaskManager {
    private readonly eventsWeHandled;
    private queue;
    private isProcessing;
    readonly logger: Logger;
    readonly callback: (dbMeta: DbMeta) => Promise<void>;
    constructor(sthis: SuperThis, callback: (dbMeta: DbMeta) => Promise<void>);
    handleEvent(cid: CarClockLink, parents: string[], dbMeta: DbMeta): Promise<void>;
    private processQueue;
}

declare class Loader implements Loadable {
    readonly name: string;
    readonly ebOpts: BlockstoreRuntime;
    readonly commitQueue: CommitQueue<CarGroup>;
    readonly isCompacting = false;
    readonly carReaders: Map<string, Promise<CarReader>>;
    readonly seenCompacted: Set<string>;
    readonly processedCars: Set<string>;
    readonly sthis: SuperThis;
    readonly taskManager?: TaskManager;
    carLog: CarLog;
    remoteMetaStore?: MetaStore;
    remoteCarStore?: DataStore;
    remoteFileStore?: DataStore;
    private getBlockCache;
    private seenMeta;
    private writeLimit;
    keyBag(): Promise<KeyBag>;
    carStore(): Promise<DataStore>;
    fileStore(): Promise<DataStore>;
    WALStore(): Promise<WALStore>;
    metaStore(): Promise<MetaStore>;
    readonly onceReady: ResolveOnce<void>;
    ready(): Promise<void>;
    close(): Promise<void>;
    destroy(): Promise<void>;
    readonly logger: Logger;
    constructor(name: string, ebOpts: BlockstoreOpts, sthis: SuperThis);
    handleDbMetasFromStore(metas: DbMeta[]): Promise<void>;
    mergeDbMetaIntoClock(meta: DbMeta): Promise<void>;
    loadCarHeaderFromMeta<T>({ cars: cids }: DbMeta): Promise<CarHeader<T>>;
    commitFiles(t: CarTransaction, done: TransactionMeta): Promise<CarGroup>;
    loadFileCar(cid: AnyLink): Promise<CarReader>;
    commit<T = TransactionMeta>(t: CarTransaction, done: T, opts?: CommitOpts): Promise<CarGroup>;
    updateCarLog<T>(cids: CarGroup, fp: CarHeader<T>, compact: boolean): Promise<void>;
    cacheTransaction(t: CarTransaction): Promise<void>;
    cacheCarReader(carCidStr: string, reader: CarReader): Promise<void>;
    removeCidsForCompact(cid: AnyLink): Promise<void>;
    entries(cache?: boolean): AsyncIterableIterator<AnyBlock>;
    getBlock(cid: AnyLink): Promise<AnyBlock | Falsy>;
    loadCar(cid: AnyLink): Promise<CarReader>;
    makeDecoderAndCarReader(cid: AnyLink, local: DataStore, remote?: DataStore): Promise<CarReader>;
    protected storesLoadCar(cid: AnyLink, local: DataStore, remote?: DataStore): Promise<CarReader>;
    protected getMoreReaders(cids: AnyLink[]): Promise<void>;
}

type BlockFetcher = BlockFetcher$1;
interface CarTransactionOpts {
    readonly add: boolean;
    readonly noLoader: boolean;
}
declare class CarTransaction extends MemoryBlockstore implements CarMakeable {
    readonly parent: BaseBlockstore;
    constructor(parent: BaseBlockstore, opts?: CarTransactionOpts);
    get<T, C extends number, A extends number, V extends Version>(cid: AnyLink): Promise<Block$1<T, C, A, V> | undefined>;
    superGet(cid: AnyLink): Promise<AnyBlock | undefined>;
}
declare class BaseBlockstore implements BlockFetcher {
    readonly transactions: Set<CarTransaction>;
    readonly ebOpts: BlockstoreRuntime;
    readonly sthis: SuperThis;
    readonly loader?: Loader;
    readonly name?: string;
    ready(): Promise<void>;
    close(): Promise<void>;
    destroy(): Promise<void>;
    compact(): Promise<void>;
    readonly logger: Logger;
    constructor(ebOpts?: BlockstoreOpts);
    get<T, C extends number, A extends number, V extends Version>(cid: AnyAnyLink): Promise<Block$1<T, C, A, V> | undefined>;
    put(cid: AnyAnyLink, block: Uint8Array): Promise<void>;
    lastTxMeta?: unknown;
    transaction<M extends TransactionMeta>(fn: (t: CarTransaction) => Promise<M>, _opts?: CarTransactionOpts): Promise<TransactionWrapper<M>>;
    openTransaction(opts?: CarTransactionOpts): CarTransaction;
    commitTransaction<M extends TransactionMeta>(t: CarTransaction, done: M, opts: CarTransactionOpts): Promise<TransactionWrapper<M>>;
    entries(): AsyncIterableIterator<AnyBlock>;
}
declare class EncryptedBlockstore extends BaseBlockstore {
    readonly name: string;
    readonly loader: Loader;
    ready(): Promise<void>;
    close(): Promise<void>;
    destroy(): Promise<void>;
    compacting: boolean;
    readonly logger: Logger;
    constructor(sthis: SuperThis, ebOpts: BlockstoreOpts);
    get<T, C extends number, A extends number, V extends Version>(cid: AnyAnyLink): Promise<Block$1<T, C, A, V> | undefined>;
    transaction<M extends TransactionMeta>(fn: (t: CarTransaction) => Promise<M>, opts?: {
        noLoader: boolean;
    }): Promise<TransactionWrapper<M>>;
    getFile(car: AnyLink, cid: AnyLink): Promise<Uint8Array>;
    compact(): Promise<void>;
    defaultCompact(blocks: CompactionFetcher, logger: Logger): Promise<TransactionMeta>;
    entries(): AsyncIterableIterator<AnyBlock>;
}
declare class CompactionFetcher implements BlockFetcher {
    readonly blockstore: EncryptedBlockstore;
    readonly loggedBlocks: CarTransaction;
    constructor(blocks: EncryptedBlockstore);
    get<T, C extends number, A extends number, V extends Version>(cid: AnyLink): Promise<Block$1<T, C, A, V> | undefined>;
}

declare function onSuperThis(fn: (sthis: SuperThis) => void): () => void;
declare function ensureSuperThis(osthis?: Partial<SuperThisOpts>): SuperThis;
declare function ensureSuperLog(sthis: SuperThis, componentName: string, ctx?: Record<string, unknown>): SuperThis;
declare function ensureLogger(sthis: SuperThis, componentName: string, ctx?: Record<string, unknown>): Logger;
type Joiner = (...toJoin: string[]) => string;
interface Store {
    readonly store: StoreType;
    readonly name: string;
}
declare function getStore(url: URI, sthis: SuperThis, joiner: Joiner): Store;
declare function getKey(url: URI, logger: Logger): string;
declare function getName(sthis: SuperThis, url: URI): string;
declare function exceptionWrapper<T, E extends Error>(fn: () => Promise<Result<T, E>>): Promise<Result<T, E>>;
declare class NotFoundError extends Error {
    readonly code = "ENOENT";
}
declare function isNotFoundError(e: Error | Result<unknown> | unknown): e is NotFoundError;
declare function dataDir(sthis: SuperThis, name?: string, base?: CoerceURI): URI;
declare function UInt8ArrayEqual(a: Uint8Array, b: Uint8Array): boolean;

type AnyLink = Link<unknown, number, number, Version>;
type CarGroup = AnyLink[];
type CarLog = CarGroup[];
type AnyAnyLink = Link<unknown, number, number, Version>;
type AnyLinkFn = (cid: AnyLink) => Promise<AnyBlock | undefined>;
interface AnyBlock {
    readonly cid: Link<unknown, number, number, Version>;
    readonly bytes: Uint8Array;
}
interface CIDBlock {
    readonly cid: CID<unknown, number, number, Version>;
    readonly bytes: Uint8Array;
}
declare function toCIDBlock(block: AnyBlock): CIDBlock;
interface AnyAnyBlock {
    readonly cid: AnyAnyLink;
    readonly bytes: Uint8Array;
}
interface IvKeyIdData {
    readonly iv: Uint8Array;
    readonly keyId: Uint8Array;
    readonly data: Uint8Array;
}
interface IvAndBytes {
    readonly bytes: Uint8Array;
    readonly iv: Uint8Array;
}
interface BytesWithIv {
    readonly bytes: Uint8Array;
    readonly iv?: Uint8Array;
}
interface AnyDecodedBlock {
    readonly cid: AnyLink;
    readonly bytes: Uint8Array;
    readonly value: Uint8Array;
}
interface CarMakeable {
    entries(): Iterable<AnyBlock>;
    get(cid: AnyLink): Promise<AnyBlock | undefined>;
}
interface CarHeader<T> {
    readonly cars: CarLog;
    readonly compact: CarLog;
    readonly meta: T;
}
interface TransactionWrapper<M extends TransactionMeta> {
    meta: M;
    cars?: CarGroup;
    t: CarTransaction;
}
type TransactionMeta = unknown;
interface EncryptedBlock {
    readonly value: IvAndBytes;
}
interface KeyMaterial {
    readonly key: Uint8Array;
    readonly keyStr: string;
}
interface KeyWithFingerPrint {
    readonly fingerPrint: string;
    readonly key: CTCryptoKey;
}
interface KeyWithFingerExtract extends KeyWithFingerPrint {
    extract(): Promise<KeyMaterial>;
}
interface CodecOpts {
    readonly ivCalc: "random" | "hash";
    readonly noIVVerify: boolean;
}
interface KeyedCrypto {
    readonly ivLength: number;
    readonly logger: Logger;
    readonly crypto: CryptoRuntime;
    readonly url: URI;
    fingerPrint(): Promise<string>;
    algo(iv?: Uint8Array): {
        name: string;
        iv: Uint8Array;
        tagLength: number;
    };
    codec(iv?: Uint8Array, codecOpts?: Partial<CodecOpts>): BlockCodec<number, Uint8Array>;
    _decrypt(data: IvAndBytes): Promise<Uint8Array>;
    _encrypt(data: BytesWithIv): Promise<Uint8Array>;
}
interface BlobLike {
    stream: () => ReadableStream;
}
interface StoreFactory {
    makeMetaStore?: (loader: Loadable) => Promise<MetaStore>;
    makeDataStore?: (loader: Loadable) => Promise<DataStore>;
    makeWALStore?: (loader: Loadable) => Promise<WALStore>;
    encodeFile?: (blob: BlobLike) => Promise<{
        cid: AnyLink;
        blocks: AnyBlock[];
    }>;
    decodeFile?: (blocks: unknown, cid: AnyLink, meta: DocFileMeta) => Promise<File>;
}
interface StoreOpts extends StoreFactory {
    readonly isIndex?: string;
    readonly stores?: {
        readonly base?: CoerceURI;
        readonly meta?: CoerceURI;
        readonly data?: CoerceURI;
        readonly index?: CoerceURI;
        readonly wal?: CoerceURI;
    };
}
interface StoreRuntime {
    makeMetaStore(loader: Loadable): Promise<MetaStore>;
    makeDataStore(loader: Loadable): Promise<DataStore>;
    makeWALStore(loader: Loadable): Promise<WALStore>;
    encodeFile(blob: BlobLike): Promise<{
        cid: AnyLink;
        blocks: AnyBlock[];
    }>;
    decodeFile(blocks: unknown, cid: AnyLink, meta: DocFileMeta): Promise<File>;
}
interface CommitOpts {
    readonly noLoader?: boolean;
    readonly compact?: boolean;
}
interface DbMeta {
    readonly cars: CarGroup;
    key?: string;
}
type LoadHandler = (dbMetas: DbMeta[]) => Promise<void>;
interface Connection {
    readonly loader?: Loadable;
    readonly loaded: Promise<void>;
    dashboardUrl?: URI;
    connectMeta_X({ loader }: {
        loader?: Loadable;
    }): void;
    connectStorage_X({ loader }: {
        loader?: Loadable;
    }): void;
}
interface BaseStore {
    readonly storeType: StoreType;
    url(): URI;
    readonly name: string;
    onStarted(fn: () => void): void;
    onClosed(fn: () => void): void;
    keyedCrypto(): Promise<KeyedCrypto>;
    close(): Promise<Result<void>>;
    destroy(): Promise<Result<void>>;
    readonly ready?: () => Promise<void>;
    start(): Promise<Result<URI>>;
}
interface MetaStore extends BaseStore {
    readonly storeType: "meta";
    load(branch?: string): Promise<DbMeta[] | Falsy>;
    save(meta: DbMeta, branch?: string): Promise<Result<void>>;
    handleByteHeads(byteHeads: Uint8Array, branch?: string): Promise<{
        eventCid: CarClockLink;
        dbMeta: DbMeta;
    }[]>;
}
interface DataSaveOpts {
    readonly public: boolean;
}
interface DataStore extends BaseStore {
    readonly storeType: "data";
    load(cid: AnyLink): Promise<AnyBlock>;
    save(car: AnyBlock, opts?: DataSaveOpts): Promise<void>;
    remove(cid: AnyLink): Promise<Result<void>>;
}
interface WALState {
    operations: DbMeta[];
    noLoaderOps: DbMeta[];
    fileOperations: {
        readonly cid: AnyLink;
        readonly public: boolean;
    }[];
}
interface WALStore extends BaseStore {
    readonly storeType: "wal";
    ready(): Promise<void>;
    readonly processing?: Promise<void> | undefined;
    readonly processQueue: CommitQueue<void>;
    process(): Promise<void>;
    enqueue(dbMeta: DbMeta, opts: CommitOpts): Promise<void>;
    enqueueFile(fileCid: AnyLink): Promise<void>;
    load(): Promise<WALState | Falsy>;
    save(state: WALState): Promise<void>;
}
type CompactFetcher = BlockFetcher & {
    readonly loggedBlocks: CarTransaction;
};
type CompactFn = (blocks: CompactFetcher) => Promise<TransactionMeta>;
type BlockstoreOpts = Partial<{
    readonly logger: Logger;
    readonly applyMeta: (meta: TransactionMeta, snap?: boolean) => Promise<void>;
    readonly compact: CompactFn;
    readonly autoCompact: number;
    readonly crypto: CryptoRuntime;
    readonly store: StoreOpts;
    readonly keyBag: KeyBagOpts;
    readonly public: boolean;
    readonly meta: DbMeta;
    readonly name: string;
    readonly threshold: number;
}>;
interface BlockstoreRuntime {
    readonly logger: Logger;
    readonly applyMeta: (meta: TransactionMeta, snap?: boolean) => Promise<void>;
    readonly compact: CompactFn;
    readonly autoCompact: number;
    readonly crypto: CryptoRuntime;
    readonly store: StoreOpts;
    readonly storeRuntime: StoreRuntime;
    readonly keyBag: Partial<KeyBagOpts>;
    readonly meta?: DbMeta;
    readonly name?: string;
    readonly threshold: number;
}
interface Loadable {
    readonly name: string;
    readonly sthis: SuperThis;
    readonly ebOpts: BlockstoreRuntime;
    remoteCarStore?: DataStore;
    carStore(): Promise<DataStore>;
    carLog: CarLog;
    remoteMetaStore?: MetaStore;
    remoteFileStore?: DataStore;
    taskManager?: TaskManager;
    ready(): Promise<void>;
    close(): Promise<void>;
    fileStore(): Promise<DataStore>;
    WALStore(): Promise<WALStore>;
    handleDbMetasFromStore(metas: DbMeta[]): Promise<void>;
}
type DbMetaEventBlock = EventBlock<{
    dbMeta: Uint8Array;
}>;
type CarClockLink = Link<DbMetaEventBlock, number, number, Version>;
type CarClockHead = CarClockLink[];

interface GatewayOpts {
    readonly gateway: Gateway;
}
type GetResult = Result<Uint8Array, NotFoundError | Error>;
type VoidResult = Result<void>;
interface TestGateway {
    get(url: URI, key: string): Promise<Uint8Array>;
}
type UnsubscribeResult = Result<() => void>;
interface Gateway {
    buildUrl(baseUrl: URI, key: string): Promise<Result<URI>>;
    start(baseUrl: URI): Promise<Result<URI>>;
    close(baseUrl: URI): Promise<VoidResult>;
    destroy(baseUrl: URI): Promise<VoidResult>;
    put(url: URI, body: Uint8Array): Promise<VoidResult>;
    get(url: URI): Promise<GetResult>;
    delete(url: URI): Promise<VoidResult>;
    subscribe?(url: URI, callback: (meta: Uint8Array) => void): Promise<UnsubscribeResult>;
}

interface GatewayFactoryItem {
    readonly protocol: string;
    readonly overrideBaseURL?: string;
    readonly overrideRegistration?: boolean;
    readonly gateway: (sthis: SuperThis) => Promise<Gateway>;
    readonly test: (sthis: SuperThis) => Promise<TestGateway>;
}
interface GatewayReady {
    readonly gateway: Gateway;
    readonly test: TestGateway;
}
declare function getGatewayFromURL(url: URI, sthis: SuperThis): Promise<GatewayReady | undefined>;
declare function registerStoreProtocol(item: GatewayFactoryItem): () => void;
declare function testStoreFactory(url: URI, sthis: SuperThis): Promise<TestGateway>;
declare function ensureStart<T>(store: T & {
    start: () => Promise<Result<URI>>;
}, logger: Logger): Promise<T>;
declare function toStoreRuntime(opts: StoreOpts, sthis: SuperThis): StoreRuntime;

declare class FragmentGateway implements Gateway {
    readonly sthis: SuperThis;
    readonly logger: Logger;
    readonly fidLength = 4;
    readonly innerGW: Gateway;
    headerSize: number;
    constructor(sthis: SuperThis, innerGW: Gateway);
    slicer(url: URI, body: Uint8Array): Promise<VoidResult>[];
    buildUrl(baseUrl: URI, key: string): Promise<Result<URI>>;
    destroy(iurl: URI): Promise<Result<void>>;
    start(url: URI): Promise<Result<URI>>;
    close(url: URI): Promise<VoidResult>;
    put(url: URI, body: Uint8Array): Promise<VoidResult>;
    get(url: URI): Promise<GetResult>;
    subscribe(url: URI, callback: (msg: Uint8Array) => void): Promise<UnsubscribeResult>;
    delete(url: URI): Promise<VoidResult>;
}

interface Connectable {
    readonly blockstore: {
        readonly loader?: Loader;
        readonly ebOpts: BlockstoreRuntime;
    };
    readonly name?: string;
}
declare abstract class ConnectionBase implements Connection {
    loader?: Loadable;
    taskManager?: TaskManager;
    loaded: Promise<void>;
    readonly url: URI;
    readonly logger: Logger;
    constructor(url: URI, logger: Logger);
    refresh(): Promise<void>;
    connect_X({ loader }: {
        readonly loader?: Loadable;
    }): Promise<void>;
    connectMeta_X({ loader }: {
        loader?: Loadable;
    }): Promise<void>;
    abstract onConnect(): Promise<void>;
    connectStorage_X({ loader }: {
        loader?: Loadable;
    }): Promise<void>;
}

declare function parseCarFile<T>(reader: CarReader, logger: Logger): Promise<CarHeader<T>>;

declare function setCryptoKeyFromGatewayMetaPayload(uri: URI, sthis: SuperThis, data: Uint8Array): Promise<Result<DbMeta | undefined>>;
declare function addCryptoKeyToGatewayMetaPayload(uri: URI, sthis: SuperThis, body: Uint8Array): Promise<Result<Uint8Array>>;

type index$3_AnyAnyBlock = AnyAnyBlock;
type index$3_AnyAnyLink = AnyAnyLink;
type index$3_AnyBlock = AnyBlock;
type index$3_AnyDecodedBlock = AnyDecodedBlock;
type index$3_AnyLink = AnyLink;
type index$3_AnyLinkFn = AnyLinkFn;
type index$3_BaseBlockstore = BaseBlockstore;
declare const index$3_BaseBlockstore: typeof BaseBlockstore;
type index$3_BaseStore = BaseStore;
type index$3_BlobLike = BlobLike;
type index$3_BlockFetcher = BlockFetcher;
type index$3_BlockstoreOpts = BlockstoreOpts;
type index$3_BlockstoreRuntime = BlockstoreRuntime;
type index$3_BytesWithIv = BytesWithIv;
type index$3_CIDBlock = CIDBlock;
type index$3_CarClockHead = CarClockHead;
type index$3_CarClockLink = CarClockLink;
type index$3_CarGroup = CarGroup;
type index$3_CarHeader<T> = CarHeader<T>;
type index$3_CarLog = CarLog;
type index$3_CarMakeable = CarMakeable;
type index$3_CarTransaction = CarTransaction;
declare const index$3_CarTransaction: typeof CarTransaction;
type index$3_CodecOpts = CodecOpts;
type index$3_CommitOpts = CommitOpts;
type index$3_CompactFetcher = CompactFetcher;
type index$3_CompactFn = CompactFn;
type index$3_CompactionFetcher = CompactionFetcher;
declare const index$3_CompactionFetcher: typeof CompactionFetcher;
type index$3_Connectable = Connectable;
type index$3_Connection = Connection;
type index$3_ConnectionBase = ConnectionBase;
declare const index$3_ConnectionBase: typeof ConnectionBase;
type index$3_DataSaveOpts = DataSaveOpts;
type index$3_DataStore = DataStore;
type index$3_DbMeta = DbMeta;
type index$3_DbMetaEventBlock = DbMetaEventBlock;
type index$3_EncryptedBlock = EncryptedBlock;
type index$3_EncryptedBlockstore = EncryptedBlockstore;
declare const index$3_EncryptedBlockstore: typeof EncryptedBlockstore;
type index$3_FragmentGateway = FragmentGateway;
declare const index$3_FragmentGateway: typeof FragmentGateway;
type index$3_Gateway = Gateway;
type index$3_GatewayFactoryItem = GatewayFactoryItem;
type index$3_GatewayOpts = GatewayOpts;
type index$3_GetResult = GetResult;
type index$3_IvAndBytes = IvAndBytes;
type index$3_IvKeyIdData = IvKeyIdData;
type index$3_KeyMaterial = KeyMaterial;
type index$3_KeyWithFingerExtract = KeyWithFingerExtract;
type index$3_KeyWithFingerPrint = KeyWithFingerPrint;
type index$3_KeyedCrypto = KeyedCrypto;
type index$3_LoadHandler = LoadHandler;
type index$3_Loadable = Loadable;
type index$3_Loader = Loader;
declare const index$3_Loader: typeof Loader;
type index$3_MetaStore = MetaStore;
type index$3_StoreFactory = StoreFactory;
type index$3_StoreOpts = StoreOpts;
type index$3_StoreRuntime = StoreRuntime;
type index$3_TestGateway = TestGateway;
type index$3_TransactionMeta = TransactionMeta;
type index$3_TransactionWrapper<M extends TransactionMeta> = TransactionWrapper<M>;
type index$3_UnsubscribeResult = UnsubscribeResult;
type index$3_VoidResult = VoidResult;
type index$3_WALState = WALState;
type index$3_WALStore = WALStore;
declare const index$3_addCryptoKeyToGatewayMetaPayload: typeof addCryptoKeyToGatewayMetaPayload;
declare const index$3_ensureStart: typeof ensureStart;
declare const index$3_getGatewayFromURL: typeof getGatewayFromURL;
declare const index$3_parseCarFile: typeof parseCarFile;
declare const index$3_registerStoreProtocol: typeof registerStoreProtocol;
declare const index$3_setCryptoKeyFromGatewayMetaPayload: typeof setCryptoKeyFromGatewayMetaPayload;
declare const index$3_testStoreFactory: typeof testStoreFactory;
declare const index$3_toCIDBlock: typeof toCIDBlock;
declare const index$3_toStoreRuntime: typeof toStoreRuntime;
declare namespace index$3 {
  export { type index$3_AnyAnyBlock as AnyAnyBlock, type index$3_AnyAnyLink as AnyAnyLink, type index$3_AnyBlock as AnyBlock, type index$3_AnyDecodedBlock as AnyDecodedBlock, type index$3_AnyLink as AnyLink, type index$3_AnyLinkFn as AnyLinkFn, index$3_BaseBlockstore as BaseBlockstore, type index$3_BaseStore as BaseStore, type index$3_BlobLike as BlobLike, type index$3_BlockFetcher as BlockFetcher, type index$3_BlockstoreOpts as BlockstoreOpts, type index$3_BlockstoreRuntime as BlockstoreRuntime, type index$3_BytesWithIv as BytesWithIv, type index$3_CIDBlock as CIDBlock, type index$3_CarClockHead as CarClockHead, type index$3_CarClockLink as CarClockLink, type index$3_CarGroup as CarGroup, type index$3_CarHeader as CarHeader, type index$3_CarLog as CarLog, type index$3_CarMakeable as CarMakeable, index$3_CarTransaction as CarTransaction, type index$3_CodecOpts as CodecOpts, type index$3_CommitOpts as CommitOpts, type index$3_CompactFetcher as CompactFetcher, type index$3_CompactFn as CompactFn, index$3_CompactionFetcher as CompactionFetcher, type index$3_Connectable as Connectable, type index$3_Connection as Connection, index$3_ConnectionBase as ConnectionBase, type index$3_DataSaveOpts as DataSaveOpts, type index$3_DataStore as DataStore, type index$3_DbMeta as DbMeta, type index$3_DbMetaEventBlock as DbMetaEventBlock, type index$3_EncryptedBlock as EncryptedBlock, index$3_EncryptedBlockstore as EncryptedBlockstore, index$3_FragmentGateway as FragmentGateway, type index$3_Gateway as Gateway, type index$3_GatewayFactoryItem as GatewayFactoryItem, type index$3_GatewayOpts as GatewayOpts, type index$3_GetResult as GetResult, type index$3_IvAndBytes as IvAndBytes, type index$3_IvKeyIdData as IvKeyIdData, type index$3_KeyMaterial as KeyMaterial, type index$3_KeyWithFingerExtract as KeyWithFingerExtract, type index$3_KeyWithFingerPrint as KeyWithFingerPrint, type index$3_KeyedCrypto as KeyedCrypto, type index$3_LoadHandler as LoadHandler, type index$3_Loadable as Loadable, index$3_Loader as Loader, type index$3_MetaStore as MetaStore, type index$3_StoreFactory as StoreFactory, type index$3_StoreOpts as StoreOpts, type index$3_StoreRuntime as StoreRuntime, type index$3_TestGateway as TestGateway, type index$3_TransactionMeta as TransactionMeta, type index$3_TransactionWrapper as TransactionWrapper, type index$3_UnsubscribeResult as UnsubscribeResult, type index$3_VoidResult as VoidResult, type index$3_WALState as WALState, type index$3_WALStore as WALStore, index$3_addCryptoKeyToGatewayMetaPayload as addCryptoKeyToGatewayMetaPayload, index$3_ensureStart as ensureStart, index$3_getGatewayFromURL as getGatewayFromURL, index$3_parseCarFile as parseCarFile, index$3_registerStoreProtocol as registerStoreProtocol, index$3_setCryptoKeyFromGatewayMetaPayload as setCryptoKeyFromGatewayMetaPayload, index$3_testStoreFactory as testStoreFactory, index$3_toCIDBlock as toCIDBlock, index$3_toStoreRuntime as toStoreRuntime };
}

type Falsy = false | null | undefined;
declare function isFalsy(value: unknown): value is Falsy;
declare function throwFalsy<T>(value: T | Falsy): T;
declare function falsyToUndef<T>(value: T | Falsy): T | undefined;
type StoreType = "data" | "wal" | "meta";
interface SysFileSystem {
    start(): Promise<SysFileSystem>;
    mkdir(path: PathLike, options?: {
        recursive: boolean;
    }): Promise<string | undefined>;
    readdir(path: PathLike, options?: unknown): Promise<string[]>;
    rm(path: PathLike, options?: MakeDirectoryOptions & {
        recursive: boolean;
    }): Promise<void>;
    copyFile(source: PathLike, destination: PathLike): Promise<void>;
    readfile(path: PathLike, options?: {
        encoding: BufferEncoding;
        flag?: string;
    }): Promise<Uint8Array>;
    stat(path: PathLike): Promise<Stats>;
    unlink(path: PathLike): Promise<void>;
    writefile(path: PathLike, data: Uint8Array | string): Promise<void>;
}
interface PathOps {
    join(...args: string[]): string;
    dirname(path: string): string;
}
interface TextEndeCoder {
    encode(input: string): Uint8Array;
    decode(input: Uint8Array): string;
}
interface SuperThisOpts {
    readonly logger: Logger;
    readonly pathOps: PathOps;
    readonly crypto: CryptoRuntime;
    readonly env: EnvFactoryOpts;
    readonly txt: TextEndeCoder;
    readonly ctx: Record<string, unknown>;
}
interface SuperThis {
    readonly logger: Logger;
    readonly loggerCollector?: Logger;
    readonly env: Env;
    readonly pathOps: PathOps;
    readonly ctx: Record<string, unknown>;
    readonly txt: TextEndeCoder;
    nextId(bytes?: number): {
        str: string;
        bin: Uint8Array;
    };
    timeOrderedNextId(time?: number): {
        str: string;
    };
    start(): Promise<void>;
    clone(override: Partial<SuperThisOpts>): SuperThis;
}
interface ConfigOpts extends Partial<SuperThisOpts> {
    readonly public?: boolean;
    readonly meta?: DbMeta;
    readonly persistIndexes?: boolean;
    readonly autoCompact?: number;
    readonly store?: StoreOpts;
    readonly threshold?: number;
}
type ClockLink = EventLink<Operation>;
type ClockHead = ClockLink[];
type DocFragment = Uint8Array | string | number | boolean | null | AnyLink | DocFragment[] | object;
type DocLiteral = string | number | boolean | Uint8Array | unknown;
type DocObject = NonNullable<unknown>;
type DocTypes = DocObject;
type DocRecord<T extends DocObject> = T;
type UnknownDoc = DocRecord<never>;
type DocFiles = Record<string, DocFileMeta | File>;
interface DocBase {
    readonly _id: string;
    readonly _files?: DocFiles;
    readonly _publicFiles?: DocFiles;
    readonly _deleted?: boolean;
}
type DocWithId<T extends DocTypes> = DocBase & T;
type DocSet<T extends DocTypes> = Partial<DocBase> & T;
interface DocFileMeta {
    readonly type: string;
    readonly size: number;
    readonly cid: AnyLink;
    readonly car?: AnyLink;
    url?: string;
    file?: () => Promise<File>;
}
interface DocUpdate<T extends DocTypes> {
    readonly id: string;
    readonly value?: DocSet<T>;
    readonly del?: boolean;
    readonly clock?: ClockLink;
}
interface DocValue<T extends DocTypes> {
    readonly doc: DocWithId<T>;
    readonly del: boolean;
    readonly cid: AnyLink;
}
type KeyLiteral = string | number | boolean;
type IndexKeyType = KeyLiteral | KeyLiteral[];
type IndexKey<K extends IndexKeyType> = [K, string];
interface IndexUpdate<K extends IndexKeyType> {
    readonly key: IndexKey<K>;
    readonly value?: DocFragment;
    readonly del?: boolean;
}
interface IndexUpdateString {
    readonly key: string;
    readonly value?: DocFragment;
    readonly del?: boolean;
}
interface IndexRow<K extends IndexKeyType, T extends DocObject, R extends DocFragment> {
    readonly id: string;
    readonly key: K;
    readonly value: R;
    readonly doc?: DocWithId<T>;
}
interface IndexRows<K extends IndexKeyType, T extends DocObject, R extends DocFragment = T> {
    readonly rows: IndexRow<K, T, R>[];
}
interface CRDTMeta {
    readonly head: ClockHead;
}
interface IndexTransactionMeta {
    readonly indexes: Record<string, IdxMeta>;
}
interface FileTransactionMeta {
    readonly files?: AnyLink[];
}
type MetaType = CRDTMeta | IndexTransactionMeta | FileTransactionMeta;
interface IdxMeta {
    readonly byId: AnyLink;
    readonly byKey: AnyLink;
    readonly map: string;
    readonly name: string;
    readonly head: ClockHead;
}
interface IdxMetaMap {
    readonly indexes?: Map<string, IdxMeta>;
}
interface QueryOpts<K extends IndexKeyType> {
    readonly descending?: boolean;
    readonly limit?: number;
    includeDocs?: boolean;
    readonly range?: [IndexKeyType, IndexKeyType];
    readonly key?: DocFragment;
    readonly keys?: DocFragment[];
    prefix?: IndexKeyType;
}
interface AllDocsQueryOpts extends QueryOpts<string> {
    readonly key?: string;
    readonly keys?: string[];
    prefix?: string;
}
interface AllDocsResponse<T extends DocTypes> {
    readonly rows: {
        readonly key: string;
        readonly value: DocWithId<T>;
    }[];
    readonly clock: ClockHead;
    readonly name?: string;
}
type EmitFn = (k: IndexKeyType, v?: DocFragment) => void;
type MapFn<T extends DocTypes> = (doc: DocWithId<T>, emit: EmitFn) => DocFragment | unknown;
interface ChangesOptions {
    readonly dirty?: boolean;
    readonly limit?: number;
}
interface ChangesResponseRow<T extends DocTypes> {
    readonly key: string;
    readonly value: DocWithId<T>;
    readonly clock?: ClockLink;
}
interface ChangesResponse<T extends DocTypes> {
    readonly clock: ClockHead;
    readonly rows: ChangesResponseRow<T>[];
    readonly name?: string;
}
interface DocResponse {
    readonly id: string;
    readonly clock: ClockHead;
    readonly name?: string;
}
type UpdateListenerFn<T extends DocTypes> = (docs: DocWithId<T>[]) => Promise<void> | void;
type NoUpdateListenerFn = () => Promise<void> | void;
type ListenerFn<T extends DocTypes> = UpdateListenerFn<T> | NoUpdateListenerFn;
interface CRDTEntry {
    readonly data: string;
    readonly parents: string[];
    readonly cid: string;
}

interface WriteQueue<T extends DocTypes> {
    push(task: DocUpdate<T>): Promise<MetaType>;
}

declare class IndexTree<K extends IndexKeyType, R extends DocFragment> {
    cid?: AnyLink;
    root?: ProllyNode<K, R>;
}
interface ProllyIndexRow<K extends IndexKeyType, T extends DocFragment> {
    readonly id: string;
    readonly key: IndexKey<K>;
    readonly value: T;
}
interface ProllyNode<K extends IndexKeyType, T extends DocFragment> extends ProllyNode$1 {
    getAllEntries(): PromiseLike<{
        [x: string]: unknown;
        result: ProllyIndexRow<K, T>[];
    }>;
    getMany<KI extends IndexKeyType>(removeIds: KI[]): Promise<{
        result: IndexKey<K>[];
    }>;
    range(a: string, b: string): Promise<{
        result: ProllyIndexRow<K, T>[];
    }>;
    get(key: string): Promise<{
        result: ProllyIndexRow<K, T>[];
    }>;
    bulk(bulk: (IndexUpdate<K> | IndexUpdateString)[]): PromiseLike<{
        readonly root?: ProllyNode<K, T>;
        readonly blocks: Block$1[];
    }>;
    readonly address: Promise<Link>;
    readonly distance: number;
    compare: (a: unknown, b: unknown) => number;
    readonly cache: unknown;
    readonly block: Promise<Block$1>;
}

declare function index$2<K extends IndexKeyType = string, T extends DocTypes = NonNullable<unknown>, R extends DocFragment = T>(sthis: SuperThis, { _crdt }: {
    _crdt: CRDT<T> | CRDT<NonNullable<unknown>>;
}, name: string, mapFn?: MapFn<T>, meta?: IdxMeta): Index<K, T, R>;
declare class Index<K extends IndexKeyType, T extends DocTypes, R extends DocFragment = T> {
    readonly blockstore: BaseBlockstore;
    readonly crdt: CRDT<T>;
    name: string;
    mapFn?: MapFn<T>;
    mapFnString: string;
    byKey: IndexTree<K, R>;
    byId: IndexTree<K, R>;
    indexHead?: ClockHead;
    includeDocsDefault: boolean;
    initError?: Error;
    ready(): Promise<void>;
    close(): Promise<void>;
    destroy(): Promise<void>;
    readonly logger: Logger;
    constructor(sthis: SuperThis, crdt: CRDT<T> | CRDT<NonNullable<unknown>>, name: string, mapFn?: MapFn<T>, meta?: IdxMeta);
    applyMapFn(name: string, mapFn?: MapFn<T>, meta?: IdxMeta): void;
    query(opts?: QueryOpts<K>): Promise<IndexRows<K, T, R>>;
    _resetIndex(): void;
    _hydrateIndex(): Promise<void>;
    _updateIndex(): Promise<IndexTransactionMeta>;
}

interface ApplyHeadTask<T extends DocTypes> {
    readonly newHead: ClockHead;
    readonly prevHead: ClockHead;
    readonly updates?: DocUpdate<T>[];
}
interface ApplyHeadQueue<T extends DocTypes> {
    push(task: ApplyHeadTask<T>): AsyncGenerator<{
        readonly updates: DocUpdate<T>[];
        readonly all: boolean;
    }, void, unknown>;
    size(): number;
}

declare class CRDTClock<T extends DocTypes> {
    head: ClockHead;
    readonly zoomers: Set<() => void>;
    readonly watchers: Set<(updates: DocUpdate<T>[]) => void>;
    readonly emptyWatchers: Set<() => void>;
    readonly blockstore: BaseBlockstore;
    readonly applyHeadQueue: ApplyHeadQueue<T>;
    transaction?: CarTransaction;
    readonly _ready: ResolveOnce<void>;
    ready(): Promise<void>;
    close(): Promise<void>;
    readonly logger: Logger;
    constructor(blockstore: BaseBlockstore);
    setHead(head: ClockHead): void;
    applyHead(newHead: ClockHead, prevHead: ClockHead, updates?: DocUpdate<T>[]): Promise<void>;
    processUpdates(updatesAcc: DocUpdate<T>[], all: boolean, prevHead: ClockHead): Promise<void>;
    notifyWatchers(updates: DocUpdate<T>[]): void;
    onTick(fn: (updates: DocUpdate<T>[]) => void): void;
    onTock(fn: () => void): void;
    onZoom(fn: () => void): void;
    int_applyHead(newHead: ClockHead, prevHead: ClockHead, localUpdates: boolean): Promise<void>;
}

declare class CRDT<T extends DocTypes> {
    readonly name?: string;
    readonly opts: ConfigOpts;
    readonly blockstore: BaseBlockstore;
    readonly indexBlockstore: BaseBlockstore;
    readonly indexers: Map<string, Index<IndexKeyType, NonNullable<unknown>>>;
    readonly clock: CRDTClock<T>;
    readonly logger: Logger;
    readonly sthis: SuperThis;
    constructor(sthis: SuperThis, name?: string, opts?: ConfigOpts);
    bulk(updates: DocUpdate<T>[]): Promise<CRDTMeta>;
    readonly onceReady: ResolveOnce<void>;
    ready(): Promise<void>;
    close(): Promise<void>;
    destroy(): Promise<void>;
    allDocs(): Promise<{
        result: DocUpdate<T>[];
        head: ClockHead;
    }>;
    vis(): Promise<string>;
    getBlock(cidString: string): Promise<Block$1>;
    get(key: string): Promise<DocValue<T> | Falsy>;
    changes(since?: ClockHead, opts?: ChangesOptions): Promise<{
        result: DocUpdate<T>[];
        head: ClockHead;
    }>;
    compact(): Promise<void>;
}

declare class Database<DT extends DocTypes = NonNullable<unknown>> implements Connectable {
    static databases: Map<string, Database>;
    readonly name?: string;
    readonly opts: ConfigOpts;
    _listening: boolean;
    readonly _listeners: Set<ListenerFn<DT>>;
    readonly _noupdate_listeners: Set<ListenerFn<DT>>;
    readonly _crdt: CRDT<DT>;
    readonly _writeQueue: WriteQueue<DT>;
    readonly blockstore: BaseBlockstore;
    close(): Promise<void>;
    destroy(): Promise<void>;
    readonly _ready: ResolveOnce<void>;
    ready(): Promise<void>;
    readonly logger: Logger;
    readonly sthis: SuperThis;
    constructor(name?: string, opts?: ConfigOpts);
    get<T extends DocTypes>(id: string): Promise<DocWithId<T>>;
    put<T extends DocTypes>(doc: DocSet<T>): Promise<DocResponse>;
    del(id: string): Promise<DocResponse>;
    changes<T extends DocTypes>(since?: ClockHead, opts?: ChangesOptions): Promise<ChangesResponse<T>>;
    allDocs<T extends DocTypes>(opts?: AllDocsQueryOpts): Promise<AllDocsResponse<T>>;
    allDocuments<T extends DocTypes>(): Promise<{
        rows: {
            key: string;
            value: DocWithId<T>;
        }[];
        clock: ClockHead;
    }>;
    subscribe<T extends DocTypes>(listener: ListenerFn<T>, updates?: boolean): () => void;
    query<K extends IndexKeyType, T extends DocTypes, R extends DocFragment = T>(field: string | MapFn<T>, opts?: QueryOpts<K>): Promise<IndexRows<K, T, R>>;
    compact(): Promise<void>;
    _notify(updates: DocUpdate<NonNullable<unknown>>[]): Promise<void>;
    _no_update_notify(): Promise<void>;
}
declare function fireproof(name: string, opts?: ConfigOpts): Database;

declare function getPath(url: URI, sthis: SuperThis$1): string;
declare function getFileName(url: URI, sthis: SuperThis$1): string;

declare function encodeFile(blob: BlobLike): Promise<{
    cid: AnyLink;
    blocks: AnyBlock[];
}>;
declare function decodeFile(blocks: unknown, cid: AnyLink, meta: DocFileMeta): Promise<File>;

declare const files_decodeFile: typeof decodeFile;
declare const files_encodeFile: typeof encodeFile;
declare namespace files {
  export { files_decodeFile as decodeFile, files_encodeFile as encodeFile };
}

declare class BlockIvKeyIdCodec implements BlockCodec<0x300539, Uint8Array> {
    readonly code = 3147065;
    readonly name = "Fireproof@encrypted-block:aes-gcm";
    readonly ko: KeyedCrypto;
    readonly iv?: Uint8Array;
    readonly opts: Partial<CodecOpts>;
    constructor(ko: KeyedCrypto, iv?: Uint8Array, opts?: CodecOpts);
    encode(data: Uint8Array): Promise<Uint8Array>;
    decode(abytes: Uint8Array | ArrayBuffer): Promise<Uint8Array>;
}
declare function keyedCryptoFactory(url: URI, kb: KeyBag, sthis: SuperThis): Promise<KeyedCrypto>;

type keyedCrypto_BlockIvKeyIdCodec = BlockIvKeyIdCodec;
declare const keyedCrypto_BlockIvKeyIdCodec: typeof BlockIvKeyIdCodec;
declare const keyedCrypto_keyedCryptoFactory: typeof keyedCryptoFactory;
declare namespace keyedCrypto {
  export { keyedCrypto_BlockIvKeyIdCodec as BlockIvKeyIdCodec, keyedCrypto_keyedCryptoFactory as keyedCryptoFactory };
}

declare const Block: typeof Block$2;
interface DecodeInput<T, Code extends number, Alg extends number> {
    bytes: ByteView<T>;
    codec: BlockDecoder<Code, T>;
    hasher: MultihashHasher<Alg>;
}
declare function decode<T, Code extends number, Alg extends number>({ bytes, codec, hasher, }: DecodeInput<T, Code, Alg>): Promise<BlockView<T, Code, Alg>>;
interface EncodeInput<T, Code extends number, Alg extends number> {
    value: T;
    codec: BlockEncoder<Code, T>;
    hasher: MultihashHasher<Alg>;
}
declare function encode<T, Code extends number, Alg extends number>({ value, codec, hasher, }: EncodeInput<T, Code, Alg>): Promise<BlockView<T, Code, Alg>>;
interface CreateInput<T, Code extends number, Alg extends number, V extends Version> {
    bytes: ByteView<T>;
    cid: Link<T, Code, Alg, V>;
    hasher: MultihashHasher<Alg>;
    codec: BlockDecoder<Code, T>;
}
declare function create<T, Code extends number, Alg extends number, V extends Version>({ bytes, cid, hasher, codec, }: CreateInput<T, Code, Alg, V>): Promise<BlockView<T, Code, Alg, V>>;
type CreateUnsafeInput<T, Code extends number, Alg extends number, V extends Version> = {
    cid: Link<T, Code, Alg, V>;
    value: T;
    codec?: BlockDecoder<Code, T>;
    bytes: ByteView<T>;
} | {
    cid: Link<T, Code, Alg, V>;
    value?: undefined;
    codec: BlockDecoder<Code, T>;
    bytes: ByteView<T>;
};
declare function createUnsafe<T, Code extends number, Alg extends number, V extends Version>({ bytes, cid, value: maybeValue, codec, }: CreateUnsafeInput<T, Code, Alg, V>): Promise<BlockView<T, Code, Alg, V>>;

declare const block_Block: typeof Block;
declare const block_create: typeof create;
declare const block_createUnsafe: typeof createUnsafe;
declare const block_decode: typeof decode;
declare const block_encode: typeof encode;
declare namespace block {
  export { block_Block as Block, block_create as create, block_createUnsafe as createUnsafe, block_decode as decode, block_encode as encode };
}

declare const index$1_block: typeof block;
declare namespace index$1 {
  export { index$1_block as block, codecInterface as codec };
}

declare const FILESTORE_VERSION = "v0.19-file";

declare const INDEXDB_VERSION = "v0.19-indexdb";

declare const index_FILESTORE_VERSION: typeof FILESTORE_VERSION;
declare const index_INDEXDB_VERSION: typeof INDEXDB_VERSION;
declare const index_files: typeof files;
declare const index_getFileName: typeof getFileName;
declare const index_getPath: typeof getPath;
declare const index_runtimeFn: typeof runtimeFn;
declare namespace index {
  export { index_FILESTORE_VERSION as FILESTORE_VERSION, index_INDEXDB_VERSION as INDEXDB_VERSION, index_files as files, index_getFileName as getFileName, index_getPath as getPath, keyBag as kb, keyedCrypto as kc, index$1 as mf, index_runtimeFn as runtimeFn };
}

declare const PACKAGE_VERSION: string;

export { type AllDocsQueryOpts, type AllDocsResponse, CRDT, type CRDTEntry, type CRDTMeta, type ChangesOptions, type ChangesResponse, type ChangesResponseRow, type ClockHead, type ClockLink, type ConfigOpts, type Connectable, Database, type DocBase, type DocFileMeta, type DocFiles, type DocFragment, type DocLiteral, type DocObject, type DocRecord, type DocResponse, type DocSet, type DocTypes, type DocUpdate, type DocValue, type DocWithId, type Falsy, type FileTransactionMeta, type IdxMeta, type IdxMetaMap, Index, type IndexKey, type IndexKeyType, type IndexRow, type IndexRows, type IndexTransactionMeta, type IndexUpdate, type IndexUpdateString, type Joiner, type KeyLiteral, type ListenerFn, type MapFn, type MetaType, type NoUpdateListenerFn, NotFoundError, PACKAGE_VERSION, type PathOps, type QueryOpts, type Store, type StoreType, type SuperThis, type SuperThisOpts, type SysFileSystem, type TextEndeCoder, UInt8ArrayEqual, type UnknownDoc, type UpdateListenerFn, index$3 as blockstore, index$3 as bs, dataDir, ensureLogger, ensureSuperLog, ensureSuperThis, exceptionWrapper, falsyToUndef, fireproof, getKey, getName, getStore, index$2 as index, isFalsy, isNotFoundError, onSuperThis, index as rt, index as runtime, throwFalsy };
declare module '@fireproof/core'
