"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/runtime/gateways/file/node/to-array-buffer.ts
function toArrayBuffer(buffer) {
  if (typeof buffer === "string") {
    buffer = Buffer.from(buffer);
  }
  const ab = new ArrayBuffer(buffer.length);
  const view = new Uint8Array(ab);
  for (let i = 0; i < buffer.length; ++i) {
    view[i] = buffer[i];
  }
  return view;
}
var init_to_array_buffer = __esm({
  "src/runtime/gateways/file/node/to-array-buffer.ts"() {
    "use strict";
  }
});

// src/runtime/gateways/file/node/mem-filesystem.ts
var mem_filesystem_exports = {};
__export(mem_filesystem_exports, {
  MemFileSystem: () => MemFileSystem
});
var import_memfs, MemFileSystem;
var init_mem_filesystem = __esm({
  "src/runtime/gateways/file/node/mem-filesystem.ts"() {
    "use strict";
    import_memfs = require("memfs");
    init_to_array_buffer();
    MemFileSystem = class {
      async start() {
        return this;
      }
      mkdir(path, options) {
        return import_memfs.fs.promises.mkdir(path, options);
      }
      readdir(path, options) {
        return import_memfs.fs.promises.readdir(path, options);
      }
      rm(path, options) {
        return import_memfs.fs.promises.rm(path, options);
      }
      copyFile(source, destination) {
        return import_memfs.fs.promises.copyFile(source, destination);
      }
      async readfile(path, options) {
        const ret = await import_memfs.fs.promises.readFile(path, options);
        return toArrayBuffer(ret);
      }
      stat(path) {
        return import_memfs.fs.promises.stat(path);
      }
      unlink(path) {
        return import_memfs.fs.promises.unlink(path);
      }
      writefile(path, data) {
        return import_memfs.fs.promises.writeFile(path, Buffer.from(data));
      }
    };
  }
});

// src/runtime/gateways/file/node/index.ts
var index_exports = {};
__export(index_exports, {
  GatewayImpl: () => FileGateway,
  GatewayTestImpl: () => FileTestGateway,
  KeyBagProviderFile: () => KeyBagProviderFile,
  KeyBagProviderImpl: () => KeyBagProviderFile,
  getFileSystem: () => getFileSystem
});
module.exports = __toCommonJS(index_exports);

// src/runtime/gateways/file/node/key-bag-file.ts
var import_core = require("@fireproof/core");

// src/runtime/gateways/file/node/get-file-system.ts
var import_cement2 = require("@adviser/cement");

// src/runtime/gateways/file/node/node-filesystem.ts
init_to_array_buffer();
var import_cement = require("@adviser/cement");
var NodeFileSystem = class {
  async start() {
    this.fs = await import("fs/promises");
    return this;
  }
  async mkdir(path, options) {
    return this.fs?.mkdir(path, options);
  }
  async readdir(path, options) {
    return this.fs?.readdir(path, options);
  }
  async rm(path, options) {
    return this.fs?.rm(path, options);
  }
  async copyFile(source, destination) {
    return this.fs?.copyFile(source, destination);
  }
  async readfile(path, options) {
    const ret = await this.fs?.readFile(path, options);
    return toArrayBuffer(ret);
  }
  stat(path) {
    return this.fs?.stat(path);
  }
  async unlink(path) {
    return this.fs?.unlink(path);
  }
  async writefile(path, data) {
    if ((0, import_cement.runtimeFn)().isDeno) {
      return this.fs?.writeFile(path, data);
    }
    return this.fs?.writeFile(path, Buffer.from(data));
  }
};

// src/runtime/gateways/file/node/get-file-system.ts
var externalLoaders = new import_cement2.KeyedResolvOnce();
async function getFileSystem(url) {
  const name = url.getParam("fs", "node");
  let fs2;
  switch (name) {
    case "mem":
      fs2 = await externalLoaders.get(name).once(async () => {
        const { MemFileSystem: MemFileSystem2 } = await Promise.resolve().then(() => (init_mem_filesystem(), mem_filesystem_exports));
        return new MemFileSystem2();
      });
      break;
    // case 'deno': {
    //   const { DenoFileSystem } = await import("./deno-filesystem.js");
    //   fs = new DenoFileSystem();
    //   break;
    // }
    default:
      fs2 = await externalLoaders.get(name).once(async () => {
        return new NodeFileSystem();
      });
  }
  return fs2.start();
}

// src/runtime/gateways/file/node/key-bag-file.ts
var KeyBagProviderFile = class {
  async _prepare(id) {
    await this.sthis.start();
    let sysFS;
    switch (this.url.protocol) {
      case "file:": {
        sysFS = await getFileSystem(this.url);
        break;
      }
      default:
        throw this.logger.Error().Url(this.url).Msg("unsupported protocol").AsError();
    }
    const dirName = this.url.pathname;
    await sysFS.mkdir(dirName, { recursive: true });
    return {
      dirName,
      sysFS,
      fName: this.sthis.pathOps.join(dirName, `${id.replace(/[^a-zA-Z0-9]/g, "_")}.json`)
    };
  }
  constructor(url, sthis) {
    this.url = url;
    this.sthis = sthis;
    this.logger = sthis.logger;
  }
  async get(id) {
    const ctx = await this._prepare(id);
    try {
      const p = await ctx.sysFS.readfile(ctx.fName);
      const ki = JSON.parse(this.sthis.txt.decode(p));
      return ki;
    } catch (e) {
      if ((0, import_core.isNotFoundError)(e)) {
        return void 0;
      }
      throw this.logger.Error().Err(e).Str("file", ctx.dirName).Msg("read bag failed").AsError();
    }
  }
  async set(id, item) {
    const ctx = await this._prepare(id);
    const p = this.sthis.txt.encode(JSON.stringify(item, null, 2));
    await ctx.sysFS.writefile(ctx.fName, p);
  }
};

// src/runtime/gateways/file/version.ts
var FILESTORE_VERSION = "v0.19-file";

// src/runtime/gateways/file/node/gateway-impl.ts
var import_cement3 = require("@adviser/cement");
var import_core3 = require("@fireproof/core");

// src/runtime/gateways/file/node/utils.ts
var import_core2 = require("@fireproof/core");
function getPath(url, sthis) {
  const basePath = url.pathname;
  const name = url.getParam("name");
  if (name) {
    const version = url.getParam("version");
    if (!version) throw sthis.logger.Error().Url(url).Msg(`version not found`).AsError();
    return sthis.pathOps.join(basePath, version, name);
  }
  return sthis.pathOps.join(basePath);
}
function getFileName(url, sthis) {
  const key = url.getParam("key");
  if (!key) throw sthis.logger.Error().Url(url).Msg(`key not found`).AsError();
  const res = (0, import_core2.getStore)(url, sthis, (...a) => a.join("-"));
  switch (res.store) {
    case "data":
      return sthis.pathOps.join(res.name, key + ".car");
    case "wal":
    case "meta":
      return sthis.pathOps.join(res.name, key + ".json");
    default:
      throw sthis.logger.Error().Url(url).Msg(`unsupported store type`).AsError();
  }
}

// src/runtime/gateways/file/node/gateway-impl.ts
var versionFiles = new import_cement3.KeyedResolvOnce();
var FileGateway = class {
  constructor(sthis) {
    this.sthis = sthis;
    this.logger = sthis.logger;
  }
  async getVersionFromFile(fs2, path, logger) {
    return versionFiles.get(path).once(async () => {
      await fs2.mkdir(path, { recursive: true });
      const vFile = this.sthis.pathOps.join(path, "version");
      const vFileStat = await fs2.stat(vFile).catch(() => void 0);
      if (!vFileStat) {
        await fs2.writefile(this.sthis.pathOps.join(path, "version"), FILESTORE_VERSION);
        return FILESTORE_VERSION;
      } else if (!vFileStat.isFile()) {
        throw logger.Error().Str("file", vFile).Msg(`version file is a directory`).AsError();
      }
      const v = await fs2.readfile(vFile);
      const vStr = this.sthis.txt.decode(v);
      if (vStr !== FILESTORE_VERSION) {
        logger.Warn().Str("file", vFile).Str("from", vStr).Str("expected", FILESTORE_VERSION).Msg(`version mismatch`);
      }
      return vStr;
    });
  }
  start(baseURL) {
    return (0, import_cement3.exception2Result)(async () => {
      const fs2 = await getFileSystem(baseURL);
      const url = baseURL.build();
      url.defParam("version", FILESTORE_VERSION);
      const dbUrl = await this.buildUrl(url.URI(), "dummy");
      const dbdirFile = this.getFilePath(dbUrl.Ok());
      await fs2.mkdir(this.sthis.pathOps.dirname(dbdirFile), { recursive: true });
      const dbroot = this.sthis.pathOps.dirname(dbdirFile);
      this.logger.Debug().Url(url.URI()).Str("dbroot", dbroot).Msg("start");
      url.setParam("version", await this.getVersionFromFile(fs2, dbroot, this.logger));
      return url.URI();
    });
  }
  async buildUrl(baseUrl, key) {
    return import_cement3.Result.Ok(baseUrl.build().setParam("key", key).URI());
  }
  async close() {
    return import_cement3.Result.Ok(void 0);
  }
  // abstract buildUrl(baseUrl: URL, key: string): Promise<Result<URL>>;
  getFilePath(url) {
    const key = url.getParam("key");
    if (!key) throw this.logger.Error().Url(url).Msg(`key not found`).AsError();
    return this.sthis.pathOps.join(getPath(url, this.sthis), getFileName(url, this.sthis));
  }
  async put(url, body) {
    return (0, import_cement3.exception2Result)(async () => {
      const file = await this.getFilePath(url);
      this.logger.Debug().Str("url", url.toString()).Str("file", file).Msg("put");
      await getFileSystem(url).then((fs2) => fs2.writefile(file, body));
    });
  }
  async get(url) {
    return (0, import_core3.exceptionWrapper)(async () => {
      const file = this.getFilePath(url);
      try {
        const res = await getFileSystem(url).then((fs2) => fs2.readfile(file));
        this.logger.Debug().Url(url.asURL()).Str("file", file).Msg("get");
        return import_cement3.Result.Ok(new Uint8Array(res));
      } catch (e) {
        if ((0, import_core3.isNotFoundError)(e)) {
          return import_cement3.Result.Err(new import_core3.NotFoundError(`file not found: ${file}`));
        }
        return import_cement3.Result.Err(e);
      }
    });
  }
  async delete(url) {
    return (0, import_cement3.exception2Result)(async () => {
      await getFileSystem(url).then((fs2) => fs2.unlink(this.getFilePath(url)));
    });
  }
  async destroy(baseURL) {
    const url = await this.buildUrl(baseURL, "x");
    if (url.isErr()) return url;
    const filepath = this.sthis.pathOps.dirname(this.getFilePath(url.Ok()));
    const fs2 = await getFileSystem(baseURL);
    let files = [];
    try {
      files = await fs2.readdir(filepath);
    } catch (e) {
      if (!(0, import_core3.isNotFoundError)(e)) {
        throw this.logger.Error().Err(e).Str("dir", filepath).Msg("destroy:readdir").AsError();
      }
    }
    for (const file of files) {
      const pathed = this.sthis.pathOps.join(filepath, file);
      try {
        await fs2.unlink(pathed);
      } catch (e) {
        if (!(0, import_core3.isNotFoundError)(e)) {
          throw this.logger.Error().Err(e).Str("file", pathed).Msg("destroy:unlink").AsError();
        }
      }
    }
    return import_cement3.Result.Ok(void 0);
  }
};
var FileTestGateway = class {
  constructor(sthis) {
    this.logger = (0, import_core3.ensureLogger)(sthis, "FileTestStore");
    this.sthis = sthis;
  }
  async get(iurl, key) {
    const url = iurl.build().setParam("key", key).URI();
    const dbFile = this.sthis.pathOps.join(getPath(url, this.sthis), getFileName(url, this.sthis));
    this.logger.Debug().Url(url).Str("dbFile", dbFile).Msg("get");
    const buffer = await (await getFileSystem(url)).readfile(dbFile);
    this.logger.Debug().Url(url).Str("dbFile", dbFile).Len(buffer).Msg("got");
    return buffer;
  }
};
//# sourceMappingURL=index.cjs.map