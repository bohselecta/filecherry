"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/runtime/gateways/indexdb/web/index.ts
var index_exports = {};
__export(index_exports, {
  GatewayImpl: () => IndexDBGateway,
  GatewayTestImpl: () => IndexDBTestGateway,
  IndexDBGateway: () => IndexDBGateway,
  IndexDBTestGateway: () => IndexDBTestGateway,
  KeyBagProviderImpl: () => KeyBagProviderIndexDB,
  KeyBagProviderIndexDB: () => KeyBagProviderIndexDB,
  getIndexDBName: () => getIndexDBName
});
module.exports = __toCommonJS(index_exports);

// src/runtime/gateways/indexdb/web/gateway-impl.ts
var import_idb = require("idb");
var import_cement = require("@adviser/cement");

// src/runtime/gateways/indexdb/version.ts
var INDEXDB_VERSION = "v0.19-indexdb";

// src/runtime/gateways/indexdb/web/gateway-impl.ts
var import_core = require("@fireproof/core");
function ensureVersion(url) {
  return url.build().defParam("version", INDEXDB_VERSION).URI();
}
function sanitzeKey(key) {
  if (key.length === 1) {
    key = key[0];
  }
  return key;
}
var onceConn = new import_cement.KeyedResolvOnce();
async function connectIdb(url, sthis) {
  const dbName = getIndexDBName(url, sthis);
  const once = await onceConn.get(dbName.fullDb).once(async () => {
    const db = await (0, import_idb.openDB)(dbName.fullDb, 1, {
      upgrade(db2) {
        ["version", "data", "wal", "meta", "idx.data", "idx.wal", "idx.meta"].map((store) => {
          db2.createObjectStore(store, {
            autoIncrement: false
          });
        });
      }
    });
    const found = await db.get("version", "version");
    const version = ensureVersion(url).getParam("version");
    if (!found) {
      await db.put("version", { version }, "version");
    } else if (found.version !== version) {
      sthis.logger.Warn().Str("url", url.toString()).Str("version", version).Str("found", found.version).Msg("version mismatch");
    }
    return { db, dbName, version, url };
  });
  return {
    ...once,
    url: url.build().setParam("version", once.version).URI()
  };
}
function joinDBName(...names) {
  return names.map((i) => i.replace(/^[^a-zA-Z0-9]+/g, "").replace(/[^a-zA-Z0-9-]+/g, "_")).filter((i) => i.length).join(".");
}
function getIndexDBName(iurl, sthis) {
  const url = ensureVersion(iurl);
  const fullDb = url.pathname.replace(/^\/+/, "").replace(/\?.*$/, "");
  const dbName = url.getParam("name");
  if (!dbName) throw sthis.logger.Error().Str("url", url.toString()).Msg(`name not found`).AsError();
  const result = joinDBName(fullDb, dbName);
  const objStore = (0, import_core.getStore)(url, sthis, joinDBName).name;
  const connectionKey = [result, objStore].join(":");
  return {
    fullDb: result,
    objStore,
    connectionKey,
    dbName
  };
}
var IndexDBGateway = class {
  constructor(sthis) {
    this.logger = (0, import_core.ensureLogger)(sthis, "IndexDBGateway");
    this.sthis = sthis;
  }
  // _db: IDBPDatabase<unknown> = {} as IDBPDatabase<unknown>;
  async start(baseURL) {
    return (0, import_cement.exception2Result)(async () => {
      this.logger.Debug().Url(baseURL).Msg("starting");
      await this.sthis.start();
      const ic = await connectIdb(baseURL, this.sthis);
      this.logger.Debug().Url(ic.url).Msg("started");
      return ic.url;
    });
  }
  async close() {
    return import_cement.Result.Ok(void 0);
  }
  async destroy(baseUrl) {
    return (0, import_cement.exception2Result)(async () => {
      const type = (0, import_core.getStore)(baseUrl, this.sthis, joinDBName).name;
      const idb = await connectIdb(baseUrl, this.sthis);
      const trans = idb.db.transaction(type, "readwrite");
      const object_store = trans.objectStore(type);
      const toDelete = [];
      for (let cursor = await object_store.openCursor(); cursor; cursor = await cursor.continue()) {
        toDelete.push(cursor.primaryKey);
      }
      for (const key of toDelete) {
        await trans.db.delete(type, key);
      }
      await trans.done;
    });
  }
  buildUrl(baseUrl, key) {
    return Promise.resolve(import_cement.Result.Ok(baseUrl.build().setParam("key", key).URI()));
  }
  async get(url) {
    return (0, import_core.exceptionWrapper)(async () => {
      const key = (0, import_core.getKey)(url, this.logger);
      const store = (0, import_core.getStore)(url, this.sthis, joinDBName).name;
      this.logger.Debug().Url(url).Str("key", key).Str("store", store).Msg("getting");
      const { db } = await connectIdb(url, this.sthis);
      const tx = db.transaction([store], "readonly");
      const bytes = await tx.objectStore(store).get(sanitzeKey(key));
      await tx.done;
      if (!bytes) {
        return import_cement.Result.Err(new import_core.NotFoundError(`missing ${key}`));
      }
      return import_cement.Result.Ok(bytes);
    });
  }
  async put(url, value) {
    return (0, import_cement.exception2Result)(async () => {
      const key = (0, import_core.getKey)(url, this.logger);
      const store = (0, import_core.getStore)(url, this.sthis, joinDBName).name;
      this.logger.Debug().Url(url).Str("key", key).Str("store", store).Msg("putting");
      const { db } = await connectIdb(url, this.sthis);
      const tx = db.transaction([store], "readwrite");
      await tx.objectStore(store).put(value, sanitzeKey(key));
      await tx.done;
    });
  }
  async delete(url) {
    return (0, import_cement.exception2Result)(async () => {
      const key = (0, import_core.getKey)(url, this.logger);
      const store = (0, import_core.getStore)(url, this.sthis, joinDBName).name;
      this.logger.Debug().Url(url).Str("key", key).Str("store", store).Msg("deleting");
      const { db } = await connectIdb(url, this.sthis);
      const tx = db.transaction([store], "readwrite");
      await tx.objectStore(store).delete(sanitzeKey(key));
      await tx.done;
      return import_cement.Result.Ok(void 0);
    });
  }
};
var IndexDBTestGateway = class {
  constructor(sthis) {
    this.sthis = sthis;
    this.logger = (0, import_core.ensureLogger)(sthis, "IndexDBTestStore", {});
  }
  async get(url, key) {
    const ic = await connectIdb(url, this.sthis);
    const store = (0, import_core.getStore)(ic.url, this.sthis, joinDBName).name;
    this.logger.Debug().Str("key", key).Str("store", store).Msg("getting");
    let bytes = await ic.db.get(store, sanitzeKey(key));
    this.logger.Debug().Str("key", key).Str("store", store).Int("len", bytes.length).Msg("got");
    if (typeof bytes === "string") {
      bytes = this.sthis.txt.encode(bytes);
    }
    return bytes;
  }
};

// src/runtime/gateways/indexdb/web/key-bag-indexdb.ts
var import_idb2 = require("idb");
var import_cement2 = require("@adviser/cement");
var import_core2 = require("@fireproof/core");
var KeyBagProviderIndexDB = class {
  constructor(url, sthis) {
    this._db = new import_cement2.ResolveOnce();
    this.sthis = sthis;
    this.logger = sthis.logger;
    this.url = url;
    this.dbName = import_core2.rt.getPath(this.url, this.sthis);
  }
  async _prepare() {
    return this._db.once(async () => {
      return await (0, import_idb2.openDB)(this.dbName, 1, {
        upgrade(db) {
          ["bag"].map((store) => {
            db.createObjectStore(store, {
              autoIncrement: false
            });
          });
        }
      });
    });
  }
  async get(id) {
    const db = await this._prepare();
    const tx = db.transaction(["bag"], "readonly");
    const keyItem = await tx.objectStore("bag").get(id);
    await tx.done;
    if (!keyItem) {
      return void 0;
    }
    return keyItem;
  }
  async set(id, item) {
    const db = await this._prepare();
    const tx = db.transaction(["bag"], "readwrite");
    await tx.objectStore("bag").put(item, id);
    await tx.done;
  }
};
//# sourceMappingURL=index.cjs.map