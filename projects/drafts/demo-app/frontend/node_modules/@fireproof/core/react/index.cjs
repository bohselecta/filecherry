"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/react/index.ts
var index_exports = {};
__export(index_exports, {
  FireproofCtx: () => FireproofCtx,
  ImgFile: () => ImgFile,
  useAllDocs: () => useAllDocs,
  useChanges: () => useChanges,
  useDocument: () => useDocument,
  useFireproof: () => useFireproof,
  useLiveQuery: () => useLiveQuery
});
module.exports = __toCommonJS(index_exports);

// src/react/useFireproof.ts
var import_core = require("@fireproof/core");
var import_react = require("react");
var FireproofCtx = {};
function deepClone(value) {
  if (typeof structuredClone !== "undefined") {
    return structuredClone(value);
  } else {
    return JSON.parse(JSON.stringify(value));
  }
}
function useFireproof(name = "useFireproof", config = {}) {
  const database = typeof name === "string" ? (0, import_core.fireproof)(name, config) : name;
  const updateHappenedRef = (0, import_react.useRef)(false);
  function useDocument2(initialDocOrFn) {
    let initialDoc;
    if (typeof initialDocOrFn === "function") {
      initialDoc = initialDocOrFn();
    } else {
      initialDoc = initialDocOrFn ?? {};
    }
    const originalInitialDoc = (0, import_react.useMemo)(() => deepClone({ ...initialDoc }), []);
    const [doc, setDoc] = (0, import_react.useState)(initialDoc);
    const refresh = (0, import_react.useCallback)(async () => {
      const gotDoc = doc._id ? await database.get(doc._id).catch(() => initialDoc) : initialDoc;
      setDoc(gotDoc);
    }, [doc._id]);
    const save = (0, import_react.useCallback)(
      async (existingDoc) => {
        updateHappenedRef.current = false;
        const toSave = existingDoc ?? doc;
        const res = await database.put(toSave);
        if (!updateHappenedRef.current && !doc._id && !existingDoc) {
          setDoc((d) => ({ ...d, _id: res.id }));
        }
        return res;
      },
      [doc]
    );
    const remove = (0, import_react.useCallback)(
      async (existingDoc) => {
        const id = existingDoc?._id ?? doc._id;
        if (!id) throw database.logger.Error().Msg(`Document must have an _id to be removed`).AsError();
        const gotDoc = await database.get(id).catch(() => void 0);
        if (!gotDoc) throw database.logger.Error().Str("id", id).Msg(`Document not found`).AsError();
        const res = await database.del(id);
        setDoc(initialDoc);
        return res;
      },
      [doc, initialDoc]
    );
    const merge = (0, import_react.useCallback)((newDoc) => {
      updateHappenedRef.current = true;
      setDoc((prev) => ({ ...prev, ...newDoc }));
    }, []);
    const replace = (0, import_react.useCallback)((newDoc) => {
      updateHappenedRef.current = true;
      setDoc(newDoc);
    }, []);
    const reset = (0, import_react.useCallback)(() => {
      updateHappenedRef.current = true;
      setDoc({ ...originalInitialDoc });
    }, [originalInitialDoc]);
    const updateDoc = (0, import_react.useCallback)(
      (newDoc, opts = { replace: false, reset: false }) => {
        if (!newDoc) {
          return opts.reset ? reset() : refresh();
        }
        return opts.replace ? replace(newDoc) : merge(newDoc);
      },
      [refresh, reset, replace, merge]
    );
    (0, import_react.useEffect)(() => {
      if (!doc._id) return;
      return database.subscribe((changes) => {
        if (updateHappenedRef.current) {
          return;
        }
        if (changes.find((c) => c._id === doc._id)) {
          void refresh();
        }
      }, true);
    }, [doc._id, refresh]);
    (0, import_react.useEffect)(() => {
      void refresh();
    }, [refresh]);
    const submit = (0, import_react.useCallback)(
      async (e) => {
        if (e?.preventDefault) e.preventDefault();
        await save();
        reset();
      },
      [save, reset]
    );
    const apiObject = {
      doc: { ...doc },
      merge,
      replace,
      reset,
      refresh,
      save,
      remove,
      submit
    };
    const tuple = [{ ...doc }, updateDoc, save, remove, reset, refresh];
    Object.assign(apiObject, tuple);
    Object.defineProperty(apiObject, Symbol.iterator, {
      enumerable: false,
      value: function* () {
        yield* tuple;
      }
    });
    return apiObject;
  }
  function useLiveQuery2(mapFn, query = {}, initialRows = []) {
    const [result, setResult] = (0, import_react.useState)(() => {
      const docs = initialRows.map((r) => r.doc).filter((r) => !!r);
      return {
        rows: initialRows,
        docs,
        length: docs.length,
        map: (fn) => docs.map(fn),
        filter: (fn) => docs.filter(fn),
        forEach: (fn) => docs.forEach(fn),
        [Symbol.iterator]: () => docs[Symbol.iterator]()
      };
    });
    const queryString = (0, import_react.useMemo)(() => JSON.stringify(query), [query]);
    const mapFnString = (0, import_react.useMemo)(() => mapFn.toString(), [mapFn]);
    const refreshRows = (0, import_react.useCallback)(async () => {
      const res = await database.query(mapFn, query);
      const docs = res.rows.map((r) => r.doc).filter((r) => !!r);
      setResult({
        ...res,
        docs,
        length: docs.length,
        map: (fn) => docs.map(fn),
        filter: (fn) => docs.filter(fn),
        forEach: (fn) => docs.forEach(fn),
        [Symbol.iterator]: () => docs[Symbol.iterator]()
      });
    }, [mapFnString, queryString]);
    (0, import_react.useEffect)(() => {
      refreshRows();
      return database.subscribe(refreshRows);
    }, [refreshRows]);
    return result;
  }
  function useAllDocs2(query = {}) {
    const [result, setResult] = (0, import_react.useState)({
      docs: []
    });
    const queryString = (0, import_react.useMemo)(() => JSON.stringify(query), [query]);
    const refreshRows = (0, import_react.useCallback)(async () => {
      const res = await database.allDocs(query);
      setResult({ ...res, docs: res.rows.map((r) => r.value) });
    }, [queryString]);
    (0, import_react.useEffect)(() => {
      refreshRows();
      return database.subscribe(refreshRows);
    }, [refreshRows]);
    return result;
  }
  function useChanges2(since = [], opts = {}) {
    const [result, setResult] = (0, import_react.useState)({
      docs: []
    });
    const queryString = (0, import_react.useMemo)(() => JSON.stringify(opts), [opts]);
    const refreshRows = (0, import_react.useCallback)(async () => {
      const res = await database.changes(since, opts);
      setResult({ ...res, docs: res.rows.map((r) => r.value) });
    }, [since, queryString]);
    (0, import_react.useEffect)(() => {
      refreshRows();
      return database.subscribe(refreshRows);
    }, [refreshRows]);
    return result;
  }
  return { database, useLiveQuery: useLiveQuery2, useDocument: useDocument2, useAllDocs: useAllDocs2, useChanges: useChanges2 };
}

// src/react/useDocument.ts
function topLevelUseDocument(...args) {
  const { useDocument: useDocument2, database } = useFireproof();
  topLevelUseDocument.database = database;
  return useDocument2(...args);
}
var useDocument = topLevelUseDocument;

// src/react/useLiveQuery.ts
function topLevelUseLiveQuery(...args) {
  const { useLiveQuery: useLiveQuery2, database } = useFireproof();
  topLevelUseLiveQuery.database = database;
  return useLiveQuery2(...args);
}
var useLiveQuery = topLevelUseLiveQuery;

// src/react/useAllDocs.ts
function topLevelUseAllDocs(...args) {
  const { useAllDocs: useAllDocs2, database } = useFireproof();
  topLevelUseAllDocs.database = database;
  return useAllDocs2(...args);
}
var useAllDocs = topLevelUseAllDocs;

// src/react/useChanges.ts
function topLevelUseChanges(...args) {
  const { useChanges: useChanges2, database } = useFireproof();
  topLevelUseChanges.database = database;
  return useChanges2(...args);
}
var useChanges = topLevelUseChanges;

// src/react/img-file.ts
var import_react2 = __toESM(require("react"), 1);
var { URL } = window;
function isFile(obj) {
  return "type" in obj && "size" in obj && "stream" in obj && typeof obj.stream === "function";
}
function isFileMeta(obj) {
  return "type" in obj && "size" in obj && "file" in obj && typeof obj.file === "function";
}
function ImgFile({ file, meta, ...imgProps }) {
  const [imgDataUrl, setImgDataUrl] = (0, import_react2.useState)("");
  const fileData = file || meta;
  (0, import_react2.useEffect)(() => {
    if (!fileData) return;
    const loadFile = async () => {
      let fileObj = null;
      let fileType = "";
      switch (true) {
        case isFile(fileData):
          fileObj = fileData;
          fileType = fileData.type;
          break;
        case isFileMeta(fileData):
          fileType = fileData.type;
          fileObj = await fileData.file?.() || null;
          break;
      }
      if (fileObj && /image/.test(fileType)) {
        const src = URL.createObjectURL(fileObj);
        setImgDataUrl(src);
        return () => URL.revokeObjectURL(src);
      }
    };
    let isMounted = true;
    let cleanup;
    loadFile().then((result) => {
      if (isMounted) {
        cleanup = result;
      } else if (result) {
        result();
      }
    });
    return () => {
      isMounted = false;
      if (cleanup) cleanup();
    };
  }, [fileData]);
  return imgDataUrl ? import_react2.default.createElement("img", {
    src: imgDataUrl,
    ...imgProps
  }) : null;
}
//# sourceMappingURL=index.cjs.map