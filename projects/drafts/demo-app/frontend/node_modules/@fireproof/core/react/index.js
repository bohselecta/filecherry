// src/react/useFireproof.ts
import { fireproof } from "@fireproof/core";
import { useCallback, useEffect, useMemo, useState, useRef } from "react";
var FireproofCtx = {};
function deepClone(value) {
  if (typeof structuredClone !== "undefined") {
    return structuredClone(value);
  } else {
    return JSON.parse(JSON.stringify(value));
  }
}
function useFireproof(name = "useFireproof", config = {}) {
  const database = typeof name === "string" ? fireproof(name, config) : name;
  const updateHappenedRef = useRef(false);
  function useDocument2(initialDocOrFn) {
    let initialDoc;
    if (typeof initialDocOrFn === "function") {
      initialDoc = initialDocOrFn();
    } else {
      initialDoc = initialDocOrFn ?? {};
    }
    const originalInitialDoc = useMemo(() => deepClone({ ...initialDoc }), []);
    const [doc, setDoc] = useState(initialDoc);
    const refresh = useCallback(async () => {
      const gotDoc = doc._id ? await database.get(doc._id).catch(() => initialDoc) : initialDoc;
      setDoc(gotDoc);
    }, [doc._id]);
    const save = useCallback(
      async (existingDoc) => {
        updateHappenedRef.current = false;
        const toSave = existingDoc ?? doc;
        const res = await database.put(toSave);
        if (!updateHappenedRef.current && !doc._id && !existingDoc) {
          setDoc((d) => ({ ...d, _id: res.id }));
        }
        return res;
      },
      [doc]
    );
    const remove = useCallback(
      async (existingDoc) => {
        const id = existingDoc?._id ?? doc._id;
        if (!id) throw database.logger.Error().Msg(`Document must have an _id to be removed`).AsError();
        const gotDoc = await database.get(id).catch(() => void 0);
        if (!gotDoc) throw database.logger.Error().Str("id", id).Msg(`Document not found`).AsError();
        const res = await database.del(id);
        setDoc(initialDoc);
        return res;
      },
      [doc, initialDoc]
    );
    const merge = useCallback((newDoc) => {
      updateHappenedRef.current = true;
      setDoc((prev) => ({ ...prev, ...newDoc }));
    }, []);
    const replace = useCallback((newDoc) => {
      updateHappenedRef.current = true;
      setDoc(newDoc);
    }, []);
    const reset = useCallback(() => {
      updateHappenedRef.current = true;
      setDoc({ ...originalInitialDoc });
    }, [originalInitialDoc]);
    const updateDoc = useCallback(
      (newDoc, opts = { replace: false, reset: false }) => {
        if (!newDoc) {
          return opts.reset ? reset() : refresh();
        }
        return opts.replace ? replace(newDoc) : merge(newDoc);
      },
      [refresh, reset, replace, merge]
    );
    useEffect(() => {
      if (!doc._id) return;
      return database.subscribe((changes) => {
        if (updateHappenedRef.current) {
          return;
        }
        if (changes.find((c) => c._id === doc._id)) {
          void refresh();
        }
      }, true);
    }, [doc._id, refresh]);
    useEffect(() => {
      void refresh();
    }, [refresh]);
    const submit = useCallback(
      async (e) => {
        if (e?.preventDefault) e.preventDefault();
        await save();
        reset();
      },
      [save, reset]
    );
    const apiObject = {
      doc: { ...doc },
      merge,
      replace,
      reset,
      refresh,
      save,
      remove,
      submit
    };
    const tuple = [{ ...doc }, updateDoc, save, remove, reset, refresh];
    Object.assign(apiObject, tuple);
    Object.defineProperty(apiObject, Symbol.iterator, {
      enumerable: false,
      value: function* () {
        yield* tuple;
      }
    });
    return apiObject;
  }
  function useLiveQuery2(mapFn, query = {}, initialRows = []) {
    const [result, setResult] = useState(() => {
      const docs = initialRows.map((r) => r.doc).filter((r) => !!r);
      return {
        rows: initialRows,
        docs,
        length: docs.length,
        map: (fn) => docs.map(fn),
        filter: (fn) => docs.filter(fn),
        forEach: (fn) => docs.forEach(fn),
        [Symbol.iterator]: () => docs[Symbol.iterator]()
      };
    });
    const queryString = useMemo(() => JSON.stringify(query), [query]);
    const mapFnString = useMemo(() => mapFn.toString(), [mapFn]);
    const refreshRows = useCallback(async () => {
      const res = await database.query(mapFn, query);
      const docs = res.rows.map((r) => r.doc).filter((r) => !!r);
      setResult({
        ...res,
        docs,
        length: docs.length,
        map: (fn) => docs.map(fn),
        filter: (fn) => docs.filter(fn),
        forEach: (fn) => docs.forEach(fn),
        [Symbol.iterator]: () => docs[Symbol.iterator]()
      });
    }, [mapFnString, queryString]);
    useEffect(() => {
      refreshRows();
      return database.subscribe(refreshRows);
    }, [refreshRows]);
    return result;
  }
  function useAllDocs2(query = {}) {
    const [result, setResult] = useState({
      docs: []
    });
    const queryString = useMemo(() => JSON.stringify(query), [query]);
    const refreshRows = useCallback(async () => {
      const res = await database.allDocs(query);
      setResult({ ...res, docs: res.rows.map((r) => r.value) });
    }, [queryString]);
    useEffect(() => {
      refreshRows();
      return database.subscribe(refreshRows);
    }, [refreshRows]);
    return result;
  }
  function useChanges2(since = [], opts = {}) {
    const [result, setResult] = useState({
      docs: []
    });
    const queryString = useMemo(() => JSON.stringify(opts), [opts]);
    const refreshRows = useCallback(async () => {
      const res = await database.changes(since, opts);
      setResult({ ...res, docs: res.rows.map((r) => r.value) });
    }, [since, queryString]);
    useEffect(() => {
      refreshRows();
      return database.subscribe(refreshRows);
    }, [refreshRows]);
    return result;
  }
  return { database, useLiveQuery: useLiveQuery2, useDocument: useDocument2, useAllDocs: useAllDocs2, useChanges: useChanges2 };
}

// src/react/useDocument.ts
function topLevelUseDocument(...args) {
  const { useDocument: useDocument2, database } = useFireproof();
  topLevelUseDocument.database = database;
  return useDocument2(...args);
}
var useDocument = topLevelUseDocument;

// src/react/useLiveQuery.ts
function topLevelUseLiveQuery(...args) {
  const { useLiveQuery: useLiveQuery2, database } = useFireproof();
  topLevelUseLiveQuery.database = database;
  return useLiveQuery2(...args);
}
var useLiveQuery = topLevelUseLiveQuery;

// src/react/useAllDocs.ts
function topLevelUseAllDocs(...args) {
  const { useAllDocs: useAllDocs2, database } = useFireproof();
  topLevelUseAllDocs.database = database;
  return useAllDocs2(...args);
}
var useAllDocs = topLevelUseAllDocs;

// src/react/useChanges.ts
function topLevelUseChanges(...args) {
  const { useChanges: useChanges2, database } = useFireproof();
  topLevelUseChanges.database = database;
  return useChanges2(...args);
}
var useChanges = topLevelUseChanges;

// src/react/img-file.ts
import React, { useState as useState2, useEffect as useEffect2 } from "react";
var { URL } = window;
function isFile(obj) {
  return "type" in obj && "size" in obj && "stream" in obj && typeof obj.stream === "function";
}
function isFileMeta(obj) {
  return "type" in obj && "size" in obj && "file" in obj && typeof obj.file === "function";
}
function ImgFile({ file, meta, ...imgProps }) {
  const [imgDataUrl, setImgDataUrl] = useState2("");
  const fileData = file || meta;
  useEffect2(() => {
    if (!fileData) return;
    const loadFile = async () => {
      let fileObj = null;
      let fileType = "";
      switch (true) {
        case isFile(fileData):
          fileObj = fileData;
          fileType = fileData.type;
          break;
        case isFileMeta(fileData):
          fileType = fileData.type;
          fileObj = await fileData.file?.() || null;
          break;
      }
      if (fileObj && /image/.test(fileType)) {
        const src = URL.createObjectURL(fileObj);
        setImgDataUrl(src);
        return () => URL.revokeObjectURL(src);
      }
    };
    let isMounted = true;
    let cleanup;
    loadFile().then((result) => {
      if (isMounted) {
        cleanup = result;
      } else if (result) {
        result();
      }
    });
    return () => {
      isMounted = false;
      if (cleanup) cleanup();
    };
  }, [fileData]);
  return imgDataUrl ? React.createElement("img", {
    src: imgDataUrl,
    ...imgProps
  }) : null;
}
export {
  FireproofCtx,
  ImgFile,
  useAllDocs,
  useChanges,
  useDocument,
  useFireproof,
  useLiveQuery
};
//# sourceMappingURL=index.js.map