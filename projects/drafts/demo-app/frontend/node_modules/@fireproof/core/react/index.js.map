{"version":3,"sources":["../../../src/react/useFireproof.ts","../../../src/react/useDocument.ts","../../../src/react/useLiveQuery.ts","../../../src/react/useAllDocs.ts","../../../src/react/useChanges.ts","../../../src/react/img-file.ts"],"sourcesContent":["import type {\n  ConfigOpts,\n  DocFragment,\n  DocResponse,\n  DocSet,\n  DocTypes,\n  DocWithId,\n  IndexKeyType,\n  IndexRow,\n  MapFn,\n  QueryOpts,\n  Database,\n} from \"@fireproof/core\";\nimport { fireproof } from \"@fireproof/core\";\nimport { useCallback, useEffect, useMemo, useState, useRef } from \"react\";\nimport type { AllDocsQueryOpts, ChangesOptions, ClockHead } from \"@fireproof/core\";\n\nexport interface LiveQueryResult<T extends DocTypes, K extends IndexKeyType, R extends DocFragment = T> {\n  readonly docs: DocWithId<T>[];\n  readonly rows: IndexRow<K, T, R>[];\n  /** @internal */\n  readonly length: number;\n  /** @internal */\n  map<U>(callbackfn: (value: DocWithId<T>, index: number, array: DocWithId<T>[]) => U): U[];\n  /** @internal */\n  filter(predicate: (value: DocWithId<T>, index: number, array: DocWithId<T>[]) => boolean): DocWithId<T>[];\n  /** @internal */\n  forEach(callbackfn: (value: DocWithId<T>, index: number, array: DocWithId<T>[]) => void): void;\n  /** @internal */\n  [Symbol.iterator](): Iterator<DocWithId<T>>;\n}\n\nexport type UseLiveQuery = <T extends DocTypes, K extends IndexKeyType = string, R extends DocFragment = T>(\n  mapFn: string | MapFn<T>,\n  query?: QueryOpts<K>,\n  initialRows?: IndexRow<K, T, R>[],\n) => LiveQueryResult<T, K, R>;\n\nexport interface AllDocsResult<T extends DocTypes> {\n  readonly docs: DocWithId<T>[];\n}\n\nexport interface ChangesResult<T extends DocTypes> {\n  readonly docs: DocWithId<T>[];\n}\n\nexport type UseAllDocs = <T extends DocTypes>(query?: AllDocsQueryOpts) => AllDocsResult<T>;\n\nexport type UseChanges = <T extends DocTypes>(since: ClockHead, opts: ChangesOptions) => ChangesResult<T>;\n\ninterface UpdateDocFnOptions {\n  readonly replace?: boolean;\n  readonly reset?: boolean;\n}\n\ntype UpdateDocFn<T extends DocTypes> = (newDoc?: DocSet<T>, options?: UpdateDocFnOptions) => void;\n\ntype StoreDocFn<T extends DocTypes> = (existingDoc?: DocWithId<T>) => Promise<DocResponse>;\n\ntype DeleteDocFn<T extends DocTypes> = (existingDoc?: DocWithId<T>) => Promise<DocResponse>;\n\ntype UseDocumentResultTuple<T extends DocTypes> = [DocWithId<T>, UpdateDocFn<T>, StoreDocFn<T>, DeleteDocFn<T>];\n\ninterface UseDocumentResultObject<T extends DocTypes> {\n  doc: DocWithId<T>;\n  merge: (newDoc: Partial<T>) => void;\n  replace: (newDoc: T) => void;\n  reset: () => void;\n  refresh: () => Promise<void>;\n  save: StoreDocFn<T>;\n  remove: DeleteDocFn<T>;\n  submit: (e?: Event) => Promise<void>;\n}\n\nexport type UseDocumentResult<T extends DocTypes> = UseDocumentResultObject<T> & UseDocumentResultTuple<T>;\n\nexport type UseDocumentInitialDocOrFn<T extends DocTypes> = DocSet<T> | (() => DocSet<T>);\nexport type UseDocument = <T extends DocTypes>(initialDocOrFn: UseDocumentInitialDocOrFn<T>) => UseDocumentResult<T>;\n\nexport interface UseFireproof {\n  readonly database: Database;\n  /**\n   * ## Summary\n   *\n   * React hook that provides the ability to create/update/save new Fireproof documents into your custom Fireproof database.\n   * The creation occurs when you do not pass in an `_id` as part of your initial document -- the database will assign a new\n   * one when you call the provided `save` handler. The hook also provides generics support so you can inline your custom type into\n   * the invocation to receive type-safety and auto-complete support in your IDE.\n   *\n   * ## Usage\n   *\n   * ```tsx\n   * const todo = useDocument<Todo>({\n   *   text: '',\n   *   date: Date.now(),\n   *   completed: false\n   * })\n   * // Access via object properties\n   * todo.doc // The current document\n   * todo.merge({ completed: true }) // Update specific fields\n   * todo.replace({ text: 'new', date: Date.now(), completed: false }) // Replace entire doc\n   * todo.save() // Save changes\n   * todo.remove() // Delete document\n   * todo.reset() // Reset to initial state\n   * todo.refresh() // Refresh from database\n   *\n   * // Or use tuple destructuring for legacy compatibility\n   * const [doc, updateDoc, saveDoc, removeDoc] = todo\n   * ```\n   *\n   * ## Overview\n   *\n   * Changes made via remote sync peers, or other members of your cloud replica group will appear automatically\n   * when you use the `useLiveQuery` and `useDocument` APIs. By default, Fireproof stores data in the browser's\n   * local storage.\n   */\n  readonly useDocument: UseDocument;\n  /**\n   * ## Summary\n   * React hook that provides access to live query results, enabling real-time updates in your app.\n   *\n   * ## Usage\n   * ```tsx\n   * const result = useLiveQuery(\"date\"); // using string key\n   * const result = useLiveQuery('date', { limit: 10, descending: true }) // key + options\n   * const result = useLiveQuery<CustomType>(\"date\"); // using generics\n   * const result = useLiveQuery((doc) => doc.date)); // using map function\n   * ```\n   *\n   * ## Overview\n   * Changes made via remote sync peers, or other members of your cloud replica group will appear automatically\n   * when you use the `useLiveQuery` and `useDocument` APIs. By default, Fireproof stores data in the browser's\n   * local storage.\n   */\n  readonly useLiveQuery: UseLiveQuery;\n  /**\n   * ## Summary\n   * React hook that provides access to all documents in the database, sorted by `_id`.\n   *\n   * ## Usage\n   * ```tsx\n   * const result = useAllDocs({ limit: 10, descending: true }); // with options\n   * const result = useAllDocs(); // without options\n   * ```\n   *\n   * ## Overview\n   * Changes made via remote sync peers, or other members of your cloud replica group will appear automatically\n   * when you use the `useAllDocs` and `useDocument` APIs. By default, Fireproof stores data in the browser's\n   * local storage.\n   */\n  readonly useAllDocs: UseAllDocs;\n  /**\n   * ## Summary\n   * React hook that provides access to all new documents in the database added since the last time the changes was called\n   *\n   * ## Usage\n   * ```tsx\n   * const result = useChanges(prevresult.clock,{limit:10}); // with options\n   * const result = useChanges(); // without options\n   * ```\n   *\n   * ## Overview\n   * Changes made via remote sync peers, or other members of your cloud replica group will appear automatically\n   * when you use the `useAllDocs`, `useChanges` and `useDocument` APIs. By default, Fireproof stores data in the browser's\n   * local storage.\n   */\n  readonly useChanges: UseChanges;\n}\n\n/**\n * @deprecated Use the `useFireproof` hook instead\n */\nexport const FireproofCtx = {} as UseFireproof;\n\nfunction deepClone<T>(value: T): T {\n  if (typeof structuredClone !== \"undefined\") {\n    return structuredClone(value);\n  } else {\n    // Fallback if structuredClone is not available (older browsers, older Node versions, etc.)\n    return JSON.parse(JSON.stringify(value));\n  }\n}\n\n/**\n *\n * ## Summary\n *\n * React hook to create a custom-named Fireproof database and provides the utility hooks to query against it.\n *\n * ## Usage\n * ```tsx\n * const { database, useLiveQuery, useDocument } = useFireproof(\"dbname\");\n * const { database, useLiveQuery, useDocument } = useFireproof(\"dbname\", { ...options });\n * ```\n *\n * ## Overview\n *\n * TL;DR: Only use this hook if you need to configure a database name other than the default `useFireproof`.\n *\n * For most applications, using the `useLiveQuery` or `useDocument` hooks exported from `use-fireproof` should\n * suffice for the majority of use-cases. Under the hood, they act against a database named `useFireproof` instantiated with\n * default configurations. However, if you need to do a custom database setup or configure a database name more to your liking\n * than the default `useFireproof`, then use `useFireproof` as it exists for that purpose. It will provide you with the\n * custom database accessor and *lexically scoped* versions of `useLiveQuery` and `useDocument` that act against said\n * custom database.\n *\n */\nexport function useFireproof(name: string | Database = \"useFireproof\", config: ConfigOpts = {}): UseFireproof {\n  const database = typeof name === \"string\" ? fireproof(name, config) : name;\n\n  const updateHappenedRef = useRef(false);\n\n  function useDocument<T extends DocTypes>(initialDocOrFn?: UseDocumentInitialDocOrFn<T>): UseDocumentResult<T> {\n    let initialDoc: DocSet<T>;\n    if (typeof initialDocOrFn === \"function\") {\n      initialDoc = initialDocOrFn();\n    } else {\n      initialDoc = initialDocOrFn ?? ({} as T);\n    }\n\n    const originalInitialDoc = useMemo(() => deepClone({ ...initialDoc }), []);\n\n    const [doc, setDoc] = useState(initialDoc);\n\n    const refresh = useCallback(async () => {\n      const gotDoc = doc._id ? await database.get<T>(doc._id).catch(() => initialDoc) : initialDoc;\n      setDoc(gotDoc);\n    }, [doc._id]);\n\n    const save: StoreDocFn<T> = useCallback(\n      async (existingDoc) => {\n        updateHappenedRef.current = false;\n        const toSave = existingDoc ?? doc;\n        const res = await database.put(toSave);\n\n        if (!updateHappenedRef.current && !doc._id && !existingDoc) {\n          setDoc((d) => ({ ...d, _id: res.id }));\n        }\n\n        return res;\n      },\n      [doc],\n    );\n\n    const remove: DeleteDocFn<T> = useCallback(\n      async (existingDoc) => {\n        const id = existingDoc?._id ?? doc._id;\n        if (!id) throw database.logger.Error().Msg(`Document must have an _id to be removed`).AsError();\n        const gotDoc = await database.get<T>(id).catch(() => undefined);\n        if (!gotDoc) throw database.logger.Error().Str(\"id\", id).Msg(`Document not found`).AsError();\n        const res = await database.del(id);\n        setDoc(initialDoc);\n        return res;\n      },\n      [doc, initialDoc],\n    );\n\n    // New granular update methods\n    const merge = useCallback((newDoc: Partial<T>) => {\n      updateHappenedRef.current = true;\n      setDoc((prev) => ({ ...prev, ...newDoc }));\n    }, []);\n\n    const replace = useCallback((newDoc: T) => {\n      updateHappenedRef.current = true;\n      setDoc(newDoc);\n    }, []);\n\n    const reset = useCallback(() => {\n      updateHappenedRef.current = true;\n      setDoc({ ...originalInitialDoc });\n    }, [originalInitialDoc]);\n\n    // Legacy-compatible updateDoc\n    const updateDoc = useCallback(\n      (newDoc?: DocSet<T>, opts = { replace: false, reset: false }) => {\n        if (!newDoc) {\n          return opts.reset ? reset() : refresh();\n        }\n        return opts.replace ? replace(newDoc as T) : merge(newDoc);\n      },\n      [refresh, reset, replace, merge],\n    );\n\n    useEffect(() => {\n      if (!doc._id) return;\n      return database.subscribe((changes) => {\n        if (updateHappenedRef.current) {\n          return;\n        }\n        if (changes.find((c) => c._id === doc._id)) {\n          void refresh();\n        }\n      }, true);\n    }, [doc._id, refresh]);\n\n    useEffect(() => {\n      void refresh();\n    }, [refresh]);\n\n    const submit = useCallback(\n      async (e?: Event) => {\n        if (e?.preventDefault) e.preventDefault();\n        await save();\n        reset();\n      },\n      [save, reset],\n    );\n\n    // Primary Object API with both new and legacy methods\n    const apiObject = {\n      doc: { ...doc } as DocWithId<T>,\n      merge,\n      replace,\n      reset,\n      refresh,\n      save,\n      remove,\n      submit,\n    };\n\n    // Make the object properly iterable\n    const tuple = [{ ...doc }, updateDoc, save, remove, reset, refresh];\n    Object.assign(apiObject, tuple);\n    Object.defineProperty(apiObject, Symbol.iterator, {\n      enumerable: false,\n      value: function* () {\n        yield* tuple;\n      },\n    });\n\n    return apiObject as UseDocumentResult<T>;\n  }\n\n  function useLiveQuery<T extends DocTypes, K extends IndexKeyType = string, R extends DocFragment = T>(\n    mapFn: MapFn<T> | string,\n    query = {},\n    initialRows: IndexRow<K, T, R>[] = [],\n  ): LiveQueryResult<T, K, R> {\n    const [result, setResult] = useState<LiveQueryResult<T, K, R>>(() => {\n      const docs = initialRows.map((r) => r.doc).filter((r): r is DocWithId<T> => !!r);\n      return {\n        rows: initialRows,\n        docs,\n        length: docs.length,\n        map: (fn) => docs.map(fn),\n        filter: (fn) => docs.filter(fn),\n        forEach: (fn) => docs.forEach(fn),\n        [Symbol.iterator]: () => docs[Symbol.iterator](),\n      };\n    });\n\n    const queryString = useMemo(() => JSON.stringify(query), [query]);\n    const mapFnString = useMemo(() => mapFn.toString(), [mapFn]);\n\n    const refreshRows = useCallback(async () => {\n      const res = await database.query<K, T, R>(mapFn, query);\n      const docs = res.rows.map((r) => r.doc as DocWithId<T>).filter((r): r is DocWithId<T> => !!r);\n      setResult({\n        ...res,\n        docs,\n        length: docs.length,\n        map: (fn) => docs.map(fn),\n        filter: (fn) => docs.filter(fn),\n        forEach: (fn) => docs.forEach(fn),\n        [Symbol.iterator]: () => docs[Symbol.iterator](),\n      });\n    }, [mapFnString, queryString]);\n\n    useEffect(() => {\n      refreshRows(); // Initial data fetch\n      return database.subscribe(refreshRows);\n    }, [refreshRows]);\n\n    return result;\n  }\n\n  function useAllDocs<T extends DocTypes>(query: AllDocsQueryOpts = {}): AllDocsResult<T> {\n    const [result, setResult] = useState<AllDocsResult<T>>({\n      docs: [],\n    });\n\n    const queryString = useMemo(() => JSON.stringify(query), [query]);\n\n    const refreshRows = useCallback(async () => {\n      const res = await database.allDocs<T>(query);\n      setResult({ ...res, docs: res.rows.map((r) => r.value as DocWithId<T>) });\n    }, [queryString]);\n\n    useEffect(() => {\n      refreshRows(); // Initial data fetch\n      return database.subscribe(refreshRows);\n    }, [refreshRows]);\n\n    return result;\n  }\n\n  function useChanges<T extends DocTypes>(since: ClockHead = [], opts: ChangesOptions = {}): ChangesResult<T> {\n    const [result, setResult] = useState<ChangesResult<T>>({\n      docs: [],\n    });\n\n    const queryString = useMemo(() => JSON.stringify(opts), [opts]);\n\n    const refreshRows = useCallback(async () => {\n      const res = await database.changes<T>(since, opts);\n      setResult({ ...res, docs: res.rows.map((r) => r.value as DocWithId<T>) });\n    }, [since, queryString]);\n\n    useEffect(() => {\n      refreshRows(); // Initial data fetch\n      return database.subscribe(refreshRows);\n    }, [refreshRows]);\n\n    return result;\n  }\n\n  return { database, useLiveQuery, useDocument, useAllDocs, useChanges };\n}\n","import { Database, DocTypes, DocWithId } from \"@fireproof/core\";\n\nimport { UseDocument, UseDocumentResult, useFireproof } from \"./useFireproof.js\";\n\nexport interface TLUseDocument {\n  <T extends DocTypes>(initialDoc: DocWithId<T>): UseDocumentResult<T>;\n  database: Database;\n}\n\nfunction topLevelUseDocument(...args: Parameters<UseDocument>) {\n  const { useDocument, database } = useFireproof();\n  (topLevelUseDocument as TLUseDocument).database = database;\n  return useDocument(...args);\n}\n\n/**\n * ## Summary\n *\n * React hook that provides the ability to create new Fireproof documents. The creation occurs when\n * you do not pass in an `_id` as part of your initial document -- the database will assign a new one when\n * you call the provided `save` handler This uses the default database named `useFireproof` under the hood which you can also\n * access via the `database` accessor.\n *\n * ## Usage\n *\n * ```tsx\n * const [todo, setTodo, saveTodo] = useDocument(() => ({\n *   text: '',\n *   date: Date.now(),\n *   completed: false\n * }))\n *\n * const [doc, setDoc, saveDoc] = useDocument(() => ({\n *   _id: `${props.customerId}-profile`, // you can imagine `customerId` as a prop passed in\n *   name: \"\",\n *   company: \"\",\n *   startedAt: Date.now()\n * }))\n *\n * const database = useDocument.database; // underlying \"useFireproof\" database accessor\n * ```\n *\n * ## Overview\n * Changes made via remote sync peers, or other members of your cloud replica group will appear automatically\n * when you use the `useLiveQuery` and `useDocument` APIs. By default, Fireproof stores data in the browser's\n * local storage.\n */\nexport const useDocument = topLevelUseDocument as TLUseDocument;\n","import { Database, DocFragment, DocTypes, IndexKeyType } from \"@fireproof/core\";\n\nimport { LiveQueryResult, useFireproof, UseLiveQuery } from \"./useFireproof.js\";\n\nexport interface TLUseLiveQuery {\n  <T extends DocTypes, K extends IndexKeyType, R extends DocFragment = T>(\n    ...args: Parameters<UseLiveQuery>\n  ): LiveQueryResult<T, K, R>;\n  database: Database;\n}\n\nfunction topLevelUseLiveQuery(...args: Parameters<UseLiveQuery>) {\n  const { useLiveQuery, database } = useFireproof();\n  (topLevelUseLiveQuery as TLUseLiveQuery).database = database;\n  return useLiveQuery(...args);\n}\n\n/**\n * ## Summary\n * React hook that provides access to live query results, enabling real-time updates in your app. This uses\n * the default database named \"useFireproof\" under the hood which you can also access via the `database` accessor.\n *\n * ## Usage\n * ```tsx\n * const results = useLiveQuery(\"date\"); // using string\n * const results = useLiveQuery((doc) => doc.date)); // using map function\n * const database = useLiveQuery.database; // underlying \"useFireproof\" database accessor\n * ```\n *\n * ## Overview\n * Changes made via remote sync peers, or other members of your cloud replica group will appear automatically\n * when you use the `useLiveQuery` and `useDocument` APIs. By default, Fireproof stores data in the browser's\n * local storage.\n */\nexport const useLiveQuery = topLevelUseLiveQuery as TLUseLiveQuery;\n","import { Database, DocTypes } from \"@fireproof/core\";\n\nimport { AllDocsResult, useFireproof, UseAllDocs } from \"./useFireproof.js\";\n\nexport interface TLUseAllDocs {\n  <T extends DocTypes>(...args: Parameters<UseAllDocs>): AllDocsResult<T>;\n  database: Database;\n}\n\nfunction topLevelUseAllDocs(...args: Parameters<UseAllDocs>) {\n  const { useAllDocs, database } = useFireproof();\n  (topLevelUseAllDocs as TLUseAllDocs).database = database;\n  return useAllDocs(...args);\n}\n\n/**\n * ## Summary\n * React hook that provides access to all documents in the database, sorted by `_id`.\n *\n * ## Usage\n * ```tsx\n * const result = useAllDocs({ limit: 10, descending: true }); // with options\n * const result = useAllDocs(); // without options\n * const database = useAllDocs.database; // underlying \"useFireproof\" database accessor\n * ```\n *\n * ## Overview\n * Changes made via remote sync peers, or other members of your cloud replica group will appear automatically\n * when you use the `useAllDocs` and `useDocument` APIs. By default, Fireproof stores data in the browser's\n * local storage.\n */\nexport const useAllDocs = topLevelUseAllDocs as TLUseAllDocs;\n","import { Database, DocTypes } from \"@fireproof/core\";\n\nimport { ChangesResult, useFireproof, UseChanges } from \"./useFireproof.js\";\n\nexport interface TLUseChanges {\n  <T extends DocTypes>(...args: Parameters<UseChanges>): ChangesResult<T>;\n  database: Database;\n}\n\nfunction topLevelUseChanges(...args: Parameters<UseChanges>) {\n  const { useChanges, database } = useFireproof();\n  (topLevelUseChanges as TLUseChanges).database = database;\n  return useChanges(...args);\n}\n\n/**\n * ## Summary\n * React hook that provides access to all new documents in the database added since the last time the changes was called\n *\n * ## Usage\n * ```tsx\n * const result = useChanges(prevresult.clock,{limit:10}); // with options\n * const result = useChanges(); // without options\n * const database = useChanges.database; // underlying \"useFireproof\" database accessor\n * ```\n *\n * ## Overview\n * Changes made via remote sync peers, or other members of your cloud replica group will appear automatically\n * when you use the `useAllDocs`, `useChanges` and `useDocument` APIs. By default, Fireproof stores data in the browser's\n * local storage.\n */\nexport const useChanges = topLevelUseChanges as TLUseChanges;\n","import React, { useState, useEffect, ImgHTMLAttributes } from \"react\";\nimport { DocFileMeta } from \"use-fireproof\";\n\nconst { URL } = window;\n\n// Union type to support both direct File objects and metadata objects\ntype FileType = File | DocFileMeta;\n\ninterface ImgFileProps extends Omit<ImgHTMLAttributes<HTMLImageElement>, \"src\"> {\n  file?: FileType;\n  /**\n   * @deprecated Use 'file' instead. This is for internal use only to support legacy code.\n   * @internal\n   */\n  meta?: FileType;\n}\n\n// Helper function to determine if the object is a File-like object\nfunction isFile(obj: FileType): obj is File {\n  return \"type\" in obj && \"size\" in obj && \"stream\" in obj && typeof obj.stream === \"function\";\n}\n\n// Helper function to determine if the object is a DocFileMeta\nfunction isFileMeta(obj: FileType): obj is DocFileMeta {\n  return \"type\" in obj && \"size\" in obj && \"file\" in obj && typeof obj.file === \"function\";\n}\n\nexport function ImgFile({ file, meta, ...imgProps }: ImgFileProps) {\n  const [imgDataUrl, setImgDataUrl] = useState(\"\");\n\n  // Use meta as fallback if file is not provided (for backward compatibility)\n  const fileData = file || meta;\n\n  useEffect(() => {\n    if (!fileData) return;\n\n    const loadFile = async () => {\n      let fileObj: File | null = null;\n      let fileType = \"\";\n\n      switch (true) {\n        case isFile(fileData):\n          fileObj = fileData;\n          fileType = fileData.type;\n          break;\n        case isFileMeta(fileData):\n          fileType = fileData.type;\n          fileObj = (await fileData.file?.()) || null;\n          break;\n      }\n\n      if (fileObj && /image/.test(fileType)) {\n        const src = URL.createObjectURL(fileObj);\n        setImgDataUrl(src);\n        return () => URL.revokeObjectURL(src);\n      }\n    };\n\n    let isMounted = true;\n    let cleanup: (() => void) | undefined;\n\n    loadFile().then((result) => {\n      if (isMounted) {\n        cleanup = result;\n      } else if (result) {\n        result();\n      }\n    });\n\n    return () => {\n      isMounted = false;\n      if (cleanup) cleanup();\n    };\n  }, [fileData]);\n\n  return imgDataUrl\n    ? React.createElement(\"img\", {\n        src: imgDataUrl,\n        ...imgProps,\n      })\n    : null;\n}\n\nexport default ImgFile;\n"],"mappings":"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","names":["useDocument","useLiveQuery","useAllDocs","useChanges","useDocument","useLiveQuery","useAllDocs","useChanges","useState","useEffect"]}