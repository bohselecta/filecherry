{"version":3,"sources":["../../src/database.ts","../../src/write-queue.ts","../../src/crdt.ts","../../src/runtime/wait-pr-multiformats/block.ts","../../src/crdt-helpers.ts","../../src/blockstore/index.ts","../../src/blockstore/types.ts","../../src/blockstore/store-factory.ts","../../src/runtime/files.ts","../../src/blockstore/store.ts","../../src/types.ts","../../src/utils.ts","../../src/blockstore/loader.ts","../../src/blockstore/loader-helpers.ts","../../src/blockstore/transaction.ts","../../src/blockstore/commit-queue.ts","../../src/runtime/key-bag.ts","../../src/blockstore/commitor.ts","../../src/blockstore/task-manager.ts","../../src/runtime/keyed-crypto.ts","../../src/blockstore/fragment-gateway.ts","../../src/blockstore/meta-key-helper.ts","../../src/blockstore/store-remote.ts","../../src/blockstore/connection-base.ts","../../src/indexer-helpers.ts","../../src/indexer.ts","../../src/crdt-clock.ts","../../src/apply-head-queue.ts","../../src/runtime/index.ts","../../src/runtime/gateways/file/node/utils.ts","../../src/runtime/wait-pr-multiformats/index.ts","../../src/runtime/wait-pr-multiformats/codec-interface.ts","../../src/runtime/gateways/file/version.ts","../../src/runtime/gateways/indexdb/version.ts","../../src/version.ts"],"sourcesContent":["import { Logger, ResolveOnce } from \"@adviser/cement\";\n\nimport { WriteQueue, writeQueue } from \"./write-queue.js\";\nimport { CRDT } from \"./crdt.js\";\nimport { index } from \"./indexer.js\";\nimport type {\n  DocUpdate,\n  ClockHead,\n  ConfigOpts,\n  MapFn,\n  QueryOpts,\n  ChangesOptions,\n  DocSet,\n  DocWithId,\n  IndexKeyType,\n  ListenerFn,\n  DocResponse,\n  ChangesResponse,\n  DocTypes,\n  IndexRows,\n  DocFragment,\n  ChangesResponseRow,\n  CRDTMeta,\n  AllDocsQueryOpts,\n  AllDocsResponse,\n  SuperThis,\n} from \"./types.js\";\nimport { BaseBlockstore, Connectable } from \"./blockstore/index.js\";\nimport { ensureLogger, ensureSuperThis, NotFoundError } from \"./utils.js\";\n\nexport class Database<DT extends DocTypes = NonNullable<unknown>> implements Connectable {\n  static databases: Map<string, Database> = new Map<string, Database>();\n\n  readonly name?: string;\n  readonly opts: ConfigOpts = {};\n\n  _listening = false;\n  readonly _listeners: Set<ListenerFn<DT>> = new Set<ListenerFn<DT>>();\n  readonly _noupdate_listeners: Set<ListenerFn<DT>> = new Set<ListenerFn<DT>>();\n  readonly _crdt: CRDT<DT>;\n  readonly _writeQueue: WriteQueue<DT>;\n  readonly blockstore: BaseBlockstore;\n\n  /**\n   * Close the database and release resources\n   */\n  async close() {\n    await this.ready();\n    await this._crdt.close();\n    await this.blockstore.close();\n  }\n\n  /**\n   * Destroy the database and release all resources\n   */\n  async destroy() {\n    await this.ready();\n    await this._crdt.destroy();\n    await this.blockstore.destroy();\n  }\n\n  readonly _ready: ResolveOnce<void> = new ResolveOnce<void>();\n  async ready(): Promise<void> {\n    return this._ready.once(async () => {\n      await this.sthis.start();\n      await this._crdt.ready();\n      await this.blockstore.ready();\n    });\n  }\n\n  readonly logger: Logger;\n  readonly sthis: SuperThis;\n\n  constructor(name?: string, opts?: ConfigOpts) {\n    this.name = name;\n    this.opts = opts || this.opts;\n    this.sthis = ensureSuperThis(this.opts);\n    this.logger = ensureLogger(this.sthis, \"Database\");\n    // this.logger.SetDebug(\"Database\")\n    this._crdt = new CRDT(this.sthis, name, this.opts);\n    this.blockstore = this._crdt.blockstore; // for connector compatibility\n    this._writeQueue = writeQueue(async (updates: DocUpdate<DT>[]) => {\n      return await this._crdt.bulk(updates);\n    }); //, Infinity)\n    this._crdt.clock.onTock(() => {\n      this._no_update_notify();\n    });\n  }\n\n  /**\n   * Get a document from the database\n   * @param id - the document id\n   * @returns the document with the _id\n   * @throws NotFoundError if the document is not found\n   */\n  async get<T extends DocTypes>(id: string): Promise<DocWithId<T>> {\n    if (!id) throw this.logger.Error().Str(\"db\", this.name).Msg(`Doc id is required`).AsError();\n\n    await this.ready();\n    this.logger.Debug().Str(\"id\", id).Msg(\"get\");\n    const got = await this._crdt.get(id).catch((e) => {\n      throw new NotFoundError(`Not found: ${id} - ${e.message}`);\n    });\n    if (!got) throw new NotFoundError(`Not found: ${id}`);\n    const { doc } = got;\n    return { ...(doc as unknown as DocWithId<T>), _id: id };\n  }\n\n  /**\n   * Put a document from the database\n   * @param doc - the document to put\n   * @returns add DocResponse with the id and clock\n   */\n  async put<T extends DocTypes>(doc: DocSet<T>): Promise<DocResponse> {\n    await this.ready();\n    this.logger.Debug().Str(\"id\", doc._id).Msg(\"put\");\n    const { _id, ...value } = doc;\n    const docId = _id || this.sthis.timeOrderedNextId().str;\n    const result = (await this._writeQueue.push({\n      id: docId,\n      value: {\n        ...(value as unknown as DocSet<DT>),\n        _id: docId,\n      },\n    })) as CRDTMeta;\n    return { id: docId, clock: result?.head, name: this.name } as DocResponse;\n  }\n\n  /**\n   * delete a document from the database\n   * @param id Document id\n   * @returns DocResponse with the id and clock\n   */\n\n  async del(id: string): Promise<DocResponse> {\n    await this.ready();\n    this.logger.Debug().Str(\"id\", id).Msg(\"del\");\n    const result = (await this._writeQueue.push({ id: id, del: true })) as CRDTMeta;\n    return { id, clock: result?.head, name: this.name } as DocResponse;\n  }\n\n  async changes<T extends DocTypes>(since: ClockHead = [], opts: ChangesOptions = {}): Promise<ChangesResponse<T>> {\n    await this.ready();\n    this.logger.Debug().Any(\"since\", since).Any(\"opts\", opts).Msg(\"changes\");\n    const { result, head } = await this._crdt.changes(since, opts);\n    const rows: ChangesResponseRow<T>[] = result.map(({ id: key, value, del, clock }) => ({\n      key,\n      value: (del ? { _id: key, _deleted: true } : { _id: key, ...value }) as DocWithId<T>,\n      clock,\n    }));\n    return { rows, clock: head, name: this.name };\n  }\n\n  async allDocs<T extends DocTypes>(opts: AllDocsQueryOpts = {}): Promise<AllDocsResponse<T>> {\n    await this.ready();\n    void opts;\n    this.logger.Debug().Msg(\"allDocs\");\n    const { result, head } = await this._crdt.allDocs();\n    const rows = result.map(({ id: key, value, del }) => ({\n      key,\n      value: (del ? { _id: key, _deleted: true } : { _id: key, ...value }) as DocWithId<T>,\n    }));\n    return { rows, clock: head, name: this.name };\n  }\n\n  async allDocuments<T extends DocTypes>(): Promise<{\n    rows: {\n      key: string;\n      value: DocWithId<T>;\n    }[];\n    clock: ClockHead;\n  }> {\n    return this.allDocs<T>();\n  }\n\n  subscribe<T extends DocTypes>(listener: ListenerFn<T>, updates?: boolean): () => void {\n    this.logger.Debug().Bool(\"updates\", updates).Msg(\"subscribe\");\n    if (updates) {\n      if (!this._listening) {\n        this._listening = true;\n        this._crdt.clock.onTick((updates: DocUpdate<NonNullable<unknown>>[]) => {\n          void this._notify(updates);\n        });\n      }\n      this._listeners.add(listener as ListenerFn<NonNullable<unknown>>);\n      return () => {\n        this._listeners.delete(listener as ListenerFn<NonNullable<unknown>>);\n      };\n    } else {\n      this._noupdate_listeners.add(listener as ListenerFn<NonNullable<unknown>>);\n      return () => {\n        this._noupdate_listeners.delete(listener as ListenerFn<NonNullable<unknown>>);\n      };\n    }\n  }\n\n  // todo if we add this onto dbs in fireproof.ts then we can make index.ts a separate package\n  async query<K extends IndexKeyType, T extends DocTypes, R extends DocFragment = T>(\n    field: string | MapFn<T>,\n    opts: QueryOpts<K> = {},\n  ): Promise<IndexRows<K, T, R>> {\n    await this.ready();\n    this.logger.Debug().Any(\"field\", field).Any(\"opts\", opts).Msg(\"query\");\n    const _crdt = this._crdt as unknown as CRDT<T>;\n    const idx =\n      typeof field === \"string\"\n        ? index<K, T, R>(this.sthis, { _crdt }, field)\n        : index<K, T, R>(this.sthis, { _crdt }, makeName(field.toString()), field);\n    return await idx.query(opts);\n  }\n\n  async compact() {\n    await this.ready();\n    await this._crdt.compact();\n  }\n\n  async _notify(updates: DocUpdate<NonNullable<unknown>>[]) {\n    await this.ready();\n    if (this._listeners.size) {\n      const docs: DocWithId<NonNullable<unknown>>[] = updates.map(({ id, value }) => ({ ...value, _id: id }));\n      for (const listener of this._listeners) {\n        await (async () => await listener(docs as DocWithId<DT>[]))().catch((e: Error) => {\n          this.logger.Error().Err(e).Msg(\"subscriber error\");\n        });\n      }\n    }\n  }\n\n  async _no_update_notify() {\n    await this.ready();\n    if (this._noupdate_listeners.size) {\n      for (const listener of this._noupdate_listeners) {\n        await (async () => await listener([]))().catch((e: Error) => {\n          this.logger.Error().Err(e).Msg(\"subscriber error\");\n        });\n      }\n    }\n  }\n}\n\nfunction toSortedArray(set?: Record<string, unknown>): Record<string, unknown>[] {\n  if (!set) return [];\n  return Object.entries(set)\n    .sort(([a], [b]) => a.localeCompare(b))\n    .map(([k, v]) => ({ [k]: v }));\n}\n\nexport function fireproof(name: string, opts?: ConfigOpts): Database {\n  const key = JSON.stringify(\n    toSortedArray({\n      name,\n      stores: toSortedArray(opts?.store?.stores),\n    }),\n  );\n  let db = Database.databases.get(key);\n  if (!db) {\n    db = new Database(name, opts);\n    Database.databases.set(key, db);\n  }\n  return db;\n}\n\nfunction makeName(fnString: string) {\n  const regex = /\\(([^,()]+,\\s*[^,()]+|\\[[^\\]]+\\],\\s*[^,()]+)\\)/g;\n  let found: RegExpExecArray | null = null;\n  const matches = Array.from(fnString.matchAll(regex), (match) => match[1].trim());\n  if (matches.length === 0) {\n    found = /=>\\s*{?\\s*([^{}]+)\\s*}?/.exec(fnString);\n    if (found && found[1].includes(\"return\")) {\n      found = null;\n    }\n  }\n  if (!found) {\n    return fnString;\n  } else {\n    // it's a consise arrow function, match everything after the arrow\n    return found[1];\n  }\n}\n","import { DocTypes, MetaType, DocUpdate } from \"./types.js\";\n\ntype WorkerFunction<T extends DocTypes> = (tasks: DocUpdate<T>[]) => Promise<MetaType>;\n\nexport interface WriteQueue<T extends DocTypes> {\n  push(task: DocUpdate<T>): Promise<MetaType>;\n}\n\ninterface WriteQueueItem<T extends DocTypes> {\n  readonly task: DocUpdate<T>;\n  resolve(result: MetaType): void;\n  reject(error: Error): void;\n}\n\nexport function writeQueue<T extends DocTypes>(worker: WorkerFunction<T>, payload = Infinity, unbounded = false): WriteQueue<T> {\n  const queue: WriteQueueItem<T>[] = [];\n  let isProcessing = false;\n\n  async function process() {\n    if (isProcessing || queue.length === 0) return;\n    isProcessing = true;\n\n    const tasksToProcess = queue.splice(0, payload);\n    const updates = tasksToProcess.map((item) => item.task);\n\n    if (unbounded) {\n      // Run all updates in parallel and resolve/reject them individually\n      const promises = updates.map(async (update, index) => {\n        try {\n          const result = await worker([update]);\n          tasksToProcess[index].resolve(result);\n        } catch (error) {\n          tasksToProcess[index].reject(error as Error);\n        }\n      });\n\n      await Promise.all(promises);\n    } else {\n      // Original logic: Run updates in a batch and resolve/reject them together\n      try {\n        const result = await worker(updates);\n        tasksToProcess.forEach((task) => task.resolve(result));\n      } catch (error) {\n        tasksToProcess.forEach((task) => task.reject(error as Error));\n      }\n    }\n\n    isProcessing = false;\n    void process();\n  }\n\n  return {\n    push(task: DocUpdate<T>): Promise<MetaType> {\n      return new Promise<MetaType>((resolve, reject) => {\n        queue.push({ task, resolve, reject });\n        void process();\n      });\n    },\n  };\n}\n","import { Block } from \"multiformats\";\nimport { Logger, ResolveOnce } from \"@adviser/cement\";\n\nimport {\n  EncryptedBlockstore,\n  type TransactionMeta,\n  type CarTransaction,\n  BaseBlockstore,\n  CompactFetcher,\n} from \"./blockstore/index.js\";\nimport {\n  clockChangesSince,\n  sanitizeDocumentFields,\n  applyBulkUpdateToCrdt,\n  getValueFromCrdt,\n  readFiles,\n  getAllEntries,\n  clockVis,\n  getBlock,\n  doCompact,\n} from \"./crdt-helpers.js\";\nimport type {\n  DocUpdate,\n  CRDTMeta,\n  ClockHead,\n  ConfigOpts,\n  ChangesOptions,\n  IdxMetaMap,\n  DocValue,\n  IndexKeyType,\n  DocWithId,\n  DocTypes,\n  Falsy,\n  SuperThis,\n} from \"./types.js\";\nimport { index, type Index } from \"./indexer.js\";\nimport { CRDTClock } from \"./crdt-clock.js\";\nimport { blockstoreFactory } from \"./blockstore/transaction.js\";\nimport { ensureLogger } from \"./utils.js\";\n\nexport class CRDT<T extends DocTypes> {\n  readonly name?: string;\n  readonly opts: ConfigOpts;\n\n  readonly blockstore: BaseBlockstore;\n  readonly indexBlockstore: BaseBlockstore;\n  readonly indexers: Map<string, Index<IndexKeyType, NonNullable<unknown>>> = new Map<\n    string,\n    Index<IndexKeyType, NonNullable<unknown>>\n  >();\n  readonly clock: CRDTClock<T>;\n\n  readonly logger: Logger;\n  readonly sthis: SuperThis;\n\n  constructor(sthis: SuperThis, name?: string, opts: ConfigOpts = {}) {\n    this.sthis = sthis;\n    this.name = name;\n    this.logger = ensureLogger(sthis, \"CRDT\");\n    this.opts = opts;\n    this.blockstore = blockstoreFactory(sthis, {\n      name: name,\n      applyMeta: async (meta: TransactionMeta) => {\n        const crdtMeta = meta as CRDTMeta;\n        if (!crdtMeta.head) throw this.logger.Error().Msg(\"missing head\").AsError();\n        await this.clock.applyHead(crdtMeta.head, []);\n      },\n      compact: async (blocks: CompactFetcher) => {\n        await doCompact(blocks, this.clock.head, this.logger);\n        return { head: this.clock.head } as TransactionMeta;\n      },\n      autoCompact: this.opts.autoCompact || 100,\n      store: { ...this.opts.store, isIndex: undefined },\n      public: this.opts.public,\n      meta: this.opts.meta,\n      threshold: this.opts.threshold,\n    });\n    this.indexBlockstore = blockstoreFactory(sthis, {\n      name: name,\n      applyMeta: async (meta: TransactionMeta) => {\n        const idxCarMeta = meta as IdxMetaMap;\n        if (!idxCarMeta.indexes) throw this.logger.Error().Msg(\"missing indexes\").AsError();\n        for (const [name, idx] of Object.entries(idxCarMeta.indexes)) {\n          index(this.sthis, { _crdt: this }, name, undefined, idx);\n        }\n      },\n      store: { ...this.opts.store, isIndex: this.opts.store?.isIndex || \"idx\" },\n      public: this.opts.public,\n    });\n    this.clock = new CRDTClock<T>(this.blockstore);\n    this.clock.onZoom(() => {\n      for (const idx of this.indexers.values()) {\n        idx._resetIndex();\n      }\n    });\n  }\n\n  async bulk(updates: DocUpdate<T>[]): Promise<CRDTMeta> {\n    await this.ready();\n    const prevHead = [...this.clock.head];\n    updates = updates.map((dupdate: DocUpdate<T>) => ({\n      ...dupdate,\n      value: sanitizeDocumentFields(dupdate.value),\n    }));\n\n    const done = await this.blockstore.transaction<CRDTMeta>(async (blocks: CarTransaction): Promise<CRDTMeta> => {\n      const { head } = await applyBulkUpdateToCrdt<T>(\n        this.blockstore.ebOpts.storeRuntime,\n        blocks,\n        this.clock.head,\n        updates,\n        this.logger,\n      );\n      updates = updates.map((dupdate: DocUpdate<T>) => {\n        // if (!dupdate.value) throw new Error(\"missing value\");\n        readFiles(this.blockstore, { doc: dupdate.value as DocWithId<T> });\n        return dupdate;\n      });\n      return { head };\n    });\n    await this.clock.applyHead(done.meta.head, prevHead, updates);\n    return done.meta;\n  }\n\n  readonly onceReady: ResolveOnce<void> = new ResolveOnce<void>();\n  async ready(): Promise<void> {\n    return this.onceReady.once(async () => {\n      try {\n        // await this.blockstore.ready();\n        // await this.indexBlockstore.ready();\n        // await this.clock.ready();\n        await Promise.all([this.blockstore.ready(), this.indexBlockstore.ready(), this.clock.ready()]);\n      } catch (e) {\n        throw this.logger.Error().Err(e).Msg(`CRDT is not ready`).AsError();\n      }\n    });\n  }\n\n  async close(): Promise<void> {\n    await Promise.all([this.blockstore.close(), this.indexBlockstore.close(), this.clock.close()]);\n  }\n\n  async destroy(): Promise<void> {\n    await Promise.all([this.blockstore.destroy(), this.indexBlockstore.destroy()]);\n  }\n\n  // if (snap) await this.clock.applyHead(crdtMeta.head, this.clock.head)\n\n  async allDocs(): Promise<{ result: DocUpdate<T>[]; head: ClockHead }> {\n    await this.ready();\n    const result: DocUpdate<T>[] = [];\n    for await (const entry of getAllEntries<T>(this.blockstore, this.clock.head, this.logger)) {\n      result.push(entry);\n    }\n    return { result, head: this.clock.head };\n  }\n\n  async vis(): Promise<string> {\n    await this.ready();\n    const txt: string[] = [];\n    for await (const line of clockVis(this.blockstore, this.clock.head)) {\n      txt.push(line);\n    }\n    return txt.join(\"\\n\");\n  }\n\n  async getBlock(cidString: string): Promise<Block> {\n    await this.ready();\n    return await getBlock(this.blockstore, cidString);\n  }\n\n  async get(key: string): Promise<DocValue<T> | Falsy> {\n    await this.ready();\n    const result = await getValueFromCrdt<T>(this.blockstore, this.clock.head, key, this.logger);\n    if (result.del) return undefined;\n    return result;\n  }\n\n  async changes(\n    since: ClockHead = [],\n    opts: ChangesOptions = {},\n  ): Promise<{\n    result: DocUpdate<T>[];\n    head: ClockHead;\n  }> {\n    await this.ready();\n    return await clockChangesSince<T>(this.blockstore, this.clock.head, since, opts, this.logger);\n  }\n\n  async compact(): Promise<void> {\n    const blocks = this.blockstore as EncryptedBlockstore;\n    return await blocks.compact();\n  }\n}\n","// this enable async codec\n// it should be gone if this in multiformats is merged:\n// https://github.com/multiformats/js-multiformats/pull/305\nimport { bytes as binary, CID, MultihashHasher, BlockView, ByteView, Version, Link } from \"multiformats\";\nimport { Block as mfBlock } from \"multiformats/block\";\nimport { BlockDecoder, BlockEncoder } from \"./codec-interface.js\";\n\n// export type Block<T, C extends number, A extends number, V extends Version> = mfBlock<T, C, A, V>\n\nexport const Block = mfBlock;\n\ninterface DecodeInput<T, Code extends number, Alg extends number> {\n  bytes: ByteView<T>;\n  codec: BlockDecoder<Code, T>;\n  hasher: MultihashHasher<Alg>;\n}\n\nexport async function decode<T, Code extends number, Alg extends number>({\n  bytes,\n  codec,\n  hasher,\n}: DecodeInput<T, Code, Alg>): Promise<BlockView<T, Code, Alg>> {\n  if (bytes == null) throw new Error('Missing required argument \"bytes\"');\n  if (codec == null || hasher == null) throw new Error(\"Missing required argument: codec or hasher\");\n\n  const value = await Promise.resolve(codec.decode(bytes));\n  const hash = await hasher.digest(bytes);\n  const cid = CID.create(1, codec.code, hash) as CID<T, Code, Alg, 1>;\n\n  return new mfBlock({ value, bytes, cid });\n}\n\ninterface EncodeInput<T, Code extends number, Alg extends number> {\n  value: T;\n  codec: BlockEncoder<Code, T>;\n  hasher: MultihashHasher<Alg>;\n}\n\nexport async function encode<T, Code extends number, Alg extends number>({\n  value,\n  codec,\n  hasher,\n}: EncodeInput<T, Code, Alg>): Promise<BlockView<T, Code, Alg>> {\n  if (typeof value === \"undefined\") throw new Error('Missing required argument \"value\"');\n  if (codec == null || hasher == null) throw new Error(\"Missing required argument: codec or hasher\");\n\n  const bytes = await Promise.resolve(codec.encode(value));\n  const hash = await hasher.digest(bytes);\n  const cid = CID.create(1, codec.code, hash) as CID<T, Code, Alg, 1>;\n\n  return new mfBlock({ value, bytes, cid });\n}\n\ninterface CreateInput<T, Code extends number, Alg extends number, V extends Version> {\n  bytes: ByteView<T>;\n  cid: Link<T, Code, Alg, V>;\n  hasher: MultihashHasher<Alg>;\n  codec: BlockDecoder<Code, T>;\n}\n\nexport async function create<T, Code extends number, Alg extends number, V extends Version>({\n  bytes,\n  cid,\n  hasher,\n  codec,\n}: CreateInput<T, Code, Alg, V>): Promise<BlockView<T, Code, Alg, V>> {\n  if (bytes == null) throw new Error('Missing required argument \"bytes\"');\n  if (hasher == null) throw new Error('Missing required argument \"hasher\"');\n  const value = await Promise.resolve(codec.decode(bytes));\n  const hash = await hasher.digest(bytes);\n  if (!binary.equals(cid.multihash.bytes, hash.bytes)) {\n    throw new Error(\"CID hash does not match bytes\");\n  }\n\n  return createUnsafe({\n    bytes,\n    cid,\n    value,\n    codec,\n  });\n}\n\ntype CreateUnsafeInput<T, Code extends number, Alg extends number, V extends Version> =\n  | {\n      cid: Link<T, Code, Alg, V>;\n      value: T;\n      codec?: BlockDecoder<Code, T>;\n      bytes: ByteView<T>;\n    }\n  | {\n      cid: Link<T, Code, Alg, V>;\n      value?: undefined;\n      codec: BlockDecoder<Code, T>;\n      bytes: ByteView<T>;\n    };\n\n/**\n * @template T - Logical type of the data encoded in the block\n * @template Code - multicodec code corresponding to codec used to encode the block\n * @template Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template V - CID version\n */\nexport async function createUnsafe<T, Code extends number, Alg extends number, V extends Version>({\n  bytes,\n  cid,\n  value: maybeValue,\n  codec,\n}: CreateUnsafeInput<T, Code, Alg, V>): Promise<BlockView<T, Code, Alg, V>> {\n  const value = await Promise.resolve(maybeValue !== undefined ? maybeValue : codec?.decode(bytes));\n\n  if (value === undefined) throw new Error('Missing required argument, must either provide \"value\" or \"codec\"');\n\n  return new Block({\n    cid: cid as CID<T, Code, Alg, V>,\n    bytes,\n    value,\n  });\n}\n","import { encode, decode, Block } from \"./runtime/wait-pr-multiformats/block.js\";\nimport { parse } from \"multiformats/link\";\nimport { sha256 as hasher } from \"multiformats/hashes/sha2\";\nimport * as codec from \"@fireproof/vendor/@ipld/dag-cbor\";\nimport { put, get, entries, root } from \"@fireproof/vendor/@web3-storage/pail/crdt\";\nimport { EventBlockView, EventLink, Operation, PutOperation } from \"@fireproof/vendor/@web3-storage/pail/crdt/api\";\nimport { EventFetcher, vis } from \"@fireproof/vendor/@web3-storage/pail/clock\";\nimport * as Batch from \"@fireproof/vendor/@web3-storage/pail/crdt/batch\";\nimport {\n  type EncryptedBlockstore,\n  CarTransaction,\n  BlockFetcher,\n  TransactionMeta,\n  AnyLink,\n  StoreRuntime,\n  BaseBlockstore,\n  CompactFetcher,\n} from \"./blockstore/index.js\";\nimport {\n  type IndexKeyType,\n  type DocUpdate,\n  type ClockHead,\n  type DocValue,\n  type CRDTMeta,\n  type ChangesOptions,\n  type DocFileMeta,\n  type DocFiles,\n  type DocSet,\n  type DocWithId,\n  type DocTypes,\n  throwFalsy,\n} from \"./types.js\";\nimport { Result } from \"@fireproof/vendor/@web3-storage/pail/crdt/api\";\nimport { Logger } from \"@adviser/cement\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction time(tag: string) {\n  // console.time(tag)\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction timeEnd(tag: string) {\n  // console.timeEnd(tag)\n}\n\nfunction toString<K extends IndexKeyType>(key: K, logger: Logger): string {\n  switch (typeof key) {\n    case \"string\":\n    case \"number\":\n      return key.toString();\n    default:\n      throw logger.Error().Msg(\"Invalid key type\").AsError();\n  }\n}\n\nexport function sanitizeDocumentFields<T>(obj: T): T {\n  if (Array.isArray(obj)) {\n    return obj.map((item: unknown) => {\n      if (typeof item === \"object\" && item !== null) {\n        return sanitizeDocumentFields(item);\n      }\n      return item;\n    }) as T;\n  } else if (typeof obj === \"object\" && obj !== null) {\n    // Special case for Date objects - convert to ISO string\n    if (obj instanceof Date) {\n      return obj.toISOString() as unknown as T;\n    }\n\n    const typedObj = obj as Record<string, unknown>;\n    const result: Record<string, unknown> = {};\n    for (const key in typedObj) {\n      if (Object.hasOwnProperty.call(typedObj, key)) {\n        const value = typedObj[key];\n        if (value === null || (!Number.isNaN(value) && value !== undefined)) {\n          if (typeof value === \"object\" && !key.startsWith(\"_\")) {\n            // Handle Date objects in properties\n            if (value instanceof Date) {\n              result[key] = (value as Date).toISOString();\n            } else {\n              const sanitized = sanitizeDocumentFields(value);\n              result[key] = sanitized;\n            }\n          } else {\n            result[key] = value;\n          }\n        }\n      }\n    }\n    return result as T;\n  }\n  return obj;\n}\n\nexport async function applyBulkUpdateToCrdt<T extends DocTypes>(\n  store: StoreRuntime,\n  tblocks: CarTransaction,\n  head: ClockHead,\n  updates: DocUpdate<T>[],\n  logger: Logger,\n): Promise<CRDTMeta> {\n  let result: Result | null = null;\n  if (updates.length > 1) {\n    const batch = await Batch.create(tblocks, head);\n    for (const update of updates) {\n      const link = await writeDocContent(store, tblocks, update, logger);\n      await batch.put(toString(update.id, logger), link);\n    }\n    result = await batch.commit();\n  } else if (updates.length === 1) {\n    const link = await writeDocContent(store, tblocks, updates[0], logger);\n    result = await put(tblocks, head, toString(updates[0].id, logger), link);\n  }\n  if (!result) throw logger.Error().Uint64(\"updates.len\", updates.length).Msg(\"Missing result\").AsError();\n\n  if (result.event) {\n    for (const { cid, bytes } of [\n      ...result.additions,\n      // ...result.removals,\n      result.event,\n    ]) {\n      tblocks.putSync(cid, bytes);\n    }\n  }\n  return { head: result.head } as CRDTMeta;\n}\n\n// this whole thing can get pulled outside of the write queue\nasync function writeDocContent<T extends DocTypes>(\n  store: StoreRuntime,\n  blocks: CarTransaction,\n  update: DocUpdate<T>,\n  logger: Logger,\n): Promise<AnyLink> {\n  let value: Partial<DocValue<T>>;\n  if (update.del) {\n    value = { del: true };\n  } else {\n    if (!update.value) throw logger.Error().Msg(\"Missing value\").AsError();\n    await processFiles(store, blocks, update.value, logger);\n    value = { doc: update.value as DocWithId<T> };\n  }\n  const block = await encode({ value, hasher, codec });\n  blocks.putSync(block.cid, block.bytes);\n  return block.cid;\n}\n\nasync function processFiles<T extends DocTypes>(store: StoreRuntime, blocks: CarTransaction, doc: DocSet<T>, logger: Logger) {\n  if (doc._files) {\n    await processFileset(logger, store, blocks, doc._files);\n  }\n  if (doc._publicFiles) {\n    await processFileset(logger, store, blocks, doc._publicFiles /*, true*/);\n  }\n}\n\nasync function processFileset(\n  logger: Logger,\n  store: StoreRuntime,\n  blocks: CarTransaction,\n  files: DocFiles /*, publicFiles = false */,\n) {\n  const dbBlockstore = blocks.parent as EncryptedBlockstore;\n  if (!dbBlockstore.loader) throw logger.Error().Msg(\"Missing loader, database name is required\").AsError();\n  const t = new CarTransaction(dbBlockstore); // maybe this should move to encrypted-blockstore\n  const didPut = [];\n  // let totalSize = 0\n  for (const filename in files) {\n    if (File === files[filename].constructor) {\n      const file = files[filename] as File;\n\n      // totalSize += file.size\n      const { cid, blocks: fileBlocks } = await store.encodeFile(file);\n      didPut.push(filename);\n      for (const block of fileBlocks) {\n        t.putSync(block.cid, block.bytes);\n      }\n      files[filename] = { cid, type: file.type, size: file.size } as DocFileMeta;\n    } else {\n      const { cid, type, size, car } = files[filename] as DocFileMeta;\n      if (cid && type && size && car) {\n        files[filename] = { cid, type, size, car };\n      }\n    }\n  }\n\n  if (didPut.length) {\n    const car = await dbBlockstore.loader.commitFiles(\n      t,\n      { files } as unknown as TransactionMeta /* {\n      public: publicFiles,\n    } */,\n    );\n    if (car) {\n      for (const name of didPut) {\n        files[name] = { car, ...files[name] } as DocFileMeta;\n      }\n    }\n  }\n}\n\nexport async function getValueFromCrdt<T extends DocTypes>(\n  blocks: BaseBlockstore,\n  head: ClockHead,\n  key: string,\n  logger: Logger,\n): Promise<DocValue<T>> {\n  if (!head.length) throw logger.Debug().Msg(\"Getting from an empty database\").AsError();\n  const link = await get(blocks, head, key);\n  if (!link) throw logger.Error().Str(\"key\", key).Msg(`Missing key`).AsError();\n  return await getValueFromLink(blocks, link, logger);\n}\n\nexport function readFiles<T extends DocTypes>(blocks: BaseBlockstore, { doc }: Partial<DocValue<T>>) {\n  if (!doc) return;\n  if (doc._files) {\n    readFileset(blocks as EncryptedBlockstore, doc._files);\n  }\n  if (doc._publicFiles) {\n    readFileset(blocks as EncryptedBlockstore, doc._publicFiles, true);\n  }\n}\n\nfunction readFileset(blocks: EncryptedBlockstore, files: DocFiles, isPublic = false) {\n  for (const filename in files) {\n    const fileMeta = files[filename] as DocFileMeta;\n    if (fileMeta.cid) {\n      if (isPublic) {\n        fileMeta.url = `https://${fileMeta.cid.toString()}.ipfs.w3s.link/`;\n      }\n      if (fileMeta.car) {\n        fileMeta.file = async () =>\n          await blocks.ebOpts.storeRuntime.decodeFile(\n            {\n              get: async (cid: AnyLink) => {\n                return await blocks.getFile(throwFalsy(fileMeta.car), cid);\n              },\n            },\n            fileMeta.cid,\n            fileMeta,\n          );\n      }\n    }\n    files[filename] = fileMeta;\n  }\n}\n\nasync function getValueFromLink<T extends DocTypes>(blocks: BlockFetcher, link: AnyLink, logger: Logger): Promise<DocValue<T>> {\n  const block = await blocks.get(link);\n  if (!block) throw logger.Error().Str(\"link\", link.toString()).Msg(`Missing linked block`).AsError();\n  const { value } = (await decode({ bytes: block.bytes, hasher, codec })) as { value: DocValue<T> };\n  const cvalue = {\n    ...value,\n    cid: link,\n  };\n  readFiles(blocks as EncryptedBlockstore, cvalue);\n  return cvalue;\n}\n\nclass DirtyEventFetcher<T> extends EventFetcher<T> {\n  readonly logger: Logger;\n  constructor(logger: Logger, blocks: BlockFetcher) {\n    super(blocks);\n    this.logger = logger;\n  }\n  async get(link: EventLink<T>): Promise<EventBlockView<T>> {\n    try {\n      return super.get(link);\n    } catch (e) {\n      this.logger.Error().Ref(\"link\", link.toString()).Err(e).Msg(\"Missing event\");\n      return { value: undefined } as unknown as EventBlockView<T>;\n    }\n  }\n}\n\nexport async function clockChangesSince<T extends DocTypes>(\n  blocks: BlockFetcher,\n  head: ClockHead,\n  since: ClockHead,\n  opts: ChangesOptions,\n  logger: Logger,\n): Promise<{ result: DocUpdate<T>[]; head: ClockHead }> {\n  const eventsFetcher = (\n    opts.dirty ? new DirtyEventFetcher<Operation>(logger, blocks) : new EventFetcher<Operation>(blocks)\n  ) as EventFetcher<Operation>;\n  const keys = new Set<string>();\n  const updates = await gatherUpdates<T>(\n    blocks,\n    eventsFetcher,\n    head,\n    since,\n    [],\n    keys,\n    new Set<string>(),\n    opts.limit || Infinity,\n    logger,\n  );\n  return { result: updates.reverse(), head };\n}\n\nasync function gatherUpdates<T extends DocTypes>(\n  blocks: BlockFetcher,\n  eventsFetcher: EventFetcher<Operation>,\n  head: ClockHead,\n  since: ClockHead,\n  updates: DocUpdate<T>[] = [],\n  keys: Set<string>,\n  didLinks: Set<string>,\n  limit: number,\n  logger: Logger,\n): Promise<DocUpdate<T>[]> {\n  if (limit <= 0) return updates;\n  // if (Math.random() < 0.001) console.log('gatherUpdates', head.length, since.length, updates.length)\n  const sHead = head.map((l) => l.toString());\n  for (const link of since) {\n    if (sHead.includes(link.toString())) {\n      return updates;\n    }\n  }\n  for (const link of head) {\n    if (didLinks.has(link.toString())) continue;\n    didLinks.add(link.toString());\n    const { value: event } = await eventsFetcher.get(link);\n    if (!event) continue;\n    const { type } = event.data;\n    let ops = [] as PutOperation[];\n    if (type === \"batch\") {\n      ops = event.data.ops as PutOperation[];\n    } else if (type === \"put\") {\n      ops = [event.data] as PutOperation[];\n    }\n    for (let i = ops.length - 1; i >= 0; i--) {\n      const { key, value } = ops[i];\n      if (!keys.has(key)) {\n        // todo option to see all updates\n        const docValue = await getValueFromLink<T>(blocks, value, logger);\n        updates.push({ id: key, value: docValue.doc, del: docValue.del, clock: link });\n        limit--;\n        keys.add(key);\n      }\n    }\n    if (event.parents) {\n      updates = await gatherUpdates(blocks, eventsFetcher, event.parents, since, updates, keys, didLinks, limit, logger);\n    }\n  }\n  return updates;\n}\n\nexport async function* getAllEntries<T extends DocTypes>(blocks: BlockFetcher, head: ClockHead, logger: Logger) {\n  // return entries(blocks, head)\n  for await (const [key, link] of entries(blocks, head)) {\n    const docValue = await getValueFromLink(blocks, link, logger);\n    yield { id: key, value: docValue.doc, del: docValue.del } as DocUpdate<T>;\n  }\n}\n\nexport async function* clockVis(blocks: BlockFetcher, head: ClockHead) {\n  for await (const line of vis(blocks, head)) {\n    yield line;\n  }\n}\n\nlet isCompacting = false;\nexport async function doCompact(blockLog: CompactFetcher, head: ClockHead, logger: Logger) {\n  if (isCompacting) {\n    // console.log('already compacting')\n    return;\n  }\n  isCompacting = true;\n\n  time(\"compact head\");\n  for (const cid of head) {\n    const bl = await blockLog.get(cid);\n    if (!bl) throw logger.Error().Ref(\"cid\", cid).Msg(\"Missing head block\").AsError();\n  }\n  timeEnd(\"compact head\");\n\n  // for await (const blk of  blocks.entries()) {\n  //   const bl = await blockLog.get(blk.cid)\n  //   if (!bl) throw new Error('Missing tblock: ' + blk.cid.toString())\n  // }\n\n  // todo maybe remove\n  // for await (const blk of blocks.loader!.entries()) {\n  //   const bl = await blockLog.get(blk.cid)\n  //   if (!bl) throw new Error('Missing db block: ' + blk.cid.toString())\n  // }\n\n  time(\"compact all entries\");\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for await (const _entry of getAllEntries(blockLog, head, logger)) {\n    // result.push(entry)\n    // void 1;\n    continue;\n  }\n  timeEnd(\"compact all entries\");\n\n  // time(\"compact crdt entries\")\n  // for await (const [, link] of entries(blockLog, head)) {\n  //   const bl = await blockLog.get(link)\n  //   if (!bl) throw new Error('Missing entry block: ' + link.toString())\n  // }\n  // timeEnd(\"compact crdt entries\")\n\n  time(\"compact clock vis\");\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for await (const _line of vis(blockLog, head)) {\n    void 1;\n  }\n  timeEnd(\"compact clock vis\");\n\n  time(\"compact root\");\n  const result = await root(blockLog, head);\n  timeEnd(\"compact root\");\n\n  time(\"compact root blocks\");\n  for (const { cid, bytes } of [...result.additions, ...result.removals]) {\n    blockLog.loggedBlocks.putSync(cid, bytes);\n  }\n  timeEnd(\"compact root blocks\");\n\n  time(\"compact changes\");\n  await clockChangesSince(blockLog, head, [], {}, logger);\n  timeEnd(\"compact changes\");\n\n  isCompacting = false;\n}\n\nexport async function getBlock(blocks: BlockFetcher, cidString: string) {\n  const block = await blocks.get(parse(cidString));\n  if (!block) throw new Error(`Missing block ${cidString}`);\n  const { cid, value } = await decode({ bytes: block.bytes, codec, hasher });\n  return new Block({ cid, value, bytes: block.bytes });\n}\n","export * from \"./types.js\";\n\nexport * from \"./store-factory.js\";\nexport * from \"./gateway.js\";\nexport * from \"./fragment-gateway.js\";\n\nimport { type Connectable } from \"./connection-base.js\";\nexport { Connectable };\n\n// import { type CarClockHead, type DbMetaEventBlock } from \"./types.js\";\n// export { CarClockHead, DbMetaEventBlock };\n\nexport { EncryptedBlockstore, BaseBlockstore, CompactionFetcher, type BlockFetcher, CarTransaction } from \"./transaction.js\";\nexport { Loader } from \"./loader.js\";\nexport { parseCarFile } from \"./loader-helpers.js\";\nexport { ConnectionBase } from \"./connection-base.js\";\nexport { setCryptoKeyFromGatewayMetaPayload, addCryptoKeyToGatewayMetaPayload } from \"./meta-key-helper.js\";\n","import type { CID, Link, Version } from \"multiformats\";\nimport type { BlockCodec } from \"../runtime/wait-pr-multiformats/codec-interface.js\";\nimport { DocFileMeta, Falsy, StoreType, SuperThis } from \"../types.js\";\nimport { BlockFetcher, CarTransaction } from \"./transaction.js\";\nimport { Logger, Result } from \"../utils.js\";\nimport { CommitQueue } from \"./commit-queue.js\";\nimport { KeyBagOpts } from \"../runtime/key-bag.js\";\nimport { CoerceURI, CryptoRuntime, CTCryptoKey, URI } from \"@adviser/cement\";\nimport { EventBlock } from \"@fireproof/vendor/@web3-storage/pail/clock\";\nimport { TaskManager } from \"./task-manager.js\";\n\nexport type AnyLink = Link<unknown, number, number, Version>;\nexport type CarGroup = AnyLink[];\nexport type CarLog = CarGroup[];\nexport type AnyAnyLink = Link<unknown, number, number, Version>;\n\nexport type AnyLinkFn = (cid: AnyLink) => Promise<AnyBlock | undefined>;\n\nexport interface AnyBlock {\n  readonly cid: Link<unknown, number, number, Version>;\n  readonly bytes: Uint8Array;\n}\n\nexport interface CIDBlock {\n  readonly cid: CID<unknown, number, number, Version>;\n  readonly bytes: Uint8Array;\n}\n\nexport function toCIDBlock(block: AnyBlock): CIDBlock {\n  return block as CIDBlock;\n}\nexport interface AnyAnyBlock {\n  readonly cid: AnyAnyLink;\n  readonly bytes: Uint8Array;\n}\n\n// export interface EncryptOpts {\n//   readonly key: ArrayBuffer;\n//   readonly cid: AnyLink;\n//   readonly bytes: Uint8Array;\n// }\n\nexport interface IvKeyIdData {\n  readonly iv: Uint8Array;\n  readonly keyId: Uint8Array;\n  readonly data: Uint8Array;\n}\n\nexport interface IvAndBytes {\n  readonly bytes: Uint8Array;\n  readonly iv: Uint8Array;\n}\n\nexport interface BytesWithIv {\n  readonly bytes: Uint8Array;\n  readonly iv?: Uint8Array;\n}\n\n// export interface DecryptOpts {\n//   readonly key: ArrayBuffer;\n//   readonly value: IvAndBytes;\n// }\n\nexport interface AnyDecodedBlock {\n  readonly cid: AnyLink;\n  readonly bytes: Uint8Array;\n  readonly value: Uint8Array;\n}\n\nexport interface CarMakeable {\n  entries(): Iterable<AnyBlock>;\n  get(cid: AnyLink): Promise<AnyBlock | undefined>;\n}\n\nexport interface CarHeader<T> {\n  readonly cars: CarLog;\n  readonly compact: CarLog;\n  readonly meta: T;\n}\n\n// type NestedData =\n//   | Uint8Array\n//   | string\n//   | number\n//   | boolean\n//   | undefined\n//   | null\n//   | AnyLink\n//   | NestedData[]\n//   | { [key: string]: NestedData };\n\nexport interface TransactionWrapper<M extends TransactionMeta> {\n  meta: M;\n  cars?: CarGroup;\n  t: CarTransaction;\n}\n\nexport type TransactionMeta = unknown;\n//CRDTMeta | IndexTransactionMeta | FileTransactionMeta;\n\n// export interface MakeCodecCrypto {\n//   subtle: {\n//     decrypt: (algo: { name: string; iv: Uint8Array; tagLength: number }, key: CryptoKey, data: Uint8Array) => Promise<ArrayBuffer>;\n//     encrypt: (algo: { name: string; iv: Uint8Array; tagLength: number }, key: CryptoKey, data: Uint8Array) => Promise<ArrayBuffer>;\n//   };\n// }\n\n// an implementation of this Interface contains the keymaterial\n// so that the fp-core can use the decrypt and encrypt without knowing the key\nexport interface EncryptedBlock {\n  readonly value: IvAndBytes;\n}\n\nexport interface KeyMaterial {\n  readonly key: Uint8Array;\n  readonly keyStr: string;\n}\n\nexport interface KeyWithFingerPrint {\n  readonly fingerPrint: string;\n  readonly key: CTCryptoKey;\n}\n\nexport interface KeyWithFingerExtract extends KeyWithFingerPrint {\n  extract(): Promise<KeyMaterial>;\n}\n\nexport interface CodecOpts {\n  readonly ivCalc: \"random\" | \"hash\";\n  readonly noIVVerify: boolean;\n}\nexport interface KeyedCrypto {\n  readonly ivLength: number; // in bytes only 12 and 16 are allowed\n  readonly logger: Logger;\n  readonly crypto: CryptoRuntime;\n  readonly url: URI;\n  // readonly codec: BlockCodec<number, IvAndBytes>;\n  // readonly isEncrypting: boolean;\n  fingerPrint(): Promise<string>;\n  algo(iv?: Uint8Array): { name: string; iv: Uint8Array; tagLength: number };\n  codec(iv?: Uint8Array, codecOpts?: Partial<CodecOpts>): BlockCodec<number, Uint8Array>;\n  _decrypt(data: IvAndBytes): Promise<Uint8Array>;\n  _encrypt(data: BytesWithIv): Promise<Uint8Array>;\n  // encode(data: Uint8Array): Promise<Uint8Array>;\n  // decode(bytes: Uint8Array | ArrayBuffer): Promise<Uint8Array>;\n}\n\nexport interface BlobLike {\n  /**\n   * Returns a ReadableStream which yields the Blob data.\n   */\n  stream: () => ReadableStream;\n}\n\nexport interface StoreFactory {\n  makeMetaStore?: (loader: Loadable) => Promise<MetaStore>;\n  makeDataStore?: (loader: Loadable) => Promise<DataStore>;\n  makeWALStore?: (loader: Loadable) => Promise<WALStore>;\n\n  encodeFile?: (blob: BlobLike) => Promise<{ cid: AnyLink; blocks: AnyBlock[] }>;\n  decodeFile?: (blocks: unknown, cid: AnyLink, meta: DocFileMeta) => Promise<File>;\n}\n\nexport interface StoreOpts extends StoreFactory {\n  readonly isIndex?: string; // index prefix\n  readonly stores?: {\n    // string means local storage\n    // URL means schema selects the storeType\n    readonly base?: CoerceURI;\n\n    readonly meta?: CoerceURI;\n    readonly data?: CoerceURI;\n    readonly index?: CoerceURI;\n    readonly wal?: CoerceURI;\n  };\n}\n\nexport interface StoreRuntime {\n  // the factories should produce ready-to-use stores\n  // which means they have to call start() on the store\n  // to fullfill lifecycle requirements\n  // to release resources, like one database connection\n  // for all stores a refcount on close() should be used\n  makeMetaStore(loader: Loadable): Promise<MetaStore>;\n  makeDataStore(loader: Loadable): Promise<DataStore>;\n  makeWALStore(loader: Loadable): Promise<WALStore>;\n  encodeFile(blob: BlobLike): Promise<{ cid: AnyLink; blocks: AnyBlock[] }>;\n  decodeFile(blocks: unknown, cid: AnyLink, meta: DocFileMeta): Promise<File>;\n}\n\nexport interface CommitOpts {\n  readonly noLoader?: boolean;\n  readonly compact?: boolean;\n  // readonly public?: boolean;\n}\n\nexport interface DbMeta {\n  readonly cars: CarGroup;\n  key?: string;\n}\n\n// export interface UploadMetaFnParams {\n//   readonly name: string;\n//   readonly branch: string;\n// }\n\n// export type FnParamTypes = \"data\" | \"file\";\n\n// export interface UploadDataFnParams {\n//   readonly type: FnParamTypes;\n//   readonly name: string;\n//   readonly car: string;\n//   readonly size: string;\n// }\n\n// export interface DownloadDataFnParams {\n//   readonly type: FnParamTypes;\n//   readonly name: string;\n//   readonly car: string;\n// }\n\n// export interface DownloadMetaFnParams {\n//   readonly name: string;\n//   readonly branch: string;\n// }\n\nexport type LoadHandler = (dbMetas: DbMeta[]) => Promise<void>;\n\nexport interface Connection {\n  readonly loader?: Loadable;\n  readonly loaded: Promise<void>;\n  dashboardUrl?: URI;\n\n  connectMeta_X({ loader }: { loader?: Loadable }): void;\n  connectStorage_X({ loader }: { loader?: Loadable }): void;\n\n  // metaUpload(bytes: Uint8Array, params: UploadMetaFnParams): Promise<Uint8Array[] | Falsy>;\n  // dataUpload(bytes: Uint8Array, params: UploadDataFnParams, opts?: { public?: boolean }): Promise<void>;\n  // metaDownload(params: DownloadMetaFnParams): Promise<Uint8Array[] | Falsy>;\n  // dataDownload(params: DownloadDataFnParams): Promise<Uint8Array | Falsy>;\n}\n\nexport interface BaseStore {\n  readonly storeType: StoreType;\n  // readonly url: URI\n  url(): URI;\n  readonly name: string;\n  onStarted(fn: () => void): void;\n  onClosed(fn: () => void): void;\n\n  keyedCrypto(): Promise<KeyedCrypto>;\n\n  close(): Promise<Result<void>>;\n  destroy(): Promise<Result<void>>;\n  readonly ready?: () => Promise<void>;\n  start(): Promise<Result<URI>>;\n}\n\nexport interface MetaStore extends BaseStore {\n  readonly storeType: \"meta\";\n  load(branch?: string): Promise<DbMeta[] | Falsy>;\n  // branch is defaulted to \"main\"\n  save(meta: DbMeta, branch?: string): Promise<Result<void>>;\n  handleByteHeads(byteHeads: Uint8Array, branch?: string): Promise<{ eventCid: CarClockLink; dbMeta: DbMeta }[]>;\n}\n\nexport interface DataSaveOpts {\n  readonly public: boolean;\n}\n\nexport interface DataStore extends BaseStore {\n  readonly storeType: \"data\";\n  load(cid: AnyLink): Promise<AnyBlock>;\n  save(car: AnyBlock, opts?: DataSaveOpts): Promise</*AnyLink | */ void>;\n  remove(cid: AnyLink): Promise<Result<void>>;\n}\n\nexport interface WALState {\n  operations: DbMeta[];\n  noLoaderOps: DbMeta[];\n  fileOperations: {\n    readonly cid: AnyLink;\n    readonly public: boolean;\n  }[];\n}\n\nexport interface WALStore extends BaseStore {\n  readonly storeType: \"wal\";\n  ready(): Promise<void>;\n  readonly processing?: Promise<void> | undefined;\n  readonly processQueue: CommitQueue<void>;\n\n  process(): Promise<void>;\n  enqueue(dbMeta: DbMeta, opts: CommitOpts): Promise<void>;\n  enqueueFile(fileCid: AnyLink /*, publicFile?: boolean*/): Promise<void>;\n  load(): Promise<WALState | Falsy>;\n  save(state: WALState): Promise<void>;\n}\n\nexport type CompactFetcher = BlockFetcher & {\n  readonly loggedBlocks: CarTransaction;\n};\nexport type CompactFn = (blocks: CompactFetcher) => Promise<TransactionMeta>;\n\nexport type BlockstoreOpts = Partial<{\n  readonly logger: Logger;\n  readonly applyMeta: (meta: TransactionMeta, snap?: boolean) => Promise<void>;\n  readonly compact: CompactFn;\n  readonly autoCompact: number;\n  readonly crypto: CryptoRuntime;\n  readonly store: StoreOpts;\n  readonly keyBag: KeyBagOpts;\n  readonly public: boolean;\n  readonly meta: DbMeta;\n  readonly name: string;\n  readonly threshold: number;\n}>;\n\nexport interface BlockstoreRuntime {\n  readonly logger: Logger;\n  readonly applyMeta: (meta: TransactionMeta, snap?: boolean) => Promise<void>;\n  readonly compact: CompactFn;\n  readonly autoCompact: number;\n  readonly crypto: CryptoRuntime;\n  readonly store: StoreOpts;\n  readonly storeRuntime: StoreRuntime;\n  readonly keyBag: Partial<KeyBagOpts>;\n  // readonly public: boolean;\n  readonly meta?: DbMeta;\n  readonly name?: string;\n  readonly threshold: number;\n}\n\nexport interface Loadable {\n  readonly name: string; // = \"\";\n  readonly sthis: SuperThis;\n  readonly ebOpts: BlockstoreRuntime;\n  remoteCarStore?: DataStore;\n  carStore(): Promise<DataStore>;\n  carLog: CarLog; // = new Array<CarGroup>();\n  remoteMetaStore?: MetaStore;\n  remoteFileStore?: DataStore;\n  taskManager?: TaskManager;\n  ready(): Promise<void>;\n  close(): Promise<void>;\n  fileStore(): Promise<DataStore>;\n  WALStore(): Promise<WALStore>;\n  handleDbMetasFromStore(metas: DbMeta[]): Promise<void>;\n}\n\nexport type DbMetaEventBlock = EventBlock<{ dbMeta: Uint8Array }>;\nexport type CarClockLink = Link<DbMetaEventBlock, number, number, Version>;\nexport type CarClockHead = CarClockLink[];\n","import { Logger, KeyedResolvOnce, CoerceURI, URI, Result, runtimeFn } from \"@adviser/cement\";\n\nimport { decodeFile, encodeFile } from \"../runtime/files.js\";\nimport { DataStoreImpl, WALStoreImpl, MetaStoreImpl } from \"./store.js\";\nimport { Loadable, StoreOpts, StoreRuntime } from \"./types.js\";\nimport { dataDir, ensureLogger, ensureSuperLog } from \"../utils.js\";\nimport { Gateway, TestGateway } from \"./gateway.js\";\nimport { getKeyBag } from \"../runtime/key-bag.js\";\nimport { SuperThis } from \"../types.js\";\n\nfunction ensureIsIndex(url: URI, isIndex?: string): URI {\n  if (isIndex) {\n    return url.build().setParam(\"index\", isIndex).URI();\n  }\n  return url.build().delParam(\"index\").URI();\n}\n\nfunction ensureName(name: string, url: URI): URI {\n  if (!url.hasParam(\"name\")) {\n    return url.build().setParam(\"name\", name).URI();\n  }\n  return url;\n}\n\nexport interface GatewayFactoryItem {\n  readonly protocol: string;\n  readonly overrideBaseURL?: string; // if this set it overrides the defaultURL\n  readonly overrideRegistration?: boolean; // if this is set, it will override the registration\n\n  readonly gateway: (sthis: SuperThis) => Promise<Gateway>;\n  readonly test: (sthis: SuperThis) => Promise<TestGateway>;\n  // which switches between file and indexdb\n  // readonly data: (logger: Logger) => Promise<Gateway>;\n  // readonly meta: (logger: Logger) => Promise<Gateway>;\n  // readonly wal: (logger: Logger) => Promise<Gateway>;\n  // readonly test: (logger: Logger) => Promise<TestStore>;\n}\n\nconst storeFactory = new Map<string, GatewayFactoryItem>();\n\nfunction buildURL(optURL: CoerceURI, loader: Loadable): URI {\n  const storeOpts = loader.ebOpts.store;\n  const obuItem = Array.from(storeFactory.values()).find((items) => items.overrideBaseURL);\n  let obuUrl: URI | undefined;\n  if (obuItem && obuItem.overrideBaseURL) {\n    obuUrl = URI.from(obuItem.overrideBaseURL);\n  }\n  const ret = ensureIsIndex(\n    URI.from(optURL || obuUrl || dataDir(loader.sthis, loader.name, storeOpts.stores?.base)),\n    storeOpts.isIndex,\n  );\n  // console.log(\"buildURL\", storeOpts.isIndex);\n  return ret;\n}\n\ninterface GatewayReady {\n  readonly gateway: Gateway;\n  readonly test: TestGateway;\n}\nconst onceGateway = new KeyedResolvOnce<GatewayReady>();\nexport async function getGatewayFromURL(url: URI, sthis: SuperThis): Promise<GatewayReady | undefined> {\n  return onceGateway.get(url.toString()).once(async () => {\n    const item = storeFactory.get(url.protocol);\n    if (item) {\n      const ret = {\n        gateway: await item.gateway(sthis),\n        test: await item.test(sthis),\n      };\n      const res = await ret.gateway.start(url);\n      if (res.isErr()) {\n        sthis.logger.Error().Result(\"start\", res).Msg(\"start failed\");\n        return undefined;\n      }\n      return ret;\n    }\n    sthis.logger.Warn().Url(url).Msg(\"unsupported protocol\");\n    return undefined;\n  });\n}\n\nexport function registerStoreProtocol(item: GatewayFactoryItem): () => void {\n  let protocol = item.protocol;\n  if (!protocol.endsWith(\":\")) {\n    protocol += \":\";\n  }\n  if (storeFactory.has(protocol)) {\n    if (!item.overrideBaseURL && storeFactory.get(protocol) !== item) {\n      throw new Error(`we need a logger here`);\n      // const logger = ensureLogger(sthis, \"registerStoreProtocol\", { protocol });\n      // logger.Warn().Msg(`protocol ${protocol} already registered`);\n      return () => {\n        /* no-op */\n      };\n    }\n  }\n  // we need to clear the overrideBaseURL if it is set\n  if (item.overrideBaseURL) {\n    Array.from(storeFactory.values()).forEach((items) => {\n      (\n        items as {\n          overrideBaseURL?: string;\n        }\n      ).overrideBaseURL = undefined;\n    });\n  }\n  storeFactory.set(protocol, item);\n  return () => {\n    storeFactory.delete(protocol);\n  };\n}\n\n// function runStoreFactory<T>(url: URI, logger: Logger, run: (item: StoreFactoryItem) => Promise<T>): Promise<T> {\n//   // const store = url.getParam(\"store\");\n//   // if (!store) {\n//   //   throw logger.Error().Url(url).Msg(\"store not found\").AsError();\n//   // }\n//   // const key = `${url.protocol}:${store}`;\n//   const item = storeFactory.get(url.protocol);\n//   if (!item) {\n//     throw logger\n//       .Error()\n//       .Url(url.asURL())\n//       .Str(\"protocol\", url.protocol)\n//       .Any(\"keys\", Array(storeFactory.keys()))\n//       .Msg(`unsupported protocol`)\n//       .AsError();\n//   }\n//   logger.Debug().Str(\"protocol\", url.protocol).Msg(\"run\");\n//   return run(item);\n// }\n\n// const onceLoadDataGateway = new KeyedResolvOnce<Gateway>();\n// function loadDataGateway(url: URI, logger: Logger) {\n//   return onceLoadDataGateway.get(url.protocol).once(async () => {\n//     return await getGatewayFromURL(url, logger).then((item) => {\n//       if (!item) {\n//         throw logger.Error().Url(url).Msg(\"unsupported protocol or store\").AsError();\n//       }\n//       return item;\n//     });\n//   })\n// }\n\nconst onceDataStoreFactory = new KeyedResolvOnce<DataStoreImpl>();\nasync function dataStoreFactory(loader: Loadable): Promise<DataStoreImpl> {\n  const url = ensureName(loader.name, buildURL(loader.ebOpts.store.stores?.data, loader)).build().setParam(\"store\", \"data\").URI();\n  const sthis = ensureSuperLog(loader.sthis, \"dataStoreFactory\", { url: url.toString() });\n  return onceDataStoreFactory.get(url.toString()).once(async () => {\n    const gateway = await getGatewayFromURL(url, sthis);\n    if (!gateway) {\n      throw sthis.logger.Error().Url(url).Msg(\"gateway not found\").AsError();\n    }\n    const store = new DataStoreImpl(sthis, loader.name, url, {\n      gateway: gateway.gateway,\n      keybag: () =>\n        getKeyBag(loader.sthis, {\n          ...loader.ebOpts.keyBag,\n        }),\n    });\n    return store;\n  });\n}\n\n// const onceLoadMetaGateway = new KeyedResolvOnce<Gateway>();\n// function loadMetaGateway(url: URI, logger: Logger) {\n//   return onceLoadMetaGateway.get(url.protocol).once(async () => {\n//     return await getGatewayFromURL(url, logger).then((item) => {\n//       if (!item) {\n//         throw logger.Error().Url(url).Msg(\"unsupported protocol or store\").AsError();\n//       }\n//       return item;\n//     });\n//   });\n// }\n\nconst onceMetaStoreFactory = new KeyedResolvOnce<MetaStoreImpl>();\nasync function metaStoreFactory(loader: Loadable): Promise<MetaStoreImpl> {\n  const url = ensureName(loader.name, buildURL(loader.ebOpts.store.stores?.meta, loader)).build().setParam(\"store\", \"meta\").URI();\n  const sthis = ensureSuperLog(loader.sthis, \"metaStoreFactory\", { url: () => url.toString() });\n  return onceMetaStoreFactory.get(url.toString()).once(async () => {\n    sthis.logger.Debug().Str(\"protocol\", url.protocol).Msg(\"pre-protocol switch\");\n    const gateway = await getGatewayFromURL(url, sthis);\n    if (!gateway) {\n      throw sthis.logger.Error().Url(url).Msg(\"gateway not found\").AsError();\n    }\n    const store = new MetaStoreImpl(loader.sthis, loader.name, url, {\n      gateway: gateway.gateway,\n      keybag: () =>\n        getKeyBag(loader.sthis, {\n          ...loader.ebOpts.keyBag,\n        }),\n    });\n    // const ret = await store.start();\n    // if (ret.isErr()) {\n    //   throw logger.Error().Result(\"start\", ret).Msg(\"start failed\").AsError();\n    // }\n    // logger.Debug().Url(ret.Ok(), \"prepared\").Msg(\"produced\");\n    return store;\n  });\n}\n\n// const onceWalGateway = new KeyedResolvOnce<Gateway>();\n// function loadWalGateway(url: URI, logger: Logger) {\n//   return onceWalGateway.get(url.protocol).once(async () => {\n//     return await getGatewayFromURL(url, logger).then((item) => {\n//       if (!item) {\n//         throw logger.Error().Url(url).Msg(\"unsupported protocol or store\").AsError();\n//       }\n//       return item;\n//     });\n//   });\n// }\n\nconst onceRemoteWalFactory = new KeyedResolvOnce<WALStoreImpl>();\nasync function remoteWalFactory(loader: Loadable): Promise<WALStoreImpl> {\n  const url = ensureName(loader.name, buildURL(loader.ebOpts.store.stores?.wal, loader)).build().setParam(\"store\", \"wal\").URI();\n  const sthis = ensureSuperLog(loader.sthis, \"remoteWalFactory\", { url: url.toString() });\n  return onceRemoteWalFactory.get(url.toString()).once(async () => {\n    const gateway = await getGatewayFromURL(url, sthis);\n    if (!gateway) {\n      throw sthis.logger.Error().Url(url).Msg(\"gateway not found\").AsError();\n    }\n    sthis.logger.Debug().Str(\"prepared\", url.toString()).Msg(\"produced\");\n    const store = new WALStoreImpl(loader, url, {\n      gateway: gateway.gateway,\n      keybag: () =>\n        getKeyBag(loader.sthis, {\n          ...loader.ebOpts.keyBag,\n        }),\n    });\n    // const ret = await store.start();\n    // if (ret.isErr()) {\n    //   throw logger.Error().Result(\"start\", ret).Msg(\"start failed\").AsError();\n    // }\n    // logger.Debug().Url(ret.Ok(), \"prepared\").Msg(\"produced\");\n    return store;\n  });\n}\n\nexport async function testStoreFactory(url: URI, sthis: SuperThis): Promise<TestGateway> {\n  sthis = ensureSuperLog(sthis, \"testStoreFactory\");\n  const gateway = await getGatewayFromURL(url, sthis);\n  if (!gateway) {\n    throw sthis.logger.Error().Url(url).Msg(\"gateway not found\").AsError();\n  }\n  return gateway.test;\n}\n\nexport async function ensureStart<T>(store: T & { start: () => Promise<Result<URI>> }, logger: Logger): Promise<T> {\n  const ret = await store.start();\n  if (ret.isErr()) {\n    throw logger.Error().Result(\"start\", ret).Msg(\"start failed\").AsError();\n  }\n  logger.Debug().Url(ret.Ok(), \"prepared\").Msg(\"produced\");\n  return store;\n}\n\nexport function toStoreRuntime(opts: StoreOpts, sthis: SuperThis): StoreRuntime {\n  const logger = ensureLogger(sthis, \"toStoreRuntime\", {});\n  return {\n    makeMetaStore: async (loader: Loadable) => {\n      logger\n        .Debug()\n        .Str(\"fromOpts\", \"\" + !!loader.ebOpts.store.makeMetaStore)\n        .Msg(\"makeMetaStore\");\n      return ensureStart(await (loader.ebOpts.store.makeMetaStore || metaStoreFactory)(loader), logger);\n    },\n    makeDataStore: async (loader: Loadable) => {\n      logger\n        .Debug()\n        .Str(\"fromOpts\", \"\" + !!loader.ebOpts.store.makeDataStore)\n        .Msg(\"makeDataStore\");\n      return ensureStart(await (loader.ebOpts.store.makeDataStore || dataStoreFactory)(loader), logger);\n    },\n    makeWALStore: async (loader: Loadable) => {\n      logger\n        .Debug()\n        .Str(\"fromOpts\", \"\" + !!loader.ebOpts.store.makeWALStore)\n        .Msg(\"makeRemoteWAL\");\n      return ensureStart(await (loader.ebOpts.store.makeWALStore || remoteWalFactory)(loader), logger);\n    },\n\n    encodeFile: opts.encodeFile || encodeFile,\n    decodeFile: opts.decodeFile || decodeFile,\n  };\n}\n\nif (runtimeFn().isNodeIsh || runtimeFn().isDeno) {\n  registerStoreProtocol({\n    protocol: \"file:\",\n    gateway: async (sthis) => {\n      const { GatewayImpl } = await import(\"@fireproof/core/node\");\n      return new GatewayImpl(sthis);\n    },\n    test: async (sthis) => {\n      const { GatewayTestImpl } = await import(\"@fireproof/core/node\");\n      return new GatewayTestImpl(sthis);\n    },\n  });\n}\n\nif (runtimeFn().isBrowser) {\n  registerStoreProtocol({\n    protocol: \"indexdb:\",\n    gateway: async (sthis) => {\n      const { GatewayImpl } = await import(\"@fireproof/core/web\");\n      return new GatewayImpl(sthis);\n    },\n    test: async (sthis) => {\n      const { GatewayTestImpl } = await import(\"@fireproof/core/web\");\n      return new GatewayTestImpl(sthis);\n    },\n  });\n}\n","import * as UnixFS from \"@ipld/unixfs\";\nimport * as raw from \"multiformats/codecs/raw\";\nimport { withMaxChunkSize } from \"@ipld/unixfs/file/chunker/fixed\";\nimport { withWidth } from \"@ipld/unixfs/file/layout/balanced\";\n\nimport type { View } from \"@ipld/unixfs\";\nimport { DocFileMeta } from \"../types.js\";\n\nimport { exporter, ReadableStorage } from \"@fireproof/vendor/ipfs-unixfs-exporter\";\nimport { BlobLike, AnyLink, AnyBlock } from \"../blockstore/index.js\";\n\nconst queuingStrategy = UnixFS.withCapacity();\n\nconst settings = UnixFS.configure({\n  fileChunkEncoder: raw,\n  smallFileEncoder: raw,\n  chunker: withMaxChunkSize(1024 * 1024),\n  fileLayout: withWidth(1024),\n});\n\nasync function collect<T>(collectable: ReadableStream<T>): Promise<T[]> {\n  const chunks: T[] = [];\n  await collectable.pipeTo(\n    new WritableStream({\n      write(chunk) {\n        chunks.push(chunk);\n      },\n    }),\n  );\n  return chunks;\n}\n\nexport async function encodeFile(blob: BlobLike): Promise<{ cid: AnyLink; blocks: AnyBlock[] }> {\n  const readable = createFileEncoderStream(blob);\n  const blocks = await collect(readable);\n  return { cid: blocks.at(-1).cid, blocks };\n}\n\nexport async function decodeFile(blocks: unknown, cid: AnyLink, meta: DocFileMeta): Promise<File> {\n  const entry = await exporter(cid.toString(), blocks as ReadableStorage, { length: meta.size });\n  const chunks = [];\n  for await (const chunk of entry.content()) {\n    chunks.push(chunk);\n  }\n  return new File(chunks, entry.name, { type: meta.type, lastModified: 0 });\n}\n\nfunction createFileEncoderStream(blob: BlobLike) {\n  const { readable, writable } = new TransformStream({}, queuingStrategy);\n  const unixfsWriter = UnixFS.createWriter({ writable, settings });\n  const fileBuilder = new UnixFSFileBuilder(\"\", blob);\n  void (async () => {\n    await fileBuilder.finalize(unixfsWriter);\n    await unixfsWriter.close();\n  })();\n  return readable;\n}\n\nclass UnixFSFileBuilder {\n  #file;\n  readonly name: string;\n  constructor(name: string, file: BlobLike) {\n    this.name = name;\n    this.#file = file;\n  }\n\n  async finalize(writer: View) {\n    const unixfsFileWriter = UnixFS.createFileWriter(writer);\n    await this.#file.stream().pipeTo(\n      new WritableStream({\n        async write(chunk) {\n          await unixfsFileWriter.write(chunk as Uint8Array);\n        },\n      }),\n    );\n    return await unixfsFileWriter.close();\n  }\n}\n","import { format, parse, ToString } from \"@fireproof/vendor/@ipld/dag-json\";\nimport { exception2Result, Logger, ResolveOnce, Result, URI } from \"@adviser/cement\";\nimport type {\n  AnyBlock,\n  AnyLink,\n  CommitOpts,\n  DataSaveOpts,\n  DataStore,\n  DbMeta,\n  WALStore as WALStore,\n  WALState,\n  KeyedCrypto,\n  Loadable,\n  MetaStore,\n  LoadHandler,\n  CarClockHead,\n  CarClockLink,\n} from \"./types.js\";\nimport { Falsy, StoreType, SuperThis, throwFalsy } from \"../types.js\";\nimport { Gateway } from \"./gateway.js\";\nimport { ensureLogger, isNotFoundError } from \"../utils.js\";\nimport { carLogIncludesGroup } from \"./loader.js\";\nimport { CommitQueue } from \"./commit-queue.js\";\nimport { keyedCryptoFactory } from \"../runtime/keyed-crypto.js\";\nimport { KeyBag } from \"../runtime/key-bag.js\";\nimport { FragmentGateway } from \"./fragment-gateway.js\";\nimport { createDbMetaEventBlock, decodeGatewayMetaBytesToDbMeta, encodeEventsWithParents } from \"./meta-key-helper.js\";\nimport pRetry from \"p-retry\";\nimport pMap from \"p-map\";\n\nfunction guardVersion(url: URI): Result<URI> {\n  if (!url.hasParam(\"version\")) {\n    return Result.Err(`missing version: ${url.toString()}`);\n  }\n  return Result.Ok(url);\n}\n\nexport interface StoreOpts {\n  readonly gateway: Gateway;\n  readonly keybag: () => Promise<KeyBag>;\n  readonly loader?: Loadable;\n}\n\nexport abstract class BaseStoreImpl {\n  // should be injectable\n\n  abstract readonly storeType: StoreType;\n  readonly name: string;\n\n  private _url: URI;\n  readonly logger: Logger;\n  readonly sthis: SuperThis;\n  readonly gateway: FragmentGateway;\n  readonly keybag: () => Promise<KeyBag>;\n  readonly loader?: Loadable;\n  constructor(name: string, url: URI, opts: StoreOpts, sthis: SuperThis, logger: Logger) {\n    this.name = name;\n    this._url = url;\n    this.keybag = opts.keybag;\n    this.sthis = sthis;\n    this.logger = logger\n      .With()\n      .Ref(\"url\", () => this._url.toString())\n      .Str(\"name\", name)\n      .Logger();\n    this.gateway = new FragmentGateway(this.sthis, opts.gateway);\n    this.loader = opts.loader;\n  }\n\n  url(): URI {\n    return this._url;\n  }\n\n  readonly _onStarted: (() => void)[] = [];\n  onStarted(fn: () => void) {\n    this._onStarted.push(fn);\n  }\n  readonly _onClosed: (() => void)[] = [];\n  onClosed(fn: () => void) {\n    this._onClosed.push(fn);\n  }\n  abstract close(): Promise<Result<void>>;\n\n  async ready() {\n    return;\n  }\n\n  async keyedCrypto(): Promise<KeyedCrypto> {\n    return keyedCryptoFactory(this._url, await this.keybag(), this.sthis);\n  }\n\n  async start(): Promise<Result<URI>> {\n    this.logger.Debug().Str(\"storeType\", this.storeType).Msg(\"starting-gateway-pre\");\n    this._url = this._url.build().setParam(\"store\", this.storeType).URI();\n    const res = await this.gateway.start(this._url);\n    if (res.isErr()) {\n      this.logger.Error().Result(\"gw-start\", res).Msg(\"started-gateway\");\n      return res as Result<URI>;\n    }\n    this._url = res.Ok();\n    // add storekey to url\n    const kb = await this.keybag();\n    const skRes = await kb.ensureKeyFromUrl(this._url, () => {\n      const idx = this._url.getParam(\"index\");\n      const storeKeyName = [this.name];\n      if (idx) {\n        storeKeyName.push(idx);\n      }\n      storeKeyName.push(this.storeType);\n      return storeKeyName.join(\":\");\n    });\n    if (skRes.isErr()) {\n      return skRes as Result<URI>;\n    }\n    this._url = skRes.Ok();\n    const version = guardVersion(this._url);\n    if (version.isErr()) {\n      this.logger.Error().Result(\"version\", version).Msg(\"guardVersion\");\n      await this.close();\n      return version;\n    }\n    if (this.ready) {\n      const fn = this.ready.bind(this);\n      const ready = await exception2Result(fn);\n      if (ready.isErr()) {\n        await this.close();\n        return ready as Result<URI>;\n      }\n    }\n    this._onStarted.forEach((fn) => fn());\n    this.logger.Debug().Msg(\"started\");\n    return version;\n  }\n}\n\nexport class MetaStoreImpl extends BaseStoreImpl implements MetaStore {\n  readonly storeType = \"meta\";\n  readonly subscribers = new Map<string, LoadHandler[]>();\n  parents: CarClockHead = [];\n  // remote: boolean;\n\n  constructor(sthis: SuperThis, name: string, url: URI, opts: StoreOpts) {\n    // const my = new URL(url.toString());\n    // my.searchParams.set(\"storekey\", 'insecure');\n    super(name, url, { ...opts }, sthis, ensureLogger(sthis, \"MetaStoreImpl\"));\n    // this.remote = !!remote;\n    if (/*this.remote && */ opts.gateway.subscribe) {\n      this.onStarted(async () => {\n        this.logger.Debug().Str(\"url\", this.url().toString()).Msg(\"Subscribing to the gateway\");\n        opts.gateway.subscribe?.(this.url(), async (message: Uint8Array) => {\n          this.logger.Debug().Msg(\"Received message from gateway\");\n          const dbMetas = await decodeGatewayMetaBytesToDbMeta(this.sthis, message);\n          await Promise.all(\n            dbMetas.map((dbMeta) => this.loader?.taskManager?.handleEvent(dbMeta.eventCid, dbMeta.parents, dbMeta.dbMeta)),\n          );\n          this.updateParentsFromDbMetas(dbMetas);\n        });\n      });\n    }\n  }\n\n  private updateParentsFromDbMetas(dbMetas: { eventCid: CarClockLink; parents: string[] }[]) {\n    const cids = dbMetas.map((m) => m.eventCid);\n    const dbMetaParents = dbMetas.flatMap((m) => m.parents);\n    const uniqueParentsMap = new Map([...this.parents, ...cids].map((p) => [p.toString(), p]));\n    const dbMetaParentsSet = new Set(dbMetaParents.map((p) => p.toString()));\n    this.parents = Array.from(uniqueParentsMap.values()).filter((p) => !dbMetaParentsSet.has(p.toString()));\n  }\n\n  async handleByteHeads(byteHeads: Uint8Array) {\n    return await decodeGatewayMetaBytesToDbMeta(this.sthis, byteHeads);\n  }\n\n  async load(): Promise<DbMeta[] | Falsy> {\n    const branch = \"main\";\n    const url = await this.gateway.buildUrl(this.url(), branch);\n    if (url.isErr()) {\n      throw this.logger.Error().Result(\"buildUrl\", url).Str(\"branch\", branch).Msg(\"got error from gateway.buildUrl\").AsError();\n    }\n    const bytes = await this.gateway.get(url.Ok());\n    if (bytes.isErr()) {\n      if (isNotFoundError(bytes)) {\n        return undefined;\n      }\n      throw this.logger.Error().Url(url.Ok()).Result(\"bytes:\", bytes).Msg(\"gateway get\").AsError();\n    }\n    const dbMetas = await this.handleByteHeads(bytes.Ok());\n    await this.loader?.handleDbMetasFromStore(dbMetas.map((m) => m.dbMeta)); // the old one didn't await\n    this.updateParentsFromDbMetas(dbMetas);\n    return dbMetas.map((m) => m.dbMeta);\n  }\n\n  async save(meta: DbMeta, branch?: string): Promise<Result<void>> {\n    branch = branch || \"main\";\n    this.logger.Debug().Str(\"branch\", branch).Any(\"meta\", meta).Msg(\"saving meta\");\n    const event = await createDbMetaEventBlock(this.sthis, meta, this.parents);\n    const bytes = await encodeEventsWithParents(this.sthis, [event], this.parents);\n    const url = await this.gateway.buildUrl(this.url(), branch);\n    if (url.isErr()) {\n      throw this.logger.Error().Err(url.Err()).Str(\"branch\", branch).Msg(\"got error from gateway.buildUrl\").AsError();\n    }\n    this.parents = [event.cid];\n    const res = await this.gateway.put(url.Ok(), bytes);\n    if (res.isErr()) {\n      throw this.logger.Error().Err(res.Err()).Msg(\"got error from gateway.put\").AsError();\n    }\n    // await this.loader?.handleDbMetasFromStore([meta]);\n    // this.loader?.taskManager?.eventsWeHandled.add(event.cid.toString());\n    return res;\n  }\n\n  async close(): Promise<Result<void>> {\n    await this.gateway.close(this.url());\n    this._onClosed.forEach((fn) => fn());\n    return Result.Ok(undefined);\n  }\n  async destroy(): Promise<Result<void>> {\n    return this.gateway.destroy(this.url());\n  }\n}\n\nexport class DataStoreImpl extends BaseStoreImpl implements DataStore {\n  readonly storeType = \"data\";\n  // readonly tag: string = \"car-base\";\n\n  constructor(sthis: SuperThis, name: string, url: URI, opts: StoreOpts) {\n    super(name, url, { ...opts }, sthis, ensureLogger(sthis, \"DataStoreImpl\"));\n  }\n\n  async load(cid: AnyLink): Promise<AnyBlock> {\n    this.logger.Debug().Any(\"cid\", cid).Msg(\"loading\");\n    const url = await this.gateway.buildUrl(this.url(), cid.toString());\n    if (url.isErr()) {\n      throw this.logger.Error().Err(url.Err()).Str(\"cid\", cid.toString()).Msg(\"got error from gateway.buildUrl\").AsError();\n    }\n    const res = await this.gateway.get(url.Ok());\n    if (res.isErr()) {\n      throw res.Err();\n    }\n    return { cid, bytes: res.Ok() };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async save(car: AnyBlock, opts?: DataSaveOpts): Promise</*AnyLink | */ void> {\n    this.logger.Debug().Any(\"cid\", car.cid.toString()).Msg(\"saving\");\n    const url = await this.gateway.buildUrl(this.url(), car.cid.toString());\n    if (url.isErr()) {\n      throw this.logger.Error().Err(url.Err()).Ref(\"cid\", car.cid).Msg(\"got error from gateway.buildUrl\").AsError();\n    }\n    const res = await this.gateway.put(url.Ok(), car.bytes);\n    if (res.isErr()) {\n      throw this.logger.Error().Err(res.Err()).Msg(\"got error from gateway.put\").AsError();\n    }\n    return res.Ok();\n  }\n  async remove(cid: AnyLink): Promise<Result<void>> {\n    const url = await this.gateway.buildUrl(this.url(), cid.toString());\n    if (url.isErr()) {\n      return url;\n    }\n    return this.gateway.delete(url.Ok());\n  }\n  async close(): Promise<Result<void>> {\n    await this.gateway.close(this.url());\n    this._onClosed.forEach((fn) => fn());\n    return Result.Ok(undefined);\n  }\n  destroy(): Promise<Result<void>> {\n    return this.gateway.destroy(this.url());\n  }\n}\n\nexport class WALStoreImpl extends BaseStoreImpl implements WALStore {\n  readonly storeType = \"wal\";\n  // readonly tag: string = \"rwal-base\";\n\n  readonly loader: Loadable;\n\n  readonly _ready = new ResolveOnce<void>();\n\n  walState: WALState = { operations: [], noLoaderOps: [], fileOperations: [] };\n  readonly processing: Promise<void> | undefined = undefined;\n  readonly processQueue: CommitQueue<void> = new CommitQueue<void>();\n\n  constructor(loader: Loadable, url: URI, opts: StoreOpts) {\n    // const my = new URL(url.toString());\n    // my.searchParams.set(\"storekey\", 'insecure');\n    super(loader.name, url, { ...opts }, loader.sthis, ensureLogger(loader.sthis, \"WALStoreImpl\"));\n    this.loader = loader;\n  }\n\n  async ready(): Promise<void> {\n    return this._ready.once(async () => {\n      const walState = await this.load().catch((e) => {\n        this.logger.Error().Any(\"error\", e).Msg(\"error loading wal\");\n        return undefined;\n      });\n      if (!walState) {\n        this.walState.operations = [];\n        this.walState.fileOperations = [];\n      } else {\n        this.walState.operations = walState.operations || [];\n        this.walState.fileOperations = walState.fileOperations || [];\n      }\n    });\n  }\n\n  async enqueue(dbMeta: DbMeta, opts: CommitOpts) {\n    await this.ready();\n    if (opts.compact) {\n      this.walState.operations = [];\n      this.walState.noLoaderOps = [dbMeta];\n    } else if (opts.noLoader) {\n      this.walState.noLoaderOps.push(dbMeta);\n    } else {\n      this.walState.operations.push(dbMeta);\n    }\n    await this.save(this.walState);\n    if (!opts.noLoader) {\n      void this.process();\n    }\n  }\n\n  async enqueueFile(fileCid: AnyLink, publicFile = false) {\n    await this.ready();\n    this.walState.fileOperations.push({ cid: fileCid, public: publicFile });\n    // await this.save(this.walState)\n  }\n\n  async process() {\n    await this.ready();\n    if (!this.loader.remoteCarStore) return;\n    await this.processQueue.enqueue(async () => {\n      try {\n        await this._doProcess();\n      } catch (e) {\n        this.logger.Error().Any(\"error\", e).Msg(\"error processing wal\");\n      }\n      if (this.walState.operations.length || this.walState.fileOperations.length || this.walState.noLoaderOps.length) {\n        setTimeout(() => void this.process(), 0);\n      }\n    });\n  }\n\n  async _doProcess() {\n    if (!this.loader.remoteCarStore) return;\n\n    const operations = [...this.walState.operations];\n    const noLoaderOps = [...this.walState.noLoaderOps];\n    const fileOperations = [...this.walState.fileOperations];\n\n    if (operations.length + noLoaderOps.length + fileOperations.length === 0) return;\n\n    const concurrencyLimit = 3;\n\n    // Helper function to retry uploads\n    const retryableUpload = <T>(fn: () => Promise<T>, description: string) =>\n      pRetry(fn, {\n        retries: 5,\n        onFailedAttempt: (error) => {\n          this.logger\n            .Warn()\n            .Msg(`Attempt ${error.attemptNumber} failed for ${description}. There are ${error.retriesLeft} retries left.`);\n        },\n      });\n\n    try {\n      // Process noLoaderOps\n      await pMap(\n        noLoaderOps,\n        async (dbMeta) => {\n          await retryableUpload(async () => {\n            for (const cid of dbMeta.cars) {\n              const car = await (await this.loader.carStore()).load(cid);\n              if (!car) {\n                if (carLogIncludesGroup(this.loader.carLog, dbMeta.cars)) {\n                  throw this.logger.Error().Ref(\"cid\", cid).Msg(\"missing local car\").AsError();\n                }\n              } else {\n                await throwFalsy(this.loader.remoteCarStore).save(car);\n              }\n            }\n            // Remove from walState after successful upload\n            this.walState.noLoaderOps = this.walState.noLoaderOps.filter((op) => op !== dbMeta);\n          }, `noLoaderOp with dbMeta.cars=${dbMeta.cars.toString()}`);\n        },\n        { concurrency: concurrencyLimit },\n      );\n\n      // Process operations\n      await pMap(\n        operations,\n        async (dbMeta) => {\n          await retryableUpload(async () => {\n            for (const cid of dbMeta.cars) {\n              const car = await (await this.loader.carStore()).load(cid);\n              if (!car) {\n                if (carLogIncludesGroup(this.loader.carLog, dbMeta.cars)) {\n                  throw this.logger.Error().Ref(\"cid\", cid).Msg(`missing local car`).AsError();\n                }\n              } else {\n                await throwFalsy(this.loader.remoteCarStore).save(car);\n              }\n            }\n            // Remove from walState after successful upload\n            this.walState.operations = this.walState.operations.filter((op) => op !== dbMeta);\n          }, `operation with dbMeta.cars=${dbMeta.cars.toString()}`);\n        },\n        { concurrency: concurrencyLimit },\n      );\n\n      // Process fileOperations\n      await pMap(\n        fileOperations,\n        async ({ cid: fileCid, public: publicFile }) => {\n          await retryableUpload(async () => {\n            const fileBlock = await (await this.loader.fileStore()).load(fileCid);\n            if (!fileBlock) {\n              throw this.logger.Error().Ref(\"cid\", fileCid).Msg(\"missing file block\").AsError();\n            }\n            await this.loader.remoteFileStore?.save(fileBlock, { public: publicFile });\n            // Remove from walState after successful upload\n            this.walState.fileOperations = this.walState.fileOperations.filter((op) => op.cid !== fileCid);\n          }, `fileOperation with cid=${fileCid.toString()}`);\n        },\n        { concurrency: concurrencyLimit },\n      );\n\n      // If all uploads succeeded, send the last dbMeta to remoteMetaStore\n      if (operations.length) {\n        const lastOp = operations[operations.length - 1];\n        await retryableUpload(async () => {\n          await this.loader.remoteMetaStore?.save(lastOp);\n        }, `remoteMetaStore save with dbMeta.cars=${lastOp.cars.toString()}`);\n      }\n    } catch (error) {\n      // Log the error\n      this.logger.Error().Any(\"error\", error).Msg(\"Processing failed\");\n      // Do not proceed to send metadata if any uploads failed\n      return;\n    } finally {\n      // Always save the WAL state\n      await this.save(this.walState);\n    }\n  }\n\n  async load(): Promise<WALState | Falsy> {\n    this.logger.Debug().Msg(\"loading\");\n    const filepath = await this.gateway.buildUrl(this.url(), \"main\");\n    if (filepath.isErr()) {\n      throw this.logger.Error().Err(filepath.Err()).Url(this.url()).Msg(\"error building url\").AsError();\n    }\n    const bytes = await this.gateway.get(filepath.Ok());\n    if (bytes.isErr()) {\n      if (isNotFoundError(bytes)) {\n        return undefined;\n      }\n      throw this.logger.Error().Err(bytes.Err()).Msg(\"error get\").AsError();\n    }\n    try {\n      return bytes && parse<WALState>(this.sthis.txt.decode(bytes.Ok()));\n    } catch (e) {\n      throw this.logger.Error().Err(e).Msg(\"error parse\").AsError();\n    }\n  }\n\n  async save(state: WALState) {\n    const filepath = await this.gateway.buildUrl(this.url(), \"main\");\n    if (filepath.isErr()) {\n      throw this.logger.Error().Err(filepath.Err()).Url(this.url()).Msg(\"error building url\").AsError();\n    }\n    let encoded: ToString<WALState>;\n    try {\n      encoded = format(state);\n    } catch (e) {\n      throw this.logger.Error().Err(e).Any(\"state\", state).Msg(\"error format\").AsError();\n    }\n    const res = await this.gateway.put(filepath.Ok(), this.sthis.txt.encode(encoded));\n    if (res.isErr()) {\n      throw this.logger.Error().Err(res.Err()).Str(\"filePath\", filepath.Ok().toString()).Msg(\"error saving\").AsError();\n    }\n  }\n\n  async close() {\n    await this.gateway.close(this.url());\n    this._onClosed.forEach((fn) => fn());\n    return Result.Ok(undefined);\n  }\n\n  destroy() {\n    return this.gateway.destroy(this.url());\n  }\n}\n","import type { EventLink } from \"@fireproof/vendor/@web3-storage/pail/clock/api\";\nimport type { Operation } from \"@fireproof/vendor/@web3-storage/pail/crdt/api\";\n\nimport type { DbMeta, StoreOpts, AnyLink } from \"./blockstore/index.js\";\nimport { EnvFactoryOpts, Env, Logger, CryptoRuntime } from \"@adviser/cement\";\n\nimport type { MakeDirectoryOptions, PathLike, Stats } from \"fs\";\n\nexport type Falsy = false | null | undefined;\n\nexport function isFalsy(value: unknown): value is Falsy {\n  return value === false && value === null && value === undefined;\n}\n\nexport function throwFalsy<T>(value: T | Falsy): T {\n  if (isFalsy(value)) {\n    throw new Error(\"value is Falsy\");\n  }\n  return value;\n}\n\nexport function falsyToUndef<T>(value: T | Falsy): T | undefined {\n  if (isFalsy(value)) {\n    return undefined;\n  }\n  return value;\n}\n\nexport type StoreType = \"data\" | \"wal\" | \"meta\";\n\nexport interface SysFileSystem {\n  start(): Promise<SysFileSystem>;\n  mkdir(path: PathLike, options?: { recursive: boolean }): Promise<string | undefined>;\n  readdir(path: PathLike, options?: unknown): Promise<string[]>;\n  rm(path: PathLike, options?: MakeDirectoryOptions & { recursive: boolean }): Promise<void>;\n  copyFile(source: PathLike, destination: PathLike): Promise<void>;\n  readfile(path: PathLike, options?: { encoding: BufferEncoding; flag?: string }): Promise<Uint8Array>;\n  stat(path: PathLike): Promise<Stats>;\n  unlink(path: PathLike): Promise<void>;\n  writefile(path: PathLike, data: Uint8Array | string): Promise<void>;\n}\n\nexport interface PathOps {\n  join(...args: string[]): string;\n  dirname(path: string): string;\n  // homedir(): string;\n}\n\n// export interface Sys {\n//   // fs: SysFileSystem;\n//   fsHelper: PathOps;\n// }\nexport interface TextEndeCoder {\n  encode(input: string): Uint8Array;\n  decode(input: Uint8Array): string;\n}\nexport interface SuperThisOpts {\n  // readonly crypto?: CryptoRuntime;\n  readonly logger: Logger;\n  readonly pathOps: PathOps;\n  readonly crypto: CryptoRuntime;\n  readonly env: EnvFactoryOpts;\n  readonly txt: TextEndeCoder;\n  readonly ctx: Record<string, unknown>;\n}\n\nexport interface SuperThis {\n  readonly logger: Logger;\n  readonly loggerCollector?: Logger;\n  readonly env: Env;\n  readonly pathOps: PathOps;\n  readonly ctx: Record<string, unknown>;\n  readonly txt: TextEndeCoder;\n  nextId(bytes?: number): { str: string; bin: Uint8Array };\n  timeOrderedNextId(time?: number): { str: string };\n  start(): Promise<void>;\n  clone(override: Partial<SuperThisOpts>): SuperThis;\n}\n\nexport interface ConfigOpts extends Partial<SuperThisOpts> {\n  readonly public?: boolean;\n  readonly meta?: DbMeta;\n  readonly persistIndexes?: boolean;\n  readonly autoCompact?: number;\n  readonly store?: StoreOpts;\n  readonly threshold?: number;\n}\n\nexport type ClockLink = EventLink<Operation>;\n\nexport type ClockHead = ClockLink[];\n\nexport type DocFragment = Uint8Array | string | number | boolean | null | AnyLink | DocFragment[] | object;\n// | { [key: string]: DocFragment };\n\nexport type DocLiteral = string | number | boolean | Uint8Array | unknown;\n\nexport type DocObject = NonNullable<unknown>;\nexport type DocTypes = DocObject;\n\nexport type DocRecord<T extends DocObject> = T;\n\nexport type UnknownDoc = DocRecord<never>;\n\nexport type DocFiles = Record<string, DocFileMeta | File>;\n\nexport interface DocBase {\n  readonly _id: string;\n  readonly _files?: DocFiles;\n  readonly _publicFiles?: DocFiles;\n  readonly _deleted?: boolean;\n}\n\nexport type DocWithId<T extends DocTypes> = DocBase & T;\n\nexport type DocSet<T extends DocTypes> = Partial<DocBase> & T;\n\nexport interface DocFileMeta {\n  readonly type: string;\n  readonly size: number;\n  readonly cid: AnyLink;\n  readonly car?: AnyLink;\n  url?: string;\n  file?: () => Promise<File>;\n}\n\nexport interface DocUpdate<T extends DocTypes> {\n  readonly id: string;\n  readonly value?: DocSet<T>;\n  readonly del?: boolean;\n  readonly clock?: ClockLink; // would be useful to give ClockLinks a type\n}\n\n// todo merge into above\nexport interface DocValue<T extends DocTypes> {\n  readonly doc: DocWithId<T>;\n  readonly del: boolean;\n  readonly cid: AnyLink;\n}\n\nexport type KeyLiteral = string | number | boolean;\nexport type IndexKeyType = KeyLiteral | KeyLiteral[];\nexport type IndexKey<K extends IndexKeyType> = [K, string];\n\nexport interface IndexUpdate<K extends IndexKeyType> {\n  readonly key: IndexKey<K>;\n  readonly value?: DocFragment;\n  readonly del?: boolean;\n}\n\nexport interface IndexUpdateString {\n  readonly key: string;\n  readonly value?: DocFragment;\n  readonly del?: boolean;\n}\n\n// export interface IndexRowObject<K extends IndexKeyType, T extends DocObject> {\n//   readonly id: string;\n//   readonly key: K;\n//   readonly value: T\n//   // readonly row: T // DocFragment;\n//   // readonly doc?: DocWithId<T>;\n//   // value?: T;\n//   // readonly del?: boolean;\n// }\n\n// export interface IndexRowLiteral<K extends IndexKeyType, T extends DocLiteral> {\n//   readonly id: string;\n//   readonly key: IndexKey<K>;\n//   readonly value: T\n// }\n\n// export type IndexRow<K extends IndexKeyType, T extends DocTypes> =\n//   T extends DocLiteral ? IndexRowLiteral<K, T> : IndexRowObject<K, T>\n\nexport interface IndexRow<K extends IndexKeyType, T extends DocObject, R extends DocFragment> {\n  readonly id: string;\n  readonly key: K; // IndexKey<K>;\n  readonly value: R;\n  readonly doc?: DocWithId<T>;\n}\n\nexport interface IndexRows<K extends IndexKeyType, T extends DocObject, R extends DocFragment = T> {\n  readonly rows: IndexRow<K, T, R>[];\n}\nexport interface CRDTMeta {\n  readonly head: ClockHead;\n}\n\nexport interface IndexTransactionMeta {\n  readonly indexes: Record<string, IdxMeta>;\n}\n\nexport interface FileTransactionMeta {\n  readonly files?: AnyLink[];\n}\n\nexport type MetaType = CRDTMeta | IndexTransactionMeta | FileTransactionMeta;\n\nexport interface IdxMeta {\n  readonly byId: AnyLink;\n  readonly byKey: AnyLink;\n  readonly map: string;\n  readonly name: string;\n  readonly head: ClockHead;\n}\n\nexport interface IdxMetaMap {\n  readonly indexes?: Map<string, IdxMeta>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface QueryOpts<K extends IndexKeyType> {\n  readonly descending?: boolean;\n  readonly limit?: number;\n  includeDocs?: boolean;\n  readonly range?: [IndexKeyType, IndexKeyType];\n  readonly key?: DocFragment;\n  readonly keys?: DocFragment[];\n  prefix?: IndexKeyType;\n}\n\nexport interface AllDocsQueryOpts extends QueryOpts<string> {\n  readonly key?: string;\n  readonly keys?: string[];\n  prefix?: string;\n}\n\nexport interface AllDocsResponse<T extends DocTypes> {\n  readonly rows: {\n    readonly key: string;\n    readonly value: DocWithId<T>;\n  }[];\n  readonly clock: ClockHead;\n  readonly name?: string;\n}\n\ntype EmitFn = (k: IndexKeyType, v?: DocFragment) => void;\nexport type MapFn<T extends DocTypes> = (doc: DocWithId<T>, emit: EmitFn) => DocFragment | unknown;\n\nexport interface ChangesOptions {\n  readonly dirty?: boolean;\n  readonly limit?: number;\n}\n\nexport interface ChangesResponseRow<T extends DocTypes> {\n  readonly key: string;\n  readonly value: DocWithId<T>;\n  readonly clock?: ClockLink;\n}\n\nexport interface ChangesResponse<T extends DocTypes> {\n  readonly clock: ClockHead;\n  readonly rows: ChangesResponseRow<T>[];\n  readonly name?: string;\n}\n\nexport interface DocResponse {\n  readonly id: string;\n  readonly clock: ClockHead;\n  readonly name?: string;\n}\n\nexport type UpdateListenerFn<T extends DocTypes> = (docs: DocWithId<T>[]) => Promise<void> | void;\nexport type NoUpdateListenerFn = () => Promise<void> | void;\nexport type ListenerFn<T extends DocTypes> = UpdateListenerFn<T> | NoUpdateListenerFn;\n\nexport interface CRDTEntry {\n  readonly data: string;\n  readonly parents: string[];\n  readonly cid: string;\n}\n","import {\n  Logger,\n  LoggerImpl,\n  IsLogger,\n  Result,\n  ResolveOnce,\n  isURL,\n  URI,\n  CoerceURI,\n  runtimeFn,\n  envFactory,\n  Env,\n  toCryptoRuntime,\n  CryptoRuntime,\n  JSONFormatter,\n  YAMLFormatter,\n} from \"@adviser/cement\";\nimport { PathOps, StoreType, SuperThis, SuperThisOpts, TextEndeCoder } from \"./types.js\";\nimport { base58btc } from \"multiformats/bases/base58\";\n\nexport type { Logger };\nexport { Result };\n\nconst _globalLogger = new ResolveOnce();\nfunction globalLogger(): Logger {\n  return _globalLogger.once(() => new LoggerImpl());\n}\n\nconst registerFP_DEBUG = new ResolveOnce();\n\ninterface superThisOpts {\n  readonly logger: Logger;\n  readonly env: Env;\n  readonly pathOps: PathOps;\n  readonly crypto: CryptoRuntime;\n  readonly ctx: Record<string, unknown>;\n  readonly txt: TextEndeCoder;\n}\n\nclass SuperThisImpl implements SuperThis {\n  readonly logger: Logger;\n  readonly env: Env;\n  readonly pathOps: PathOps;\n  readonly ctx: Record<string, unknown>;\n  readonly txt: TextEndeCoder;\n  readonly crypto: CryptoRuntime;\n\n  constructor(opts: superThisOpts) {\n    this.logger = opts.logger;\n    this.env = opts.env;\n    this.crypto = opts.crypto;\n    this.pathOps = opts.pathOps;\n    this.txt = opts.txt;\n    this.ctx = { ...opts.ctx };\n    // console.log(\"superThis\", this);\n  }\n\n  nextId(bytes = 6): { str: string; bin: Uint8Array } {\n    const bin = this.crypto.randomBytes(bytes);\n    return {\n      str: base58btc.encode(bin),\n      bin,\n    };\n  }\n\n  timeOrderedNextId(now?: number): { str: string } {\n    now = typeof now === \"number\" ? now : new Date().getTime();\n    // 49th bit\n    const t = (0x1000000000000 + now).toString(16).replace(/^1/, \"\");\n    const bin = this.crypto.randomBytes(10);\n    bin[1] = (bin[1] & 0xf0) | (bin[1] | 0x08 && 0x0b);\n    const hex = Array.from(bin)\n      .map((i) => i.toString(16).padStart(2, \"0\"))\n      .join(\"\");\n    return {\n      str: `${t.slice(0, 8)}-${t.slice(8)}-7${hex.slice(0, 3)}-${hex.slice(3, 7)}-${hex.slice(7, 19)}`,\n    };\n  }\n\n  start(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  clone(override: Partial<SuperThisOpts>): SuperThis {\n    return new SuperThisImpl({\n      logger: override.logger || this.logger,\n      env: envFactory(override.env) || this.env,\n      crypto: override.crypto || this.crypto,\n      pathOps: override.pathOps || this.pathOps,\n      txt: override.txt || this.txt,\n      ctx: { ...this.ctx, ...override.ctx },\n    });\n  }\n}\n\n// const pathOps =\nfunction presetEnv() {\n  const penv = new Map([\n    // [\"FP_DEBUG\", \"xxx\"],\n    // [\"FP_ENV\", \"development\"],\n    ...Array.from(\n      Object.entries(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ((globalThis as any)[Symbol.for(\"FP_PRESET_ENV\")] || {}) as Record<string, string>,\n      ),\n    ), // .map(([k, v]) => [k, v as string])\n  ]);\n  // console.log(\">>>>>>\", penv)\n  return penv;\n}\n// const envImpl = envFactory({\n//   symbol: \"FP_ENV\",\n//   presetEnv: presetEnv(),\n// });\nclass pathOpsImpl implements PathOps {\n  join(...paths: string[]): string {\n    return paths.map((i) => i.replace(/\\/+$/, \"\")).join(\"/\");\n  }\n  dirname(path: string) {\n    return path.split(\"/\").slice(0, -1).join(\"/\");\n  }\n  // homedir() {\n  //     throw new Error(\"SysContainer:homedir is not available in seeded state\");\n  //   }\n}\nconst pathOps = new pathOpsImpl();\nconst txtOps = {\n  // eslint-disable-next-line no-restricted-globals\n  encode: (input: string) => new TextEncoder().encode(input),\n  // eslint-disable-next-line no-restricted-globals\n  decode: (input: Uint8Array) => new TextDecoder().decode(input),\n};\n\nconst _onSuperThis = new Map<string, (sthis: SuperThis) => void>();\nexport function onSuperThis(fn: (sthis: SuperThis) => void): () => void {\n  const key = `onSuperThis-${Math.random().toString(36).slice(2)}`;\n  _onSuperThis.set(key, fn);\n  return () => {\n    _onSuperThis.delete(key);\n  };\n}\n\nexport function ensureSuperThis(osthis?: Partial<SuperThisOpts>): SuperThis {\n  const env = envFactory({\n    symbol: osthis?.env?.symbol || \"FP_ENV\",\n    presetEnv: osthis?.env?.presetEnv || presetEnv(),\n  });\n  const ret = new SuperThisImpl({\n    logger: osthis?.logger || globalLogger(),\n    env,\n    crypto: osthis?.crypto || toCryptoRuntime(),\n    ctx: osthis?.ctx || {},\n    pathOps,\n    txt: osthis?.txt || txtOps,\n  });\n  _onSuperThis.forEach((fn) => fn(ret));\n  return ret;\n}\n\n// // eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function ensureSuperLog(sthis: SuperThis, componentName: string, ctx?: Record<string, unknown>): SuperThis {\n  return sthis.clone({\n    logger: ensureLogger(sthis, componentName, ctx),\n  });\n}\n\nexport function ensureLogger(\n  sthis: SuperThis /* Partial<LoggerOpts> | Logger */,\n  componentName: string,\n  ctx?: Record<string, unknown>,\n): Logger {\n  // if (!opts?.logger) {\n  //   throw new Error(\"logger is required\");\n  // }\n  let logger: Logger;\n  if (sthis && IsLogger(sthis.logger)) {\n    logger = sthis.logger;\n  } else {\n    logger = globalLogger();\n  }\n  const cLogger = logger.With().Module(componentName); //.Str(\"this\", uuidv7());\n  const debug: string[] = [];\n  let exposeStack = false;\n  if (ctx) {\n    if (\"debug\" in ctx) {\n      if (typeof ctx.debug === \"string\" && ctx.debug.length > 0) {\n        debug.push(ctx.debug);\n      } else {\n        debug.push(componentName);\n      }\n      delete ctx.debug;\n    }\n    if (\"exposeStack\" in ctx) {\n      exposeStack = true;\n      delete ctx.exposeStack;\n    }\n    if (\"this\" in ctx) {\n      cLogger.Str(\"this\", sthis.nextId(4).str);\n      delete ctx.this;\n    }\n    for (const [key, value] of Object.entries(ctx)) {\n      switch (typeof value) {\n        case \"string\":\n          cLogger.Str(key, value);\n          break;\n        case \"number\":\n          cLogger.Uint64(key, value);\n          break;\n        default:\n          if (value instanceof Date) {\n            cLogger.Str(key, value.toISOString());\n          } else if (isURL(value)) {\n            cLogger.Str(key, value.toString());\n          } else if (typeof value === \"function\") {\n            cLogger.Ref(key, value);\n          } else {\n            cLogger.Any(key, value);\n          }\n          break;\n      }\n    }\n  }\n  registerFP_DEBUG\n    .once(async () => {\n      // console.log(\"registerFP_DEBUG\", SysContainer.env)\n      sthis.env.onSet(\n        (key, value) => {\n          // console.log(\"FP_DEBUG\", key, value, debug)\n          switch (key) {\n            case \"FP_FORMAT\": {\n              switch (value) {\n                case \"jsonice\":\n                  logger.SetFormatter(new JSONFormatter(logger.TxtEnDe(), 2));\n                  break;\n                case \"yaml\":\n                  logger.SetFormatter(new YAMLFormatter(logger.TxtEnDe(), 2));\n                  break;\n                case \"json\":\n                default:\n                  logger.SetFormatter(new JSONFormatter(logger.TxtEnDe()));\n                  break;\n              }\n              break;\n            }\n            case \"FP_DEBUG\":\n              logger.SetDebug(value || []);\n              break;\n            case \"FP_STACK\":\n              logger.SetExposeStack(!!value);\n              break;\n          }\n        },\n        \"FP_FORMAT\",\n        \"FP_DEBUG\",\n        \"FP_STACK\",\n      );\n    })\n    .finally(() => {\n      /* do nothing */\n    });\n\n  if (debug.length > 0) {\n    logger.SetDebug(debug);\n  }\n  if (exposeStack) {\n    logger.SetExposeStack(true);\n  }\n  const out = cLogger.Logger();\n  // out.Debug().Msg(\"logger ready\");\n  return out;\n}\n\nexport type Joiner = (...toJoin: string[]) => string;\n\nexport interface Store {\n  readonly store: StoreType;\n  readonly name: string;\n}\n\nexport function getStore(url: URI, sthis: SuperThis, joiner: Joiner): Store {\n  const store = url.getParam(\"store\");\n  switch (store) {\n    case \"data\":\n    case \"wal\":\n    case \"meta\":\n      break;\n    default:\n      throw sthis.logger.Error().Url(url).Msg(`store not found`).AsError();\n  }\n  let name: string = store;\n  if (url.hasParam(\"index\")) {\n    name = joiner(url.getParam(\"index\") || \"idx\", name);\n  }\n  return { store, name };\n}\n\nexport function getKey(url: URI, logger: Logger): string {\n  const result = url.getParam(\"key\");\n  if (!result) throw logger.Error().Str(\"url\", url.toString()).Msg(`key not found`).AsError();\n  return result;\n}\n\nexport function getName(sthis: SuperThis, url: URI): string {\n  let result = url.getParam(\"name\");\n  if (!result) {\n    result = sthis.pathOps.dirname(url.pathname);\n    if (result.length === 0) {\n      throw sthis.logger.Error().Str(\"url\", url.toString()).Msg(`name not found`).AsError();\n    }\n  }\n  return result;\n}\n\n// export function exception2Result<T = void>(fn: () => Promise<T>): Promise<Result<T>> {\n//   return fn()\n//     .then((value) => Result.Ok(value))\n//     .catch((e) => Result.Err(e));\n// }\n\nexport async function exceptionWrapper<T, E extends Error>(fn: () => Promise<Result<T, E>>): Promise<Result<T, E>> {\n  return fn().catch((e) => Result.Err(e));\n}\n\n// // the big side effect party --- hate it\n// export function sanitizeURL(url: URL) {\n//   url.searchParams.sort();\n//   // const searchParams = Object.entries(url.searchParams).sort(([a], [b]) => a.localeCompare(b));\n//   // console.log(\"searchParams\", searchParams);\n//   // for (const [key] of searchParams) {\n//   //   url.searchParams.delete(key);\n//   // }\n//   // for (const [key, value] of searchParams) {\n//   //   url.searchParams.set(key, value);\n//   // }\n// }\n\nexport class NotFoundError extends Error {\n  readonly code = \"ENOENT\";\n}\n\nexport function isNotFoundError(e: Error | Result<unknown> | unknown): e is NotFoundError {\n  if (Result.Is(e)) {\n    if (e.isOk()) return false;\n    e = e.Err();\n  }\n  if ((e as NotFoundError).code === \"ENOENT\") return true;\n  return false;\n}\n\nexport function dataDir(sthis: SuperThis, name?: string, base?: CoerceURI): URI {\n  if (!base) {\n    if (!runtimeFn().isBrowser) {\n      const home = sthis.env.get(\"HOME\") || \"./\";\n      base = sthis.env.get(\"FP_STORAGE_URL\") || `file://${sthis.pathOps.join(home, \".fireproof\")}`;\n    } else {\n      base = sthis.env.get(\"FP_STORAGE_URL\") || `indexdb://fp`;\n    }\n  }\n  return URI.from(base.toString())\n    .build()\n    .setParam(\"name\", name || \"\")\n    .URI();\n}\n\nexport function UInt8ArrayEqual(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n","import pLimit from \"p-limit\";\nimport { CarReader } from \"@fireproof/vendor/@ipld/car/reader\";\nimport { Logger, ResolveOnce } from \"@adviser/cement\";\n// import { uuidv4 } from \"uuidv7\";\n\nimport {\n  type AnyBlock,\n  type AnyLink,\n  type CarHeader,\n  type CommitOpts,\n  type DbMeta,\n  type TransactionMeta,\n  type CarGroup,\n  type CarLog,\n  DataStore,\n  WALStore,\n  // RemoteMetaStore,\n  MetaStore,\n  BaseStore,\n  type Loadable,\n  BlockstoreRuntime,\n  BlockstoreOpts,\n} from \"./types.js\";\n\nimport { parseCarFile } from \"./loader-helpers.js\";\n\nimport { CarTransaction, defaultedBlockstoreRuntime } from \"./transaction.js\";\nimport { CommitQueue } from \"./commit-queue.js\";\nimport type { Falsy, SuperThis } from \"../types.js\";\nimport { getKeyBag, KeyBag } from \"../runtime/key-bag.js\";\nimport { commit, commitFiles, CommitParams } from \"./commitor.js\";\nimport { decode } from \"../runtime/wait-pr-multiformats/block.js\";\nimport { sha256 as hasher } from \"multiformats/hashes/sha2\";\nimport { TaskManager } from \"./task-manager.js\";\n\nexport function carLogIncludesGroup(list: CarLog, cids: CarGroup) {\n  return list.some((arr: CarGroup) => {\n    return arr.toString() === cids.toString();\n  });\n}\n\n// this works for car groups because toString looks like bafy,bafy\nfunction uniqueCids(list: CarLog, remove = new Set<string>()): CarLog {\n  const byString = new Map<string, CarGroup>();\n  for (const cid of list) {\n    if (remove.has(cid.toString())) continue;\n    byString.set(cid.toString(), cid);\n  }\n  return [...byString.values()];\n}\n\n// export interface DecoderAndCarReader extends CarReader {\n//   readonly decoder: BlockDecoder<number, Uint8Array>;\n// }\n\nexport class Loader implements Loadable {\n  readonly name: string;\n  readonly ebOpts: BlockstoreRuntime;\n  readonly commitQueue: CommitQueue<CarGroup> = new CommitQueue<CarGroup>();\n  readonly isCompacting = false;\n  readonly carReaders: Map<string, Promise<CarReader>> = new Map<string, Promise<CarReader>>();\n  readonly seenCompacted: Set<string> = new Set<string>();\n  readonly processedCars: Set<string> = new Set<string>();\n  readonly sthis: SuperThis;\n  readonly taskManager?: TaskManager;\n\n  carLog: CarLog = [];\n  // key?: string;\n  // keyId?: string;\n  remoteMetaStore?: MetaStore;\n  remoteCarStore?: DataStore;\n  remoteFileStore?: DataStore;\n\n  private getBlockCache = new Map<string, AnyBlock>();\n  private seenMeta = new Set<string>();\n  private writeLimit = pLimit(1);\n\n  // readonly id = uuidv4();\n\n  async keyBag(): Promise<KeyBag> {\n    return getKeyBag(this.sthis, this.ebOpts.keyBag);\n  }\n\n  async carStore(): Promise<DataStore> {\n    return this.ebOpts.storeRuntime.makeDataStore(this);\n  }\n\n  async fileStore(): Promise<DataStore> {\n    return this.ebOpts.storeRuntime.makeDataStore(this);\n  }\n  async WALStore(): Promise<WALStore> {\n    return this.ebOpts.storeRuntime.makeWALStore(this);\n  }\n\n  async metaStore(): Promise<MetaStore> {\n    return this.ebOpts.storeRuntime.makeMetaStore(this);\n  }\n\n  readonly onceReady: ResolveOnce<void> = new ResolveOnce<void>();\n  async ready(): Promise<void> {\n    return this.onceReady.once(async () => {\n      const metas = await (await this.metaStore()).load();\n      if (this.ebOpts.meta) {\n        await this.handleDbMetasFromStore([this.ebOpts.meta]);\n      } else if (metas) {\n        await this.handleDbMetasFromStore(metas);\n      }\n    });\n  }\n\n  async close() {\n    const toClose = await Promise.all([this.carStore(), this.metaStore(), this.fileStore(), this.WALStore()]);\n    await Promise.all(toClose.map((store) => store.close()));\n  }\n\n  async destroy() {\n    const toDestroy = await Promise.all([this.carStore(), this.metaStore(), this.fileStore(), this.WALStore()]);\n    await Promise.all(toDestroy.map((store) => store.destroy()));\n  }\n\n  readonly logger: Logger;\n  constructor(name: string, ebOpts: BlockstoreOpts, sthis: SuperThis) {\n    this.name = name;\n    // console.log(\"Loader\", name, ebOpts)\n    this.sthis = sthis;\n    this.ebOpts = defaultedBlockstoreRuntime(\n      sthis,\n      {\n        ...ebOpts,\n        name,\n      },\n      \"Loader\",\n    );\n    this.logger = this.ebOpts.logger;\n    this.taskManager = new TaskManager(sthis, async (dbMeta: DbMeta) => {\n      await this.handleDbMetasFromStore([dbMeta]);\n    });\n  }\n\n  // async snapToCar(carCid: AnyLink | string) {\n  //   await this.ready\n  //   if (typeof carCid === 'string') {\n  //     carCid = CID.parse(carCid)\n  //   }\n  //   const carHeader = await this.loadCarHeaderFromMeta({ car: carCid, key: this.key || null })\n  //   this.carLog = [carCid, ...carHeader.cars]\n  //   await this.getMoreReaders(carHeader.cars)\n  //   await this._applyCarHeader(carHeader, true)\n  // }\n\n  async handleDbMetasFromStore(metas: DbMeta[]): Promise<void> {\n    this.logger.Debug().Any(\"metas\", metas).Msg(\"handleDbMetasFromStore\");\n    for (const meta of metas) {\n      await this.writeLimit(async () => {\n        await this.mergeDbMetaIntoClock(meta);\n      });\n    }\n  }\n\n  async mergeDbMetaIntoClock(meta: DbMeta): Promise<void> {\n    if (this.isCompacting) {\n      throw this.logger.Error().Msg(\"cannot merge while compacting\").AsError();\n    }\n\n    if (this.seenMeta.has(meta.cars.toString())) return;\n    this.seenMeta.add(meta.cars.toString());\n\n    // if (meta.key) {\n    //   await this.setKey(meta.key);\n    // }\n    if (carLogIncludesGroup(this.carLog, meta.cars)) {\n      return;\n    }\n    const carHeader = await this.loadCarHeaderFromMeta<TransactionMeta>(meta);\n    // fetch other cars down the compact log?\n    // todo we should use a CID set for the compacted cids (how to expire?)\n    // console.log('merge carHeader', carHeader.head.length, carHeader.head.toString(), meta.car.toString())\n    carHeader.compact.map((c) => c.toString()).forEach(this.seenCompacted.add, this.seenCompacted);\n    await this.getMoreReaders(carHeader.cars.flat());\n    this.carLog = [...uniqueCids([meta.cars, ...this.carLog, ...carHeader.cars], this.seenCompacted)];\n    await this.ebOpts.applyMeta?.(carHeader.meta);\n  }\n\n  // protected async ingestKeyFromMeta(meta: DbMeta): Promise<void> {\n  //   const { key } = meta;\n  //   if (key) {\n  //     await this.setKey(key);\n  //   }\n  // }\n\n  async loadCarHeaderFromMeta<T>({ cars: cids }: DbMeta): Promise<CarHeader<T>> {\n    //Call loadCar for every cid\n    const reader = await this.loadCar(cids[0]);\n    return await parseCarFile(reader, this.logger);\n  }\n\n  // async _getKey(): Promise<string | undefined> {\n  //   if (this.key) return this.key;\n  //   // generate a random key\n  //   if (!this.ebOpts.public) {\n  //     await this.setKey(toHexString(this.ebOpts.crypto.randomBytes(32)));\n  //   }\n  //   return this.key || undefined;\n  // }\n\n  async commitFiles(\n    t: CarTransaction,\n    done: TransactionMeta,\n    // opts: CommitOpts = { noLoader: false, compact: false },\n  ): Promise<CarGroup> {\n    await this.ready();\n    const fstore = await this.fileStore();\n    const wstore = await this.WALStore();\n    return this.commitQueue.enqueue(() => commitFiles(fstore, wstore, t, done));\n  }\n\n  async loadFileCar(cid: AnyLink /*, isPublic = false*/): Promise<CarReader> {\n    return await this.storesLoadCar(cid, await this.fileStore(), this.remoteFileStore);\n  }\n\n  async commit<T = TransactionMeta>(\n    t: CarTransaction,\n    done: T,\n    opts: CommitOpts = { noLoader: false, compact: false },\n  ): Promise<CarGroup> {\n    await this.ready();\n    const fstore = await this.fileStore();\n    const params: CommitParams = {\n      encoder: (await fstore.keyedCrypto()).codec(),\n      carLog: this.carLog,\n      carStore: fstore,\n      WALStore: await this.WALStore(),\n      metaStore: await this.metaStore(),\n      threshold: this.ebOpts.threshold,\n    };\n    return this.commitQueue.enqueue(async () => {\n      await this.cacheTransaction(t);\n      const ret = await commit(params, t, done, opts);\n      await this.updateCarLog(ret.cgrp, ret.header, !!opts.compact);\n      return ret.cgrp;\n    });\n  }\n\n  async updateCarLog<T>(cids: CarGroup, fp: CarHeader<T>, compact: boolean): Promise<void> {\n    if (compact) {\n      const previousCompactCid = fp.compact[fp.compact.length - 1];\n      fp.compact.map((c) => c.toString()).forEach(this.seenCompacted.add, this.seenCompacted);\n      this.carLog = [...uniqueCids([...this.carLog, ...fp.cars, cids], this.seenCompacted)];\n      await this.removeCidsForCompact(previousCompactCid[0]).catch((e) => e);\n    } else {\n      this.carLog.unshift(cids);\n    }\n  }\n\n  async cacheTransaction(t: CarTransaction) {\n    for await (const block of t.entries()) {\n      const sBlock = block.cid.toString();\n      if (!this.getBlockCache.has(sBlock)) {\n        this.getBlockCache.set(sBlock, block);\n      }\n    }\n  }\n\n  async cacheCarReader(carCidStr: string, reader: CarReader) {\n    if (this.processedCars.has(carCidStr)) return;\n    this.processedCars.add(carCidStr);\n    for await (const block of reader.blocks()) {\n      const sBlock = block.cid.toString();\n      if (!this.getBlockCache.has(sBlock)) {\n        this.getBlockCache.set(sBlock, block);\n      }\n    }\n  }\n\n  async removeCidsForCompact(cid: AnyLink) {\n    const carHeader = await this.loadCarHeaderFromMeta({\n      cars: [cid],\n    } as unknown as DbMeta);\n    for (const cids of carHeader.compact) {\n      for (const cid of cids) {\n        await (await this.carStore()).remove(cid);\n      }\n    }\n  }\n\n  // async flushCars() {\n  //   await this.ready\n  //   // for each cid in car log, make a dbMeta\n  //   for (const cid of this.carLog) {\n  //     const dbMeta = { car: cid, key: this.key || null } as DbMeta\n  //     await this.remoteWAL!.enqueue(dbMeta, { public: false })\n  //   }\n  // }\n\n  async *entries(cache = true): AsyncIterableIterator<AnyBlock> {\n    await this.ready();\n    if (cache) {\n      for (const [, block] of this.getBlockCache) {\n        yield block;\n      }\n    } else {\n      for (const [, block] of this.getBlockCache) {\n        yield block;\n      }\n      for (const cids of this.carLog) {\n        for (const cid of cids) {\n          const reader = await this.loadCar(cid);\n          if (!reader) throw this.logger.Error().Ref(\"cid\", cid).Msg(\"missing car reader\").AsError();\n          for await (const block of reader.blocks()) {\n            const sCid = block.cid.toString();\n            if (!this.getBlockCache.has(sCid)) {\n              yield block;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  async getBlock(cid: AnyLink): Promise<AnyBlock | Falsy> {\n    await this.ready();\n    const sCid = cid.toString();\n    if (this.getBlockCache.has(sCid)) return this.getBlockCache.get(sCid);\n\n    const getCarCid = async (carCid: AnyLink) => {\n      if (this.getBlockCache.has(sCid)) return this.getBlockCache.get(sCid);\n      const reader = await this.loadCar(carCid);\n      if (!reader) {\n        throw this.logger.Error().Ref(\"cid\", carCid).Msg(\"missing car reader\").AsError();\n      }\n      await this.cacheCarReader(carCid.toString(), reader).catch(() => {\n        return;\n      });\n      if (this.getBlockCache.has(sCid)) return this.getBlockCache.get(sCid);\n      throw this.logger.Error().Str(\"cid\", sCid).Msg(\"block not in reader\").AsError();\n    };\n\n    const getCompactCarCids = async (carCid: AnyLink) => {\n      // console.log(\"getCompactCarCids\", carCid.toString())\n\n      const reader = await this.loadCar(carCid);\n      if (!reader) {\n        throw this.logger.Error().Str(\"cid\", carCid.toString()).Msg(\"missing car reader\").AsError();\n      }\n\n      const header = await parseCarFile(reader, this.logger);\n\n      const compacts = header.compact;\n\n      let got: AnyBlock | undefined;\n      const batchSize = 5;\n      for (let i = 0; i < compacts.length; i += batchSize) {\n        const promises: Promise<AnyBlock | undefined>[] = [];\n        for (let j = i; j < Math.min(i + batchSize, compacts.length); j++) {\n          for (const cid of compacts[j]) {\n            promises.push(getCarCid(cid));\n          }\n        }\n        try {\n          got = await Promise.any(promises);\n        } catch {\n          // Ignore the error and continue with the next iteration\n        }\n        if (got) break;\n      }\n\n      if (this.getBlockCache.has(sCid)) return this.getBlockCache.get(sCid);\n      throw this.logger.Error().Str(\"cid\", sCid).Msg(\"block not in compact reader\").AsError();\n    };\n\n    let got;\n    const batchSize = 5;\n    for (let i = 0; i < this.carLog.length; i += batchSize) {\n      const batch = this.carLog.slice(i, i + batchSize);\n      const promises: Promise<AnyBlock | undefined>[] = batch.flatMap((slice) => slice.map(getCarCid));\n      try {\n        got = await Promise.any(promises);\n      } catch {\n        // Ignore the error and continue with the next iteration\n      }\n      if (got) break;\n    }\n\n    if (!got) {\n      try {\n        got = await getCompactCarCids(this.carLog[this.carLog.length - 1][0]);\n      } catch {\n        // Ignore the error and continue with the next iteration\n      }\n    }\n\n    return got;\n  }\n\n  async loadCar(cid: AnyLink): Promise<CarReader> {\n    if (!this.carStore) {\n      throw this.logger.Error().Msg(\"car store not initialized\").AsError();\n    }\n    const loaded = await this.storesLoadCar(cid, await this.carStore(), this.remoteCarStore);\n    return loaded;\n  }\n\n  async makeDecoderAndCarReader(cid: AnyLink, local: DataStore, remote?: DataStore): Promise<CarReader> {\n    const cidsString = cid.toString();\n    let loadedCar: AnyBlock | undefined = undefined;\n    let activeStore: BaseStore = local;\n    try {\n      //loadedCar now is an array of AnyBlocks\n      this.logger.Debug().Str(\"cid\", cidsString).Msg(\"loading car\");\n      loadedCar = await local.load(cid);\n      this.logger.Debug().Bool(\"loadedCar\", loadedCar).Msg(\"loaded\");\n    } catch (e) {\n      if (remote) {\n        const remoteCar = await remote.load(cid);\n        if (remoteCar) {\n          // todo test for this\n          this.logger.Debug().Ref(\"cid\", remoteCar.cid).Msg(\"saving remote car locally\");\n          await local.save(remoteCar);\n          loadedCar = remoteCar;\n          activeStore = remote;\n        }\n      } else {\n        this.logger.Error().Str(\"cid\", cidsString).Err(e).Msg(\"loading car\");\n      }\n    }\n    if (!loadedCar) {\n      throw this.logger.Error().Url(local.url()).Str(\"cid\", cidsString).Msg(\"missing car files\").AsError();\n    }\n    //This needs a fix as well as the fromBytes function expects a Uint8Array\n    //Either we can merge the bytes or return an array of rawReaders\n    const bytes = await decode({ bytes: loadedCar.bytes, hasher, codec: (await activeStore.keyedCrypto()).codec() }); // as Uint8Array,\n    const rawReader = await CarReader.fromBytes(bytes.value);\n    const readerP = Promise.resolve(rawReader);\n    // const kc = await activeStore.keyedCrypto()\n    // const readerP = !kc.isEncrypting ? Promise.resolve(rawReader) : this.ensureDecryptedReader(activeStore, rawReader);\n\n    const cachedReaderP = readerP.then(async (reader) => {\n      await this.cacheCarReader(cidsString, reader).catch((e) => {\n        this.logger.Error().Err(e).Str(\"cid\", cidsString).Msg(\"error caching car reader\");\n        return;\n      });\n      return reader;\n    });\n    this.carReaders.set(cidsString, cachedReaderP);\n    return readerP;\n  }\n\n  //What if instead it returns an Array of CarHeader\n  protected async storesLoadCar(cid: AnyLink, local: DataStore, remote?: DataStore): Promise<CarReader> {\n    const cidsString = cid.toString();\n    let dacr = this.carReaders.get(cidsString);\n    if (!dacr) {\n      dacr = this.makeDecoderAndCarReader(cid, local, remote);\n      this.carReaders.set(cidsString, dacr);\n    }\n    return dacr;\n  }\n\n  protected async getMoreReaders(cids: AnyLink[]) {\n    const limit = pLimit(5);\n    const missing = cids.filter((cid) => !this.carReaders.has(cid.toString()));\n    await Promise.all(missing.map((cid) => limit(() => this.loadCar(cid))));\n  }\n}\n","import { decode } from \"../runtime/wait-pr-multiformats/block.js\";\nimport { sha256 as hasher } from \"multiformats/hashes/sha2\";\nimport * as dagCodec from \"@fireproof/vendor/@ipld/dag-cbor\";\nimport type { Logger } from \"@adviser/cement\";\n\nimport { CarHeader } from \"./types.js\";\n// import { decodeRunLength } from \"../runtime/keyed-crypto.js\";\n// import { base58btc } from \"multiformats/bases/base58\";\nimport { CarReader } from \"@fireproof/vendor/@ipld/car/reader\";\n\n// export async function encodeCarHeader<T>(fp: CarHeader<T>) {\n//   return (await encode({\n//     value: { fp },\n//     hasher,\n//     codec: dagCodec,\n//   })) as AnyBlock;\n// }\n\n// function wrapDagDecoder<T>(dec: BlockDecoder<number, Uint8Array>): BlockDecoder<number, CarDecoded<T>> {\n//   return {\n//     code: dec.code,\n//     decode: async (block: Uint8Array) => dagCodec.decode(await dec.decode(block))\n//   }\n// }\n\ninterface CarDecoded<T> {\n  readonly fp: CarHeader<T>;\n}\n\nexport async function parseCarFile<T>(reader: CarReader, logger: Logger): Promise<CarHeader<T>> {\n  const roots = await reader.getRoots();\n  const header = await reader.get(roots[0]);\n  if (!header) throw logger.Error().Msg(\"missing header block\").AsError();\n  const dec = await decode({ bytes: header.bytes, hasher, codec: dagCodec });\n  // console.log(\"parseCarFile-done\", roots[0].toString(), header)\n  // const { value } = await decode({\n  //   bytes: header.bytes,\n  //   hasher,\n  //   codec: await wrapDagDecoder<T>({\n  //     code: dagCodec.code,\n  //     decode: (block) => {\n  //       const ui = new Uint8Array(block);\n  //       const iv = decodeRunLength(ui, 0, logger);\n  //       const key = decodeRunLength(ui, iv.next, logger);\n  //       // const fp = decodeRunLength(ui, key.next, logger);\n  //       console.log(\"parseCarFile\", { iv: iv.data.length, key: base58btc.encode(key.data) }, (new Error()).stack);\n  //       return ui\n  //     }\n  //   })\n  // });\n  const fpvalue = dec.value as CarDecoded<T>;\n  // @jchris where is the fp attribute coming from?\n  if (fpvalue && !fpvalue.fp) {\n    throw logger.Error().Msg(\"missing fp\").AsError();\n  }\n  return fpvalue.fp;\n}\n","import { MemoryBlockstore } from \"@fireproof/vendor/@web3-storage/pail/block\";\nimport { BlockFetcher as BlockFetcherApi } from \"@fireproof/vendor/@web3-storage/pail/api\";\n\nimport {\n  AnyAnyLink,\n  AnyBlock,\n  AnyLink,\n  CarMakeable,\n  TransactionMeta,\n  TransactionWrapper,\n  BlockstoreOpts,\n  BlockstoreRuntime,\n} from \"./types.js\";\n\nimport { Loader } from \"./loader.js\";\nimport type { CID, Block, Version } from \"multiformats\";\nimport { falsyToUndef, SuperThis } from \"../types.js\";\nimport { toStoreRuntime } from \"./store-factory.js\";\nimport { Logger, toCryptoRuntime } from \"@adviser/cement\";\nimport { ensureLogger, ensureSuperThis } from \"../utils.js\";\n\nexport type BlockFetcher = BlockFetcherApi;\n\nexport interface CarTransactionOpts {\n  readonly add: boolean;\n  readonly noLoader: boolean;\n}\n\nexport class CarTransaction extends MemoryBlockstore implements CarMakeable {\n  readonly parent: BaseBlockstore;\n  constructor(parent: BaseBlockstore, opts: CarTransactionOpts = { add: true, noLoader: false }) {\n    super();\n    if (opts.add) {\n      parent.transactions.add(this);\n    }\n    this.parent = parent;\n  }\n\n  async get<T, C extends number, A extends number, V extends Version>(cid: AnyLink): Promise<Block<T, C, A, V> | undefined> {\n    return ((await this.superGet(cid)) || falsyToUndef(await this.parent.get(cid))) as Block<T, C, A, V>;\n  }\n\n  async superGet(cid: AnyLink): Promise<AnyBlock | undefined> {\n    return super.get(cid);\n  }\n}\n\nexport function defaultedBlockstoreRuntime(\n  sthis: SuperThis,\n  opts: BlockstoreOpts,\n  component: string,\n  ctx?: Record<string, unknown>,\n): BlockstoreRuntime {\n  const logger = ensureLogger(sthis, component, ctx);\n  const store = opts.store || {};\n  return {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    applyMeta: (meta: TransactionMeta, snap?: boolean): Promise<void> => {\n      return Promise.resolve();\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    compact: async (blocks: BlockFetcher) => {\n      return {} as unknown as TransactionMeta;\n    },\n    autoCompact: 100,\n    public: false,\n    name: undefined,\n    threshold: 1000 * 1000,\n    ...opts,\n    logger,\n    keyBag: opts.keyBag || {},\n    crypto: toCryptoRuntime(opts.crypto),\n    store,\n    storeRuntime: toStoreRuntime(store, sthis),\n  };\n}\n\nexport function blockstoreFactory(sthis: SuperThis, opts: BlockstoreOpts): BaseBlockstore | EncryptedBlockstore {\n  if (opts.name) {\n    return new EncryptedBlockstore(sthis, opts);\n  } else {\n    return new BaseBlockstore(opts);\n  }\n}\n\nexport class BaseBlockstore implements BlockFetcher {\n  readonly transactions: Set<CarTransaction> = new Set<CarTransaction>();\n  readonly ebOpts: BlockstoreRuntime;\n  readonly sthis: SuperThis;\n\n  readonly loader?: Loader;\n  readonly name?: string;\n\n  // ready: Promise<void>;\n  ready(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  async close(): Promise<void> {\n    // no-op\n  }\n\n  async destroy(): Promise<void> {\n    // no-op\n  }\n\n  async compact(): Promise<void> {\n    // no-op\n  }\n\n  readonly logger: Logger;\n  constructor(ebOpts: BlockstoreOpts = {}) {\n    // console.log(\"BaseBlockstore\", ebOpts)\n    this.sthis = ensureSuperThis(ebOpts);\n    this.ebOpts = defaultedBlockstoreRuntime(this.sthis, ebOpts, \"BaseBlockstore\");\n    this.logger = this.ebOpts.logger;\n  }\n\n  async get<T, C extends number, A extends number, V extends Version>(cid: AnyAnyLink): Promise<Block<T, C, A, V> | undefined> {\n    if (!cid) throw this.logger.Error().Msg(\"required cid\").AsError();\n    for (const f of this.transactions) {\n      // if (Math.random() < 0.001) console.log('get', cid.toString(), this.transactions.size)\n      const v = await f.superGet(cid);\n      if (v) return v as Block<T, C, A, V>;\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async put(cid: AnyAnyLink, block: Uint8Array): Promise<void> {\n    throw this.logger.Error().Msg(\"use a transaction to put\").AsError();\n  }\n\n  lastTxMeta?: unknown; // TransactionMeta\n\n  async transaction<M extends TransactionMeta>(\n    fn: (t: CarTransaction) => Promise<M>,\n    _opts?: CarTransactionOpts,\n  ): Promise<TransactionWrapper<M>> {\n    const t = new CarTransaction(this, _opts);\n    const done: M = await fn(t);\n    this.lastTxMeta = done;\n    return { t, meta: done };\n  }\n\n  openTransaction(opts: CarTransactionOpts = { add: true, noLoader: false }): CarTransaction {\n    return new CarTransaction(this, opts);\n  }\n\n  async commitTransaction<M extends TransactionMeta>(\n    t: CarTransaction,\n    done: M,\n    opts: CarTransactionOpts,\n  ): Promise<TransactionWrapper<M>> {\n    if (!this.loader) throw this.logger.Error().Msg(\"loader required to commit\").AsError();\n    const cars = await this.loader?.commit<M>(t, done, opts);\n    if (this.ebOpts.autoCompact && this.loader.carLog.length > this.ebOpts.autoCompact) {\n      setTimeout(() => void this.compact(), 10);\n    }\n    if (cars) {\n      this.transactions.delete(t);\n      return { meta: done, cars, t };\n    }\n    throw this.logger.Error().Msg(\"failed to commit car files\").AsError();\n  }\n\n  async *entries(): AsyncIterableIterator<AnyBlock> {\n    const seen = new Set<string>();\n    for (const t of this.transactions) {\n      for await (const blk of t.entries()) {\n        if (seen.has(blk.cid.toString())) continue;\n        seen.add(blk.cid.toString());\n        yield blk;\n      }\n    }\n  }\n}\n\nexport class EncryptedBlockstore extends BaseBlockstore {\n  readonly name: string;\n  readonly loader: Loader;\n\n  ready(): Promise<void> {\n    return this.loader.ready();\n  }\n\n  close(): Promise<void> {\n    return this.loader.close();\n  }\n\n  destroy(): Promise<void> {\n    return this.loader.destroy();\n  }\n\n  compacting = false;\n  readonly logger: Logger;\n\n  constructor(sthis: SuperThis, ebOpts: BlockstoreOpts) {\n    super(ebOpts);\n    this.logger = ensureLogger(this.sthis, \"EncryptedBlockstore\");\n    const { name } = ebOpts;\n    if (!name) {\n      throw this.logger.Error().Msg(\"name required\").AsError();\n    }\n    this.name = name;\n    this.loader = new Loader(this.name, ebOpts, sthis);\n  }\n\n  async get<T, C extends number, A extends number, V extends Version>(cid: AnyAnyLink): Promise<Block<T, C, A, V> | undefined> {\n    const got = await super.get(cid);\n    if (got) return got as Block<T, C, A, V>;\n    if (!this.loader) {\n      return;\n    }\n    return falsyToUndef(await this.loader.getBlock(cid)) as Block<T, C, A, V>;\n  }\n\n  async transaction<M extends TransactionMeta>(\n    fn: (t: CarTransaction) => Promise<M>,\n    opts = { noLoader: false },\n  ): Promise<TransactionWrapper<M>> {\n    const { t, meta: done } = await super.transaction<M>(fn);\n    const cars = await this.loader.commit<M>(t, done, opts);\n    if (this.ebOpts.autoCompact && this.loader.carLog.length > this.ebOpts.autoCompact) {\n      setTimeout(() => void this.compact(), 10);\n    }\n    if (cars) {\n      this.transactions.delete(t);\n      return { meta: done, cars, t };\n    }\n    throw this.logger.Error().Msg(\"failed to commit car files\").AsError();\n  }\n\n  async getFile(car: AnyLink, cid: AnyLink /*, isPublic = false*/): Promise<Uint8Array> {\n    await this.ready();\n    if (!this.loader) throw this.logger.Error().Msg(\"loader required to get file, database must be named\").AsError();\n    const reader = await this.loader.loadFileCar(car /*, isPublic */);\n    const block = await reader.get(cid as CID);\n    if (!block) throw this.logger.Error().Str(\"cid\", cid.toString()).Msg(`Missing block`).AsError();\n    return block.bytes;\n  }\n\n  async compact() {\n    await this.ready();\n    if (!this.loader) throw this.logger.Error().Msg(\"loader required to compact\").AsError();\n    if (this.loader.carLog.length < 2) return;\n    const compactFn = this.ebOpts.compact || ((blocks: CompactionFetcher) => this.defaultCompact(blocks, this.logger));\n    if (!compactFn || this.compacting) return;\n    const blockLog = new CompactionFetcher(this);\n    this.compacting = true;\n    const meta = await compactFn(blockLog);\n    await this.loader?.commit(blockLog.loggedBlocks, meta, {\n      compact: true,\n      noLoader: true,\n    });\n    this.compacting = false;\n  }\n\n  async defaultCompact(blocks: CompactionFetcher, logger: Logger): Promise<TransactionMeta> {\n    // console.log('eb compact')\n    if (!this.loader) {\n      throw logger.Error().Msg(\"no loader\").AsError();\n    }\n    if (!this.lastTxMeta) {\n      throw logger.Error().Msg(\"no lastTxMeta\").AsError();\n    }\n    for await (const blk of this.loader.entries(false)) {\n      blocks.loggedBlocks.putSync(blk.cid, blk.bytes);\n    }\n    for (const t of this.transactions) {\n      for await (const blk of t.entries()) {\n        blocks.loggedBlocks.putSync(blk.cid, blk.bytes);\n      }\n    }\n    return this.lastTxMeta as TransactionMeta;\n  }\n\n  async *entries(): AsyncIterableIterator<AnyBlock> {\n    // const seen = new Set<string>();\n    for await (const blk of this.loader.entries()) {\n      // if (seen.has(blk.cid.toString())) continue\n      // seen.add(blk.cid.toString())\n      yield blk;\n    }\n  }\n}\n\nexport class CompactionFetcher implements BlockFetcher {\n  readonly blockstore: EncryptedBlockstore;\n  // loader: Loader | null = null\n  readonly loggedBlocks: CarTransaction;\n\n  constructor(blocks: EncryptedBlockstore) {\n    this.blockstore = blocks;\n    // this.loader = blocks.loader\n    this.loggedBlocks = new CarTransaction(blocks);\n  }\n\n  async get<T, C extends number, A extends number, V extends Version>(cid: AnyLink): Promise<Block<T, C, A, V> | undefined> {\n    const block = await this.blockstore.get(cid);\n    if (block) this.loggedBlocks.putSync(cid, block.bytes);\n    return falsyToUndef(block) as Block<T, C, A, V>;\n  }\n}\n","import { Future } from \"@adviser/cement\";\n\ntype QueueFunction<T = void> = () => Promise<T>;\n\nexport class CommitQueue<T = void> {\n  readonly queue: QueueFunction<void>[] = [];\n  processing = false;\n\n  readonly _waitIdleItems: Set<Future<void>> = new Set<Future<void>>();\n  waitIdle(): Promise<void> {\n    if (this.queue.length === 0 && !this.processing) {\n      return Promise.resolve();\n    }\n    const fn = new Future<void>();\n    this._waitIdleItems.add(fn);\n    return fn.asPromise();\n  }\n\n  async enqueue(fn: QueueFunction<T>): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      const queueFn = async () => {\n        try {\n          resolve(await fn());\n        } catch (e) {\n          reject(e);\n        } finally {\n          this.processing = false;\n          this.processNext();\n        }\n      };\n      this.queue.push(queueFn);\n      if (!this.processing) {\n        this.processNext();\n      }\n    });\n  }\n\n  processNext() {\n    if (this.queue.length > 0 && !this.processing) {\n      this.processing = true;\n      const queueFn = this.queue.shift();\n      if (queueFn) {\n        queueFn().finally(() => {\n          /**/\n        });\n      }\n    }\n    if (this.queue.length === 0 && !this.processing) {\n      const toResolve = Array.from(this._waitIdleItems);\n      this._waitIdleItems.clear();\n      toResolve.map((fn) => fn.resolve());\n    }\n  }\n}\n","import {\n  CoerceURI,\n  CryptoRuntime,\n  KeyedResolvOnce,\n  Logger,\n  ResolveOnce,\n  ResolveSeq,\n  Result,\n  runtimeFn,\n  toCryptoRuntime,\n  URI,\n} from \"@adviser/cement\";\nimport { KeyWithFingerExtract, KeyWithFingerPrint } from \"../blockstore/types.js\";\nimport { ensureLogger } from \"../utils.js\";\nimport { base58btc } from \"multiformats/bases/base58\";\nimport { SuperThis } from \"../types.js\";\n\nexport class KeyBag {\n  readonly logger: Logger;\n  constructor(readonly rt: KeyBagRuntime) {\n    this.logger = ensureLogger(rt.sthis, \"KeyBag\");\n    this.logger.Debug().Msg(\"KeyBag created\");\n  }\n\n  readonly _warnOnce: ResolveOnce<void> = new ResolveOnce<void>();\n  async subtleKey(key: string): Promise<CryptoKey> {\n    const extractable = this.rt.url.getParam(\"extractKey\") === \"_deprecated_internal_api\";\n    if (extractable) {\n      this._warnOnce.once(() =>\n        this.logger.Warn().Msg(\"extractKey is enabled via _deprecated_internal_api --- handle keys safely!!!\"),\n      );\n    }\n    return await this.rt.crypto.importKey(\n      \"raw\", // raw or jwk\n      base58btc.decode(key),\n      // hexStringToUint8Array(key), // raw data\n      \"AES-GCM\",\n      extractable,\n      [\"encrypt\", \"decrypt\"],\n    );\n  }\n\n  async ensureKeyFromUrl(url: URI, keyFactory: () => string): Promise<Result<URI>> {\n    // add storekey to url\n    const storeKey = url.getParam(\"storekey\");\n    if (storeKey === \"insecure\") {\n      return Result.Ok(url);\n    }\n    if (!storeKey) {\n      const keyName = `@${keyFactory()}@`;\n      const ret = await this.getNamedKey(keyName);\n      if (ret.isErr()) {\n        return ret as unknown as Result<URI>;\n      }\n      const urb = url.build().setParam(\"storekey\", keyName);\n      return Result.Ok(urb.URI());\n    }\n    if (storeKey.startsWith(\"@\") && storeKey.endsWith(\"@\")) {\n      const ret = await this.getNamedKey(storeKey);\n      if (ret.isErr()) {\n        return ret as unknown as Result<URI>;\n      }\n    }\n    return Result.Ok(url);\n  }\n\n  async toKeyWithFingerPrint(keyStr: string): Promise<Result<KeyWithFingerPrint>> {\n    const material = base58btc.decode(keyStr); //\n    const key = await this.subtleKey(keyStr);\n    const fpr = await this.rt.crypto.digestSHA256(material);\n    return Result.Ok({\n      key,\n      fingerPrint: base58btc.encode(new Uint8Array(fpr)),\n    });\n  }\n\n  readonly _seq: ResolveSeq<Result<KeyWithFingerPrint>> = new ResolveSeq<Result<KeyWithFingerPrint>>();\n  async setNamedKey(name: string, key: string): Promise<Result<KeyWithFingerPrint>> {\n    return this._seq.add(() => this._setNamedKey(name, key));\n  }\n\n  // avoid deadlock\n  async _setNamedKey(name: string, key: string): Promise<Result<KeyWithFingerPrint>> {\n    const item = {\n      name,\n      key: key,\n    };\n    const bag = await this.rt.getBag();\n    this.logger.Debug().Str(\"name\", name).Msg(\"setNamedKey\");\n    // there should be a version that throws if key exists\n    await bag.set(name, item);\n    return await this.toKeyWithFingerPrint(item.key);\n  }\n\n  async getNamedExtractableKey(name: string, failIfNotFound = false): Promise<Result<KeyWithFingerExtract>> {\n    const ret = await this.getNamedKey(name, failIfNotFound);\n    if (ret.isErr()) {\n      return ret as unknown as Result<KeyWithFingerExtract>;\n    }\n    const named = ret.Ok();\n    return Result.Ok({\n      ...named,\n      extract: async () => {\n        const ext = new Uint8Array((await this.rt.crypto.exportKey(\"raw\", named.key)) as ArrayBuffer);\n        return {\n          key: ext,\n          keyStr: base58btc.encode(ext),\n        };\n      },\n    });\n  }\n\n  async getNamedKey(name: string, failIfNotFound = false): Promise<Result<KeyWithFingerPrint>> {\n    const id = this.rt.sthis.nextId(4).str;\n    return this._seq.add(async () => {\n      const bag = await this.rt.getBag();\n      const named = await bag.get(name);\n      if (named) {\n        const fpr = await this.toKeyWithFingerPrint(named.key);\n        this.logger.Debug().Str(\"id\", id).Str(\"name\", name).Result(\"fpr\", fpr).Msg(\"fingerPrint getNamedKey\");\n        return fpr;\n      }\n      if (failIfNotFound) {\n        this.logger.Debug().Str(\"id\", id).Str(\"name\", name).Msg(\"failIfNotFound getNamedKey\");\n        return Result.Err(new Error(`Key not found: ${name}`));\n      }\n      // this.logger.Debug().Str(\"id\", id).Str(\"name\", name).Msg(\"createKey getNamedKey-pre\");\n      const ret = await this._setNamedKey(name, base58btc.encode(this.rt.crypto.randomBytes(this.rt.keyLength)));\n      this.logger.Debug().Str(\"id\", id).Str(\"name\", name).Result(\"fpr\", ret).Msg(\"createKey getNamedKey-post\");\n      return ret;\n    });\n  }\n}\n\nexport interface KeyItem {\n  readonly name: string;\n  readonly key: string;\n}\nexport type KeyBagFile = Record<string, KeyItem>;\n\nexport interface KeyBagOpts {\n  // in future you can encrypt the keybag with ?masterkey=xxxxx\n  readonly url: CoerceURI;\n  // readonly key: string; // key to encrypt the keybag\n  readonly crypto: CryptoRuntime;\n  readonly keyLength: number; // default: 16\n  // readonly logger: Logger;\n  readonly keyRuntime: KeyBagRuntime;\n}\n\nexport interface KeyBagProvider {\n  get(id: string): Promise<KeyItem | undefined>;\n  set(id: string, item: KeyItem): Promise<void>;\n}\nexport interface KeyBagRuntime {\n  readonly url: URI;\n  readonly crypto: CryptoRuntime;\n  readonly logger: Logger;\n  readonly sthis: SuperThis;\n  readonly keyLength: number;\n  // readonly key?: FPCryptoKey;\n  getBag(): Promise<KeyBagProvider>;\n  id(): string;\n}\n\nexport type KeyBackProviderFactory = (url: URI, sthis: SuperThis) => Promise<KeyBagProvider>;\n\nexport interface KeyBagProviderFactoryItem {\n  readonly protocol: string;\n  // if this is set the default protocol selection is overridden\n  readonly override?: boolean;\n  readonly factory: KeyBackProviderFactory;\n}\n\nconst keyBagProviderFactories = new Map<string, KeyBagProviderFactoryItem>(\n  [\n    {\n      protocol: \"file:\",\n      factory: async (url: URI, sthis: SuperThis) => {\n        const { KeyBagProviderImpl } = await import(\"@fireproof/core/node\");\n        return new KeyBagProviderImpl(url, sthis);\n      },\n    },\n    {\n      protocol: \"indexdb:\",\n      factory: async (url: URI, sthis: SuperThis) => {\n        const { KeyBagProviderImpl } = await import(\"@fireproof/core/web\");\n        return new KeyBagProviderImpl(url, sthis);\n      },\n    },\n  ].map((i) => [i.protocol, i]),\n);\n\nexport function registerKeyBagProviderFactory(item: KeyBagProviderFactoryItem) {\n  const protocol = item.protocol.endsWith(\":\") ? item.protocol : item.protocol + \":\";\n  keyBagProviderFactories.set(protocol, {\n    ...item,\n    protocol,\n  });\n}\n\nexport function defaultKeyBagUrl(sthis: SuperThis): URI {\n  let bagFnameOrUrl = sthis.env.get(\"FP_KEYBAG_URL\");\n  let url: URI;\n  if (runtimeFn().isBrowser) {\n    url = URI.from(bagFnameOrUrl || \"indexdb://fp-keybag\");\n  } else {\n    if (!bagFnameOrUrl) {\n      const home = sthis.env.get(\"HOME\");\n      bagFnameOrUrl = `${home}/.fireproof/keybag`;\n      url = URI.from(`file://${bagFnameOrUrl}`);\n    } else {\n      url = URI.from(bagFnameOrUrl);\n    }\n  }\n  const logger = ensureLogger(sthis, \"defaultKeyBagUrl\");\n  logger.Debug().Url(url).Msg(\"from env\");\n  return url;\n}\n\nfunction defaultKeyBagOpts(sthis: SuperThis, kbo: Partial<KeyBagOpts>): KeyBagRuntime {\n  if (kbo.keyRuntime) {\n    return kbo.keyRuntime;\n  }\n  const logger = ensureLogger(sthis, \"KeyBag\");\n  let url: URI;\n  if (kbo.url) {\n    url = URI.from(kbo.url);\n    logger.Debug().Url(url).Msg(\"from opts\");\n  } else {\n    url = defaultKeyBagUrl(sthis);\n  }\n  const kitem = keyBagProviderFactories.get(url.protocol);\n  if (!kitem) {\n    throw logger.Error().Url(url).Msg(\"unsupported protocol\").AsError();\n  }\n  const getBag = async () => kitem.factory(url, sthis);\n\n  if (url.hasParam(\"masterkey\")) {\n    throw logger.Error().Url(url).Msg(\"masterkey is not supported\").AsError();\n  }\n  return {\n    url,\n    crypto: kbo.crypto || toCryptoRuntime({}),\n    sthis,\n    logger,\n    keyLength: kbo.keyLength || 16,\n    getBag,\n    id: () => {\n      return url.toString();\n    },\n  };\n}\n\nconst _keyBags = new KeyedResolvOnce<KeyBag>();\nexport async function getKeyBag(sthis: SuperThis, kbo: Partial<KeyBagOpts> = {}): Promise<KeyBag> {\n  await sthis.start();\n  const rt = defaultKeyBagOpts(sthis, kbo);\n  return _keyBags.get(rt.id()).once(async () => new KeyBag(rt));\n}\n","import { FileTransactionMeta } from \"../types.js\";\nimport { CarTransaction } from \"./transaction.js\";\nimport {\n  AnyBlock,\n  AnyLink,\n  CarGroup,\n  CarHeader,\n  CarLog,\n  CarMakeable,\n  CommitOpts,\n  DataStore,\n  DbMeta,\n  MetaStore,\n  toCIDBlock,\n  TransactionMeta,\n  WALStore,\n} from \"./types.js\";\nimport * as CBW from \"@fireproof/vendor/@ipld/car/buffer-writer\";\nimport { CID } from \"multiformats\";\nimport { encode } from \"../runtime/wait-pr-multiformats/block.js\";\nimport { BlockEncoder } from \"../runtime/wait-pr-multiformats/codec-interface.js\";\nimport { sha256 as hasher } from \"multiformats/hashes/sha2\";\nimport * as dagCodec from \"@fireproof/vendor/@ipld/dag-cbor\";\n\nasync function encodeCarFile(roots: AnyLink[], t: CarMakeable, codec: BlockEncoder<number, Uint8Array>): Promise<AnyBlock> {\n  let size = 0;\n  const headerSize = CBW.headerLength({ roots } as { roots: CID<unknown, number, number, 1>[] });\n  size += headerSize;\n  for (const { cid, bytes } of t.entries()) {\n    size += CBW.blockLength({ cid, bytes } as CBW.Block);\n  }\n  const buffer = new Uint8Array(size);\n  const writer = CBW.createWriter(buffer, { headerSize });\n\n  for (const r of roots) {\n    writer.addRoot(r as CID<unknown, number, number, 1>);\n  }\n\n  for (const { cid, bytes } of t.entries()) {\n    writer.write({ cid, bytes } as CBW.Block);\n  }\n  writer.close();\n  return await encode({ value: writer.bytes, hasher, codec });\n}\n\nexport async function createCarFile(\n  encoder: BlockEncoder<number, Uint8Array>,\n  cid: AnyLink,\n  t: CarTransaction,\n): Promise<{ cid: AnyLink; bytes: Uint8Array }> {\n  // try {\n  return encodeCarFile([cid], t, encoder);\n  //   const keycr = await store.keyedCrypto()\n  //   return keycr.isEncrypting\n  //     ? await encryptedEncodeCarFile(this.logger, keycr, cid, t)\n  //     : await encodeCarFile([cid], t);\n  // } catch (e) {\n  // throw store.logger.Error().Err(e).Msg(\"error creating car file\").AsError();\n  // }\n}\n\nexport async function commitFiles(\n  fileStore: DataStore,\n  walStore: WALStore,\n  t: CarTransaction,\n  done: TransactionMeta,\n  // opts: CommitOpts = { noLoader: false, compact: false },\n): Promise<CarGroup> {\n  const { files: roots } = makeFileCarHeader(done as FileTransactionMeta) as {\n    files: AnyLink[];\n  };\n  const cids: AnyLink[] = [];\n  // const fileStore = await this.fileStore();\n  const codec = (await fileStore.keyedCrypto()).codec();\n  const cars = await prepareCarFilesFiles(codec, roots, t);\n  for (const car of cars) {\n    const { cid, bytes } = car;\n    // real deal\n    await fileStore.save({ cid, bytes });\n    await walStore.enqueueFile(cid /*, !!opts.public*/);\n    cids.push(cid);\n  }\n  return cids;\n}\n\nfunction makeFileCarHeader(result: FileTransactionMeta): TransactionMeta {\n  const files: AnyLink[] = [];\n  for (const [, meta] of Object.entries(result.files || {})) {\n    if (meta && typeof meta === \"object\" && \"cid\" in meta && meta !== null) {\n      files.push(meta.cid as AnyLink);\n    }\n  }\n  return { ...result, files };\n}\n\nasync function prepareCarFilesFiles(\n  encoder: BlockEncoder<number, Uint8Array>,\n  roots: AnyLink[],\n  t: CarTransaction,\n  // isPublic: boolean,\n): Promise<{ cid: AnyLink; bytes: Uint8Array }[]> {\n  // const theKey = isPublic ? null : await this._getKey();\n  // const kc = await store.keyedCrypto()\n  // const car = kc.isEncrypting\n  //   ? await encryptedEncodeCarFile(this.logger, kc, roots[0], t)\n  //   : await encodeCarFile(roots, t);\n  return [await encodeCarFile(roots, t, encoder)];\n}\n\n// PUR Commit\n\nfunction makeCarHeader<T>(meta: T, cars: CarLog, compact = false): CarHeader<T> {\n  const coreHeader = compact ? { cars: [], compact: cars } : { cars, compact: [] };\n  return { ...coreHeader, meta };\n}\n\nasync function encodeCarHeader<T>(fp: CarHeader<T>) {\n  return (await encode({\n    value: { fp },\n    hasher,\n    codec: dagCodec,\n  })) as AnyBlock;\n}\n\nexport interface CommitParams {\n  readonly encoder: BlockEncoder<number, Uint8Array>;\n  readonly carLog: CarLog;\n  readonly carStore: DataStore;\n  readonly WALStore: WALStore;\n  readonly metaStore: MetaStore;\n  readonly threshold?: number;\n}\n\nexport async function commit<T>(\n  params: CommitParams,\n  t: CarTransaction,\n  done: T,\n  opts: CommitOpts = { noLoader: false, compact: false },\n): Promise<{ cgrp: CarGroup; header: CarHeader<T> }> {\n  const fp = makeCarHeader<T>(done, params.carLog, !!opts.compact);\n  const rootBlock = await encodeCarHeader(fp);\n\n  const cars = await prepareCarFiles(params.encoder, params.threshold, rootBlock, t);\n  const cids: AnyLink[] = [];\n  for (const car of cars) {\n    const { cid, bytes } = car;\n    await params.carStore.save({ cid, bytes });\n    cids.push(cid);\n  }\n\n  // await this.cacheTransaction(t);\n  const newDbMeta = { cars: cids } as DbMeta;\n  await params.WALStore.enqueue(newDbMeta, opts);\n  await params.metaStore.save(newDbMeta);\n  return { cgrp: cids, header: fp };\n}\n\nasync function prepareCarFiles(\n  encoder: BlockEncoder<number, Uint8Array>,\n  threshold: number | undefined,\n  rootBlock: AnyBlock,\n  t: CarTransaction,\n): Promise<{ cid: AnyLink; bytes: Uint8Array }[]> {\n  // const theKey = isPublic ? undefined : await this._getKey();\n  const carFiles: { cid: AnyLink; bytes: Uint8Array }[] = [];\n  threshold = threshold || 128000 * 8; // remove the * 8 to fit partykit\n  let clonedt = new CarTransaction(t.parent, { add: false, noLoader: false });\n  clonedt.putSync(rootBlock.cid, rootBlock.bytes);\n  let newsize = CBW.blockLength(toCIDBlock(rootBlock));\n  let cidRootBlock = rootBlock;\n  for (const { cid, bytes } of t.entries()) {\n    newsize += CBW.blockLength(toCIDBlock({ cid: cid, bytes }));\n    if (newsize >= threshold) {\n      carFiles.push(await createCarFile(encoder, cidRootBlock.cid, clonedt));\n      clonedt = new CarTransaction(t.parent, { add: false, noLoader: false });\n      clonedt.putSync(cid, bytes);\n      cidRootBlock = { cid, bytes };\n      newsize = CBW.blockLength(toCIDBlock({ cid, bytes })); //+ CBW.blockLength(rootBlock)\n    } else {\n      clonedt.putSync(cid, bytes);\n    }\n  }\n  // HEREMENO\n  carFiles.push(await createCarFile(encoder, cidRootBlock.cid, clonedt));\n  // console.log(\"split to \", carFiles.length, \"files\")\n  return carFiles;\n}\n","import { Logger } from \"@adviser/cement\";\nimport type { CarClockLink, DbMeta } from \"./types.js\";\nimport { ensureLogger } from \"../utils.js\";\nimport { SuperThis } from \"../types.js\";\n\ninterface TaskItem {\n  readonly cid: string;\n  readonly dbMeta: DbMeta;\n  retries: number;\n}\n\nexport class TaskManager {\n  // we need to remove the events after some time\n  private readonly eventsWeHandled = new Set<string>();\n\n  private queue: TaskItem[] = [];\n  private isProcessing = false;\n\n  readonly logger: Logger;\n  readonly callback: (dbMeta: DbMeta) => Promise<void>;\n  constructor(sthis: SuperThis, callback: (dbMeta: DbMeta) => Promise<void>) {\n    this.logger = ensureLogger(sthis, \"TaskManager\");\n    this.callback = callback;\n  }\n\n  async handleEvent(cid: CarClockLink, parents: string[], dbMeta: DbMeta) {\n    for (const parent of parents) {\n      this.eventsWeHandled.add(parent.toString());\n    }\n    this.queue.push({ cid: cid.toString(), dbMeta, retries: 0 });\n    this.queue = this.queue.filter(({ cid }) => !this.eventsWeHandled.has(cid));\n    void this.processQueue();\n  }\n\n  private async processQueue() {\n    if (this.isProcessing) return;\n    this.isProcessing = true;\n    const filteredQueue = this.queue.filter(({ cid }) => !this.eventsWeHandled.has(cid));\n    const first = filteredQueue[0];\n    if (!first) {\n      this.isProcessing = false;\n      return;\n    }\n    try {\n      await this.callback(first.dbMeta);\n      this.eventsWeHandled.add(first.cid);\n      this.queue = this.queue.filter(({ cid }) => !this.eventsWeHandled.has(cid));\n    } catch (err) {\n      if (first.retries++ > 3) {\n        this.logger.Error().Str(\"cid\", first.cid).Msg(\"failed to process event block after 3 retries\");\n        this.queue = this.queue.filter(({ cid }) => cid !== first.cid);\n      }\n      await new Promise((resolve) => setTimeout(resolve, 50));\n      throw this.logger.Error().Err(err).Msg(\"failed to process event block\").AsError();\n    } finally {\n      this.isProcessing = false;\n      if (this.queue.length > 0) {\n        void this.processQueue();\n      }\n    }\n  }\n}\n","import { CryptoRuntime, Logger, URI } from \"@adviser/cement\";\nimport { BytesWithIv, CodecOpts, IvAndBytes, IvKeyIdData, KeyedCrypto, KeyWithFingerPrint } from \"../blockstore/index.js\";\nimport { ensureLogger, UInt8ArrayEqual } from \"../utils.js\";\nimport { KeyBag } from \"./key-bag.js\";\nimport type { BlockCodec } from \"./wait-pr-multiformats/codec-interface.js\";\nimport { base58btc } from \"multiformats/bases/base58\";\nimport { sha256 as hasher } from \"multiformats/hashes/sha2\";\nimport * as CBOR from \"@fireproof/vendor/cborg\";\nimport { SuperThis } from \"../types.js\";\n\ninterface GenerateIVFn {\n  calc(ko: KeyedCrypto, crypto: CryptoRuntime, data: Uint8Array): Promise<Uint8Array>;\n  verify(ko: KeyedCrypto, crypto: CryptoRuntime, iv: Uint8Array, data: Uint8Array): Promise<boolean>;\n}\n\nconst generateIV: Record<string, GenerateIVFn> = {\n  random: {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    calc: async (ko: KeyedCrypto, crypto: CryptoRuntime, data: Uint8Array): Promise<Uint8Array> => {\n      return crypto.randomBytes(ko.ivLength);\n    },\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    verify: async (ko: KeyedCrypto, crypto: CryptoRuntime, iv: Uint8Array, data: Uint8Array): Promise<boolean> => {\n      return true;\n    },\n  },\n  hash: {\n    calc: async (ko: KeyedCrypto, crypto: CryptoRuntime, data: Uint8Array): Promise<Uint8Array> => {\n      const hash = await hasher.digest(data);\n      const hashBytes = new Uint8Array(hash.bytes);\n      const hashArray = new Uint8Array(ko.ivLength);\n      for (let i = 0; i < hashBytes.length; i++) {\n        hashArray[i % ko.ivLength] ^= hashBytes[i];\n      }\n      return hashArray;\n    },\n    verify: async function (ko: KeyedCrypto, crypto: CryptoRuntime, iv: Uint8Array, data: Uint8Array): Promise<boolean> {\n      return ko.url.getParam(\"ivverify\") !== \"disable\" && UInt8ArrayEqual(iv, await this.calc(ko, crypto, data));\n    },\n  },\n};\n\nfunction getGenerateIVFn(url: URI, opts: Partial<CodecOpts>): GenerateIVFn {\n  const ivhash = opts.ivCalc || url.getParam(\"ivhash\") || \"hash\";\n  return generateIV[ivhash] || generateIV[\"hash\"];\n}\n\nexport class BlockIvKeyIdCodec implements BlockCodec<0x300539, Uint8Array> {\n  readonly code = 0x300539;\n  readonly name = \"Fireproof@encrypted-block:aes-gcm\";\n\n  readonly ko: KeyedCrypto;\n  readonly iv?: Uint8Array;\n  readonly opts: Partial<CodecOpts>;\n  constructor(ko: KeyedCrypto, iv?: Uint8Array, opts?: CodecOpts) {\n    this.ko = ko;\n    this.iv = iv;\n    this.opts = opts || {};\n  }\n\n  async encode(data: Uint8Array): Promise<Uint8Array> {\n    const calcIv = this.iv || (await getGenerateIVFn(this.ko.url, this.opts).calc(this.ko, this.ko.crypto, data));\n    const { iv } = this.ko.algo(calcIv);\n    const fprt = await this.ko.fingerPrint();\n    const keyId = base58btc.decode(fprt);\n    this.ko.logger.Debug().Str(\"fp\", fprt).Msg(\"encode\");\n    return CBOR.encode({\n      iv: iv,\n      keyId: keyId,\n      data: await this.ko._encrypt({ iv, bytes: data }),\n    } as IvKeyIdData);\n  }\n\n  async decode(abytes: Uint8Array | ArrayBuffer): Promise<Uint8Array> {\n    let bytes: Uint8Array;\n    if (abytes instanceof Uint8Array) {\n      bytes = abytes;\n    } else {\n      bytes = new Uint8Array(abytes);\n    }\n    const { iv, keyId, data } = CBOR.decode(bytes) as IvKeyIdData;\n    const fprt = await this.ko.fingerPrint();\n    this.ko.logger.Debug().Str(\"fp\", base58btc.encode(keyId)).Msg(\"decode\");\n    if (base58btc.encode(keyId) !== fprt) {\n      throw this.ko.logger.Error().Str(\"fp\", fprt).Str(\"keyId\", base58btc.encode(keyId)).Msg(\"keyId mismatch\").AsError();\n    }\n    const result = await this.ko._decrypt({ iv: iv, bytes: data });\n    if (!this.opts?.noIVVerify && !(await getGenerateIVFn(this.ko.url, this.opts).verify(this.ko, this.ko.crypto, iv, result))) {\n      throw this.ko.logger.Error().Msg(\"iv missmatch\").AsError();\n    }\n    return result;\n  }\n}\n\nclass keyedCrypto implements KeyedCrypto {\n  readonly ivLength = 12;\n  readonly logger: Logger;\n  readonly crypto: CryptoRuntime;\n  readonly key: KeyWithFingerPrint;\n  readonly isEncrypting = true;\n  readonly url: URI;\n  constructor(url: URI, key: KeyWithFingerPrint, cyopt: CryptoRuntime, sthis: SuperThis) {\n    this.logger = ensureLogger(sthis, \"keyedCrypto\");\n    this.crypto = cyopt;\n    this.key = key;\n    this.url = url;\n  }\n  fingerPrint(): Promise<string> {\n    return Promise.resolve(this.key.fingerPrint);\n  }\n  codec(iv?: Uint8Array, opts?: CodecOpts): BlockCodec<number, Uint8Array> {\n    return new BlockIvKeyIdCodec(this, iv, opts);\n  }\n  algo(iv?: Uint8Array) {\n    return {\n      name: \"AES-GCM\",\n      iv: iv || this.crypto.randomBytes(this.ivLength),\n      tagLength: 128,\n    };\n  }\n  async _decrypt(data: IvAndBytes): Promise<Uint8Array> {\n    this.logger.Debug().Len(data.bytes, \"bytes\").Len(data.iv, \"iv\").Str(\"fp\", this.key.fingerPrint).Msg(\"decrypting\");\n    return new Uint8Array(await this.crypto.decrypt(this.algo(data.iv), this.key.key, data.bytes));\n  }\n  async _encrypt(data: BytesWithIv): Promise<Uint8Array> {\n    this.logger.Debug().Len(data.bytes).Str(\"fp\", this.key.fingerPrint).Msg(\"encrypting\");\n    const a = this.algo(data.iv);\n    return new Uint8Array(await this.crypto.encrypt(a, this.key.key, data.bytes));\n  }\n}\n\nclass nullCodec implements BlockCodec<0x0, Uint8Array> {\n  readonly code = 0x0;\n  readonly name = \"Fireproof@unencrypted-block\";\n\n  encode(data: Uint8Array): Uint8Array {\n    return data;\n  }\n  decode(data: Uint8Array): Uint8Array {\n    return data;\n  }\n}\n\nclass noCrypto implements KeyedCrypto {\n  readonly ivLength = 0;\n  readonly code = 0x0;\n  readonly name = \"Fireproof@unencrypted-block\";\n  readonly logger: Logger;\n  readonly crypto: CryptoRuntime;\n  readonly isEncrypting = false;\n  readonly _fingerPrint = \"noCrypto:\" + Math.random();\n  readonly url: URI;\n  constructor(url: URI, cyrt: CryptoRuntime, sthis: SuperThis) {\n    this.logger = ensureLogger(sthis, \"noCrypto\");\n    this.crypto = cyrt;\n    this.url = url;\n  }\n\n  fingerPrint(): Promise<string> {\n    return Promise.resolve(this._fingerPrint);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  codec(iv?: Uint8Array): BlockCodec<number, Uint8Array> {\n    return new nullCodec();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  algo(iv?: Uint8Array): { name: string; iv: Uint8Array; tagLength: number } {\n    return {\n      name: \"noCrypto\",\n      iv: new Uint8Array(),\n      tagLength: 0,\n    };\n  }\n  _decrypt(): Promise<Uint8Array> {\n    throw this.logger.Error().Msg(\"noCrypto.decrypt not implemented\").AsError();\n  }\n  _encrypt(): Promise<Uint8Array> {\n    throw this.logger.Error().Msg(\"noCrypto.decrypt not implemented\").AsError();\n  }\n}\n\nexport async function keyedCryptoFactory(url: URI, kb: KeyBag, sthis: SuperThis): Promise<KeyedCrypto> {\n  const storekey = url.getParam(\"storekey\");\n  if (storekey && storekey !== \"insecure\") {\n    let rkey = await kb.getNamedKey(storekey, true);\n    if (rkey.isErr()) {\n      try {\n        rkey = await kb.toKeyWithFingerPrint(storekey);\n      } catch (e) {\n        throw (\n          sthis.logger\n            .Error()\n            .Err(e)\n            .Str(\"keybag\", kb.rt.id())\n            // .Result(\"key\", rkey)\n            .Str(\"name\", storekey)\n            .Msg(\"getNamedKey failed\")\n            .AsError()\n        );\n      }\n    }\n    return new keyedCrypto(url, rkey.Ok(), kb.rt.crypto, sthis);\n  }\n  return new noCrypto(url, kb.rt.crypto, sthis);\n}\n","import { Logger, Result, URI } from \"@adviser/cement\";\n\nimport { base58btc } from \"multiformats/bases/base58\";\nimport { encode, decode } from \"@fireproof/vendor/cborg\";\nimport { Gateway, GetResult, UnsubscribeResult, VoidResult } from \"./gateway.js\";\nimport { SuperThis } from \"../types.js\";\nimport { ensureSuperLog } from \"../utils.js\";\n\nfunction getFragSize(url: URI): number {\n  const fragSize = url.getParam(\"fragSize\");\n  let ret = 0;\n  if (fragSize) {\n    ret = parseInt(fragSize);\n  }\n  if (isNaN(ret) || ret <= 0) {\n    ret = 0;\n  }\n  return ret;\n}\n\nasync function getFrags(url: URI, innerGW: Gateway, headerSize: number, logger: Logger): Promise<Result<Fragment>[]> {\n  const fragSize = getFragSize(url);\n  if (!fragSize) {\n    const res = await innerGW.get(url);\n    if (res.isErr()) {\n      return [res as unknown as Result<Fragment>];\n    }\n    const data = res.unwrap();\n    return [\n      Result.Ok({\n        fid: new Uint8Array(0),\n        ofs: 0,\n        len: data.length,\n        data,\n      }),\n    ];\n  }\n  const firstRaw = await innerGW.get(url.build().setParam(\"ofs\", \"0\").URI());\n  if (firstRaw.isErr()) {\n    return [firstRaw as unknown as Result<Fragment>];\n  }\n  const firstFragment = decode(firstRaw.unwrap()) as Fragment;\n  const blockSize = firstFragment.data.length;\n  const ops: Promise<Result<Fragment>>[] = [Promise.resolve(Result.Ok(firstFragment))];\n  const fidStr = base58btc.encode(firstFragment.fid);\n  const fragUrl = url\n    .build()\n    .setParam(\"fid\", fidStr)\n    .setParam(\"len\", firstFragment.len.toString())\n    .setParam(\"headerSize\", headerSize.toString());\n\n  for (let ofs = blockSize; ofs < firstFragment.len; ofs += blockSize) {\n    ops.push(\n      (async (furl, ofs): Promise<Result<Fragment>> => {\n        const raw = await innerGW.get(furl);\n        if (raw.isErr()) {\n          return raw as unknown as Result<Fragment>;\n        }\n        const fragment = decode(raw.unwrap());\n        if (base58btc.encode(fragment.fid) !== fidStr) {\n          return Result.Err(logger.Error().Msg(\"Fragment fid mismatch\").AsError());\n        }\n        if (fragment.ofs !== ofs) {\n          return Result.Err(logger.Error().Uint64(\"ofs\", ofs).Msg(\"Fragment ofs mismatch\").AsError());\n        }\n        return Result.Ok(fragment);\n      })(fragUrl.setParam(\"ofs\", ofs.toString()).URI(), ofs),\n    );\n  }\n  return Promise.all(ops);\n}\n\ninterface Fragment {\n  readonly fid: Uint8Array;\n  readonly ofs: number;\n  readonly len: number;\n  readonly data: Uint8Array;\n}\n\nexport class FragmentGateway implements Gateway {\n  readonly sthis: SuperThis;\n  readonly logger: Logger;\n  readonly fidLength = 4;\n\n  readonly innerGW: Gateway;\n  headerSize = 32;\n\n  constructor(sthis: SuperThis, innerGW: Gateway) {\n    this.sthis = ensureSuperLog(sthis, \"FragmentGateway\");\n    this.logger = this.sthis.logger;\n    this.innerGW = innerGW;\n  }\n\n  slicer(url: URI, body: Uint8Array): Promise<VoidResult>[] {\n    const fragSize = getFragSize(url);\n    if (!fragSize) {\n      return [this.innerGW.put(url, body)];\n    }\n    const blocksize = fragSize - this.headerSize;\n    if (blocksize <= 0) {\n      throw this.logger\n        .Error()\n        .Uint64(\"fragSize\", fragSize)\n        .Uint64(\"headerSize\", this.headerSize)\n        .Msg(\"Fragment size is too small\")\n        .AsError();\n    }\n    const ops: Promise<VoidResult>[] = [];\n    const fid = this.sthis.nextId(this.fidLength);\n    const fragUrl = url\n      .build()\n      .setParam(\"fid\", fid.str)\n      .setParam(\"len\", body.length.toString())\n      .setParam(\"headerSize\", this.headerSize.toString());\n    for (let ofs = 0; ofs < body.length; ofs += blocksize) {\n      const block = encode({\n        fid: fid.bin,\n        ofs,\n        len: body.length,\n        data: body.slice(ofs, ofs + blocksize),\n      } as Fragment);\n      if (block.length > fragSize) {\n        throw this.logger.Error().Uint64(\"block\", block.length).Uint64(\"fragSize\", fragSize).Msg(\"Block size to big\").AsError();\n      }\n      ops.push(this.innerGW.put(fragUrl.setParam(\"ofs\", ofs.toString()).URI(), block));\n    }\n    return ops;\n  }\n\n  buildUrl(baseUrl: URI, key: string): Promise<Result<URI>> {\n    return this.innerGW.buildUrl(baseUrl, key);\n  }\n\n  async destroy(iurl: URI): Promise<Result<void>> {\n    return this.innerGW.destroy(iurl);\n  }\n\n  async start(url: URI): Promise<Result<URI>> {\n    this.headerSize =\n      encode({\n        fid: this.sthis.nextId(this.fidLength).bin,\n        ofs: 1024 * 1024, // 32bit\n        len: 16 * 1024 * 1024, // 32bit\n        data: new Uint8Array(1024),\n      }).length - 1024;\n    return this.innerGW.start(url);\n  }\n\n  async close(url: URI): Promise<VoidResult> {\n    return this.innerGW.close(url);\n  }\n\n  async put(url: URI, body: Uint8Array): Promise<VoidResult> {\n    await Promise.all(this.slicer(url, body));\n    return Result.Ok(undefined);\n  }\n\n  async get(url: URI): Promise<GetResult> {\n    const rfrags = await getFrags(url, this.innerGW, this.headerSize, this.logger);\n    let buffer: Uint8Array | undefined = undefined;\n    for (const rfrag of rfrags) {\n      if (rfrag.isErr()) {\n        return Result.Err(rfrag.Err());\n      }\n      const frag = rfrag.Ok();\n      buffer = buffer || new Uint8Array(frag.len);\n      buffer.set(frag.data, frag.ofs);\n    }\n    return Result.Ok(buffer || new Uint8Array(0));\n  }\n\n  async subscribe(url: URI, callback: (msg: Uint8Array) => void): Promise<UnsubscribeResult> {\n    if (this.innerGW.subscribe) {\n      return this.innerGW.subscribe(url, callback);\n    } else {\n      return Result.Err(this.logger.Error().Url(url).Msg(\"subscribe not supported\").AsError());\n    }\n  }\n\n  async delete(url: URI): Promise<VoidResult> {\n    const rfrags = await getFrags(url, this.innerGW, this.headerSize, this.logger);\n    for (const rfrag of rfrags) {\n      if (rfrag.isErr()) {\n        return Result.Err(rfrag.Err());\n      }\n      const frag = rfrag.Ok();\n      const fidStr = base58btc.encode(frag.fid);\n      const fragUrl = url\n        .build()\n        .setParam(\"fid\", fidStr)\n        .setParam(\"len\", frag.len.toString())\n        .setParam(\"headerSize\", this.headerSize.toString())\n        .URI();\n      await this.innerGW.delete(fragUrl);\n    }\n    return Result.Ok(undefined);\n  }\n}\n","import { format, parse } from \"@fireproof/vendor/@ipld/dag-json\";\nimport { EventBlock, decodeEventBlock } from \"@fireproof/vendor/@web3-storage/pail/clock\";\nimport { EventView } from \"@fireproof/vendor/@web3-storage/pail/clock/api\";\nimport type { DbMeta, CarClockHead, DbMetaEventBlock, CarClockLink } from \"./types.js\";\nimport { SuperThis, CRDTEntry } from \"../types.js\";\nimport { CID, Link } from \"multiformats\";\nimport { base64pad } from \"multiformats/bases/base64\";\nimport { Result, URI } from \"@adviser/cement\";\nimport { getKeyBag } from \"../runtime/key-bag.js\";\nimport { ensureLogger } from \"../utils.js\";\n\nexport async function decodeGatewayMetaBytesToDbMeta(sthis: SuperThis, byteHeads: Uint8Array) {\n  const crdtEntries = JSON.parse(sthis.txt.decode(byteHeads)) as CRDTEntry[];\n  if (!Array.isArray(crdtEntries)) {\n    sthis.logger.Debug().Str(\"crdtEntries\", JSON.stringify(crdtEntries)).Msg(\"No data in CRDT entries\");\n    return [];\n  }\n  if (!crdtEntries.length) {\n    sthis.logger.Debug().Any(\"byteHeads\", byteHeads).Msg(\"No CRDT entries found\");\n    return [];\n  }\n  const logger = ensureLogger(sthis, \"decodeGatewayMetaBytesToDbMeta\");\n  return Promise.all(\n    crdtEntries.map(async (crdtEntry) => {\n      const eventBlock = await decodeEventBlock<{ dbMeta: Uint8Array }>(base64pad.decode(crdtEntry.data));\n      const dbMeta = parse<DbMeta>(sthis.txt.decode(eventBlock.value.data.dbMeta));\n      logger\n        .Debug()\n        .Any(\"crdtEntry\", {\n          crdtEntry,\n          eventBlock,\n          dbMeta,\n          dbMetaStrings: dbMeta.cars.map((car) => car.toString()),\n        })\n        .Msg(\"CRDT entry\");\n      return {\n        eventCid: eventBlock.cid as CarClockLink,\n        parents: crdtEntry.parents,\n        dbMeta: dbMeta,\n      };\n    }),\n  );\n}\n\nexport async function setCryptoKeyFromGatewayMetaPayload(\n  uri: URI,\n  sthis: SuperThis,\n  data: Uint8Array,\n): Promise<Result<DbMeta | undefined>> {\n  try {\n    sthis.logger.Debug().Str(\"uri\", uri.toString()).Msg(\"Setting crypto key from gateway meta payload\");\n    const keyInfo = await decodeGatewayMetaBytesToDbMeta(sthis, data);\n    if (keyInfo.length) {\n      const dbMeta = keyInfo[0].dbMeta;\n      if (dbMeta.key) {\n        const kb = await getKeyBag(sthis);\n        const keyName = getStoreKeyName(uri);\n        const res = await kb.setNamedKey(keyName, dbMeta.key);\n        if (res.isErr()) {\n          sthis.logger.Debug().Str(\"keyName\", keyName).Str(\"dbMeta.key\", dbMeta.key).Msg(\"Failed to set named key\");\n          throw res.Err();\n        }\n      }\n      sthis.logger.Debug().Str(\"dbMeta.key\", dbMeta.key).Str(\"uri\", uri.toString()).Msg(\"Set crypto key from gateway meta payload\");\n      return Result.Ok(dbMeta);\n    }\n    sthis.logger.Debug().Any(\"data\", data).Msg(\"No crypto in gateway meta payload\");\n    return Result.Ok(undefined);\n  } catch (error) {\n    sthis.logger.Debug().Err(error).Msg(\"Failed to set crypto key from gateway meta payload\");\n    return Result.Err(error as Error);\n  }\n}\n\nexport async function addCryptoKeyToGatewayMetaPayload(uri: URI, sthis: SuperThis, body: Uint8Array): Promise<Result<Uint8Array>> {\n  try {\n    sthis.logger.Debug().Str(\"uri\", uri.toString()).Msg(\"Adding crypto key to gateway meta payload\");\n    const keyName = getStoreKeyName(uri);\n    const kb = await getKeyBag(sthis);\n    const res = await kb.getNamedExtractableKey(keyName, true);\n    if (res.isErr()) {\n      sthis.logger.Error().Str(\"keyName\", keyName).Msg(\"Failed to get named extractable key\");\n      throw res.Err();\n    }\n    const keyData = await res.Ok().extract();\n    const dbMetas = await decodeGatewayMetaBytesToDbMeta(sthis, body);\n    const { dbMeta, parents } = dbMetas[0]; // as { dbMeta: DbMeta };\n    const parentLinks = parents.map((p) => CID.parse(p) as CarClockLink);\n    dbMeta.key = keyData.keyStr;\n    const events = await Promise.all([dbMeta].map((dbMeta) => createDbMetaEventBlock(sthis, dbMeta, parentLinks)));\n    const encoded = await encodeEventsWithParents(sthis, events, parentLinks);\n    sthis.logger.Debug().Str(\"uri\", uri.toString()).Msg(\"Added crypto key to gateway meta payload\");\n    return Result.Ok(encoded);\n  } catch (error) {\n    sthis.logger.Error().Err(error).Msg(\"Failed to add crypto key to gateway meta payload\");\n    return Result.Err(error as Error);\n  }\n}\n\nexport function getStoreKeyName(url: URI): string {\n  const storeKeyName = [url.getParam(\"localName\") || url.getParam(\"name\")];\n  const idx = url.getParam(\"index\");\n  if (idx) {\n    storeKeyName.push(idx);\n  }\n  storeKeyName.push(\"data\");\n  return `@${storeKeyName.join(\":\")}@`;\n}\n\nexport async function createDbMetaEventBlock(sthis: SuperThis, dbMeta: DbMeta, parents: CarClockHead): Promise<DbMetaEventBlock> {\n  const event = await EventBlock.create(\n    {\n      dbMeta: sthis.txt.encode(format(dbMeta)),\n    },\n    parents as unknown as Link<EventView<{ dbMeta: Uint8Array }>, number, number, 1>[],\n  );\n  return event as EventBlock<{ dbMeta: Uint8Array }>;\n}\n\nexport async function encodeEventsWithParents(\n  sthis: SuperThis,\n  events: EventBlock<{ dbMeta: Uint8Array }>[],\n  parents: CarClockHead,\n): Promise<Uint8Array> {\n  const crdtEntries = events.map((event) => {\n    const base64String = base64pad.encode(event.bytes);\n    return {\n      cid: event.cid.toString(),\n      data: base64String,\n      parents: parents.map((p) => p.toString()),\n    };\n  });\n  return sthis.txt.encode(JSON.stringify(crdtEntries));\n}\n","import { URI } from \"@adviser/cement\";\nimport { MetaStoreImpl, DataStoreImpl, StoreOpts } from \"./store.js\";\nimport { SuperThis } from \"../types.js\";\n\n// export type LoadHandler = (dbMetas: DbMeta[]) => Promise<void>;\n// export function validateDataParams(params: DownloadDataFnParams | UploadDataFnParams, logger: Logger) {\n//   const { type, name, car } = params;\n//   if (!name) throw logger.Error().Msg(\"name is required\").AsError();\n//   if (!car) {\n//     throw logger.Error().Msg(\"car is required\").AsError();\n//   }\n//   if (type !== \"file\" && type !== \"data\") {\n//     throw logger.Error().Msg(\"type must be file or data\").AsError();\n//   }\n// }\n\n// export function validateMetaParams(params: DownloadMetaFnParams | UploadMetaFnParams, logger: Logger) {\n//   const { name, branch } = params;\n//   if (!name) throw logger.Error().Msg(\"name is required\").AsError();\n//   if (!branch) {\n//     throw logger.Error().Msg(\"branch is required\").AsError();\n//   }\n// }\n\n// export class RemoteDataStore extends DataStoreImpl {\n//   // just for explaining the concept\n// }\n\n// export class RemoteMetaStore extends MetaStoreImpl {\n//   // just for explaining the concept\n// }\n\nexport async function RemoteDataStore(sthis: SuperThis, name: string, url: URI, opts: StoreOpts) {\n  const ds = new DataStoreImpl(sthis, name, url, opts);\n  await ds.start();\n  return ds;\n}\nexport async function RemoteMetaStore(sthis: SuperThis, name: string, url: URI, opts: StoreOpts) {\n  const ms = new MetaStoreImpl(sthis, name, url, opts /* , true*/);\n  await ms.start();\n  return ms;\n}\n\n// export class RemoteWALStore extends WALStoreImpl {\n//   // basicly do nothing write the WAL into memory\n//   constructor(loader: Loadable) {\n\n//     //import { FileWALGateway } from \"../runtime/gateways/file/gateway.js\";\n//     // super(loader, new URL(\"file:///dummy?fs=mem\"), loader.logger, new FileWALGateway(loader.logger));\n//   }\n\n// }\n","import { Logger, URI } from \"@adviser/cement\";\n\nimport { throwFalsy } from \"../types.js\";\nimport { TaskManager } from \"./task-manager.js\";\nimport type { BlockstoreRuntime, Connection, Loadable } from \"./types.js\";\nimport { type Loader } from \"./loader.js\";\nimport { RemoteDataStore, RemoteMetaStore } from \"./store-remote.js\";\nimport { getGatewayFromURL } from \"./store-factory.js\";\nimport { getKeyBag } from \"../runtime/key-bag.js\";\n\nexport interface Connectable {\n  readonly blockstore: {\n    readonly loader?: Loader;\n    readonly ebOpts: BlockstoreRuntime;\n  };\n  readonly name?: string;\n  // readonly sthis: SuperThis;\n}\n\nexport abstract class ConnectionBase implements Connection {\n  // readonly ready: Promise<unknown>;\n  // todo move to LRU blockstore https://github.com/web3-storage/w3clock/blob/main/src/worker/block.js\n  // readonly eventBlocks = new MemoryBlockstore();\n  loader?: Loadable;\n  taskManager?: TaskManager;\n  loaded: Promise<void> = Promise.resolve();\n\n  readonly url: URI;\n\n  // abstract metaUpload(bytes: Uint8Array, params: UploadMetaFnParams): Promise<Uint8Array[] | Falsy>;\n  // abstract dataUpload(bytes: Uint8Array, params: UploadDataFnParams, opts?: { public?: boolean }): Promise<void>;\n  // abstract metaDownload(params: DownloadMetaFnParams): Promise<Uint8Array[] | Falsy>;\n  // abstract dataDownload(params: DownloadDataFnParams): Promise<Uint8Array | Falsy>;\n\n  readonly logger: Logger;\n  constructor(url: URI, logger: Logger) {\n    this.logger = logger;\n    this.url = url;\n  }\n\n  async refresh() {\n    await throwFalsy(throwFalsy(this.loader).remoteMetaStore).load();\n    await (await throwFalsy(this.loader).WALStore()).process();\n  }\n\n  async connect_X({ loader }: { readonly loader?: Loadable }) {\n    if (!loader) throw this.logger.Error().Msg(\"loader is required\").AsError();\n    await this.connectMeta_X({ loader });\n    await this.connectStorage_X({ loader });\n  }\n\n  async connectMeta_X({ loader }: { loader?: Loadable }) {\n    if (!loader) throw this.logger.Error().Msg(\"connectMeta_X: loader is required\").AsError();\n    this.loader = loader;\n    await this.onConnect();\n    const metaUrl = this.url.build().defParam(\"store\", \"meta\").URI();\n    const gateway = await getGatewayFromURL(metaUrl, this.loader.sthis);\n    if (!gateway) throw this.logger.Error().Url(metaUrl).Msg(\"connectMeta_X: gateway is required\").AsError();\n    const dbName = metaUrl.getParam(\"name\");\n    if (!dbName) throw this.logger.Error().Url(metaUrl).Msg(\"connectMeta_X: name is required\").AsError();\n    const remote = await RemoteMetaStore(loader.sthis, dbName, metaUrl, {\n      gateway: gateway.gateway,\n      keybag: () => getKeyBag(loader.sthis, loader.ebOpts.keyBag),\n      loader,\n    });\n    this.loader.remoteMetaStore = remote;\n    this.loaded = this.loader.ready().then(async () => {\n      return remote.load().then(async () => {\n        return (await throwFalsy(this.loader).WALStore()).process();\n      });\n    });\n  }\n\n  abstract onConnect(): Promise<void>;\n\n  async connectStorage_X({ loader }: { loader?: Loadable }) {\n    if (!loader) throw this.logger.Error().Msg(\"connectStorage_X: loader is required\").AsError();\n    this.loader = loader;\n    // const dataUrl = this.url.build().defParam(\"store\", \"data\").defParam(\"fragSize\", \"128000\").URI();\n    const dataUrl = this.url.build().defParam(\"store\", \"data\").URI();\n    const gateway = await getGatewayFromURL(dataUrl, this.loader.sthis);\n    if (!gateway) throw this.logger.Error().Url(dataUrl).Msg(\"connectStorage_X: gateway is required\").AsError();\n    const name = dataUrl.getParam(\"name\");\n    if (!name) throw this.logger.Error().Url(dataUrl).Msg(\"connectStorage_X: name is required\").AsError;\n    loader.remoteCarStore = await RemoteDataStore(loader.sthis, name, this.url, {\n      gateway: gateway.gateway,\n      keybag: () => getKeyBag(loader.sthis, this.loader?.ebOpts.keyBag),\n    });\n    // @jchris why we have a differention between remoteCarStore and remoteFileStore? -- file store is for on-demand attachment loading\n    // for now we don't have any difference but in superthis car store and\n    // file store could have different urls/gateways\n    loader.remoteFileStore = loader.remoteCarStore;\n  }\n\n  // move this stuff to connect\n  // async getDashboardURL(compact = true) {\n  //   const baseUrl = 'https://dashboard.fireproof.storage/'\n  //   if (!this.loader?.remoteCarStore) return new URL('/howto', baseUrl)\n  //   // if (compact) {\n  //   //   await this.compact()\n  //   // }\n  //   const currents = await this.loader?.metaStore?.load()\n  //   if (!currents) throw new Error(\"Can't sync empty database: save data first\")\n  //   if (currents.length > 1)\n  //     throw new Error(\"Can't sync database with split heads: make an update first\")\n  //   const current = currents[0]\n  //   const params = {\n  //     car: current.car.toString()\n  //   }\n  //   if (current.key) {\n  //     // @ts-ignore\n  //     params.key = current.key.toString()\n  //   }\n  //   // @ts-ignore\n  //   if (this.name) {\n  //     // @ts-ignore\n  //     params.name = this.name\n  //   }\n  //   const url = new URL('/import#' + new URLSearchParams(params).toString(), baseUrl)\n  //   console.log('Import to dashboard: ' + url.toString())\n  //   return url\n  // }\n\n  // openDashboard() {\n  //   void this.getDashboardURL().then(url => {\n  //     if (url) window.open(url.toString(), '_blank')\n  //   })\n  // }\n}\n","import type { Block, Link } from \"multiformats\";\nimport { create } from \"./runtime/wait-pr-multiformats/block.js\";\nimport { sha256 as hasher } from \"multiformats/hashes/sha2\";\nimport * as codec from \"@fireproof/vendor/@ipld/dag-cbor\";\n\n// @ts-expect-error \"charwise\" has no types\nimport charwise from \"charwise\";\n// @ts-expect-error \"prolly-trees\" has no types\nimport * as DbIndex from \"prolly-trees/db-index\";\n// @ts-expect-error \"prolly-trees\" has no types\nimport { bf, simpleCompare } from \"prolly-trees/utils\";\n// @ts-expect-error \"prolly-trees\" has no types\nimport { nocache as cache } from \"prolly-trees/cache\";\n// @ts-expect-error \"prolly-trees\" has no types\nimport { ProllyNode as BaseNode } from \"prolly-trees/db-index\";\n\nimport {\n  DocUpdate,\n  MapFn,\n  DocFragment,\n  IndexUpdate,\n  QueryOpts,\n  IndexRow,\n  DocWithId,\n  IndexKeyType,\n  IndexKey,\n  DocTypes,\n  DocObject,\n  IndexUpdateString,\n} from \"./types.js\";\nimport { CarTransaction, BlockFetcher, AnyLink, AnyBlock } from \"./blockstore/index.js\";\nimport { CRDT } from \"./crdt.js\";\n\nexport class IndexTree<K extends IndexKeyType, R extends DocFragment> {\n  cid?: AnyLink;\n  root?: ProllyNode<K, R>;\n}\n\ntype CompareRef = string | number;\nexport type CompareKey = [string | number, CompareRef];\n\nfunction refCompare(aRef: CompareRef, bRef: CompareRef) {\n  if (Number.isNaN(aRef)) return -1;\n  if (Number.isNaN(bRef)) throw new Error(\"ref may not be Infinity or NaN\");\n  if (aRef === Infinity) return 1;\n  // if (!Number.isFinite(bRef)) throw new Error('ref may not be Infinity or NaN')\n\n  return simpleCompare(aRef, bRef) as number;\n}\n\nfunction compare(a: CompareKey, b: CompareKey) {\n  const [aKey, aRef] = a;\n  const [bKey, bRef] = b;\n\n  const comp: number = simpleCompare(aKey, bKey);\n  if (comp !== 0) return comp;\n  return refCompare(aRef, bRef);\n}\n\nexport const byKeyOpts: StaticProllyOptions<CompareKey> = { cache, chunker: bf(30), codec, hasher, compare };\n\nexport const byIdOpts: StaticProllyOptions<unknown> = { cache, chunker: bf(30), codec, hasher, compare: simpleCompare };\n\nexport interface IndexDoc<K extends IndexKeyType> {\n  readonly key: IndexKey<K>;\n  readonly value: DocFragment;\n}\n\nexport interface IndexDocString {\n  readonly key: string;\n  readonly value: DocFragment;\n}\n\nexport function indexEntriesForChanges<T extends DocTypes, K extends IndexKeyType>(\n  changes: DocUpdate<T>[],\n  mapFn: MapFn<T>,\n): IndexDoc<K>[] {\n  const indexEntries: IndexDoc<K>[] = [];\n  changes.forEach(({ id: key, value, del }) => {\n    if (del || !value) return;\n    let mapCalled = false;\n    const mapReturn = mapFn({ ...(value as DocWithId<T>), _id: key }, (k: IndexKeyType, v?: DocFragment) => {\n      mapCalled = true;\n      if (typeof k === \"undefined\") return;\n      indexEntries.push({\n        key: [charwise.encode(k) as K, key],\n        value: v || null,\n      });\n    });\n    if (!mapCalled && mapReturn) {\n      indexEntries.push({\n        key: [charwise.encode(mapReturn) as K, key],\n        value: null,\n      });\n    }\n  });\n  return indexEntries;\n}\n\nfunction makeProllyGetBlock(blocks: BlockFetcher): (address: AnyLink) => Promise<AnyBlock> {\n  return async (address: AnyLink) => {\n    const block = await blocks.get(address);\n    if (!block) throw new Error(`Missing block ${address.toString()}`);\n    const { cid, bytes } = block;\n    return create({ cid, bytes, hasher, codec }) as Promise<AnyBlock>;\n  };\n}\n\nexport async function bulkIndex<K extends IndexKeyType, T extends DocFragment, CT>(\n  tblocks: CarTransaction,\n  inIndex: IndexTree<K, T>,\n  indexEntries: (IndexUpdate<K> | IndexUpdateString)[],\n  opts: StaticProllyOptions<CT>,\n): Promise<IndexTree<K, T>> {\n  if (!indexEntries.length) return inIndex;\n  if (!inIndex.root) {\n    if (!inIndex.cid) {\n      let returnRootBlock: Block | undefined = undefined;\n      let returnNode: ProllyNode<K, T> | undefined = undefined;\n\n      for await (const node of (await DbIndex.create({\n        get: makeProllyGetBlock(tblocks),\n        list: indexEntries,\n        ...opts,\n      })) as ProllyNode<K, T>[]) {\n        const block = await node.block;\n        await tblocks.put(block.cid, block.bytes);\n        returnRootBlock = block;\n        returnNode = node;\n      }\n      if (!returnNode || !returnRootBlock) throw new Error(\"failed to create index\");\n      return { root: returnNode, cid: returnRootBlock.cid };\n    } else {\n      inIndex.root = (await DbIndex.load({ cid: inIndex.cid, get: makeProllyGetBlock(tblocks), ...opts })) as ProllyNode<K, T>;\n    }\n  }\n  const { root, blocks: newBlocks } = await inIndex.root.bulk(indexEntries);\n  if (root) {\n    for await (const block of newBlocks) {\n      await tblocks.put(block.cid, block.bytes);\n    }\n    return { root, cid: (await root.block).cid };\n  } else {\n    return { root: undefined, cid: undefined };\n  }\n}\n\nexport async function loadIndex<K extends IndexKeyType, T extends DocFragment, CT>(\n  tblocks: BlockFetcher,\n  cid: AnyLink,\n  opts: StaticProllyOptions<CT>,\n): Promise<ProllyNode<K, T>> {\n  return (await DbIndex.load({ cid, get: makeProllyGetBlock(tblocks), ...opts })) as ProllyNode<K, T>;\n}\n\nexport async function applyQuery<K extends IndexKeyType, T extends DocObject, R extends DocFragment>(\n  crdt: CRDT<T>,\n  resp: { result: ProllyIndexRow<K, R>[] },\n  query: QueryOpts<K>,\n): Promise<{\n  rows: IndexRow<K, T, R>[];\n}> {\n  if (query.descending) {\n    resp.result = resp.result.reverse();\n  }\n  if (query.limit) {\n    resp.result = resp.result.slice(0, query.limit);\n  }\n  if (query.includeDocs) {\n    resp.result = await Promise.all(\n      resp.result.map(async (row) => {\n        const val = await crdt.get(row.id);\n        const doc = val ? ({ ...val.doc, _id: row.id } as DocWithId<T>) : undefined;\n        return { ...row, doc };\n      }),\n    );\n  }\n  return {\n    rows: resp.result.map(({ key, ...row }) => {\n      return {\n        key: charwise.decode(key),\n        ...row,\n      };\n    }),\n  };\n}\n\nexport function encodeRange(range: [IndexKeyType, IndexKeyType]): [string, string] {\n  return [charwise.encode(range[0]), charwise.encode(range[1])];\n}\n\nexport function encodeKey(key: DocFragment): string {\n  return charwise.encode(key) as string;\n}\n\nexport interface ProllyIndexRow<K extends IndexKeyType, T extends DocFragment> {\n  readonly id: string;\n  readonly key: IndexKey<K>;\n  readonly value: T;\n}\n\n// ProllyNode type based on the ProllyNode from 'prolly-trees/base'\ninterface ProllyNode<K extends IndexKeyType, T extends DocFragment> extends BaseNode {\n  getAllEntries(): PromiseLike<{ [x: string]: unknown; result: ProllyIndexRow<K, T>[] }>;\n  getMany<KI extends IndexKeyType>(removeIds: KI[]): Promise<{ /* [x: K]: unknown; */ result: IndexKey<K>[] }>;\n  range(a: string, b: string): Promise<{ result: ProllyIndexRow<K, T>[] }>;\n  get(key: string): Promise<{ result: ProllyIndexRow<K, T>[] }>;\n  bulk(bulk: (IndexUpdate<K> | IndexUpdateString)[]): PromiseLike<{\n    readonly root?: ProllyNode<K, T>;\n    readonly blocks: Block[];\n  }>;\n  readonly address: Promise<Link>;\n  readonly distance: number;\n  compare: (a: unknown, b: unknown) => number;\n  readonly cache: unknown;\n  readonly block: Promise<Block>;\n}\n\ninterface StaticProllyOptions<T> {\n  readonly cache: unknown;\n  chunker: (entry: T, distance: number) => boolean;\n  readonly codec: unknown;\n  readonly hasher: unknown;\n  compare: (a: T, b: T) => number;\n}\n","import {\n  type ClockHead,\n  type DocUpdate,\n  type MapFn,\n  type IndexUpdate,\n  type QueryOpts,\n  type IdxMeta,\n  type DocFragment,\n  type IdxMetaMap,\n  type IndexKeyType,\n  type IndexRows,\n  type DocTypes,\n  type IndexUpdateString,\n  throwFalsy,\n  IndexTransactionMeta,\n  SuperThis,\n} from \"./types.js\";\nimport { BaseBlockstore } from \"./blockstore/index.js\";\n\nimport {\n  bulkIndex,\n  indexEntriesForChanges,\n  byIdOpts,\n  byKeyOpts,\n  IndexTree,\n  applyQuery,\n  encodeRange,\n  encodeKey,\n  loadIndex,\n  IndexDocString,\n  CompareKey,\n} from \"./indexer-helpers.js\";\nimport { CRDT } from \"./crdt.js\";\nimport { ensureLogger } from \"./utils.js\";\nimport { Logger } from \"@adviser/cement\";\n\nexport function index<K extends IndexKeyType = string, T extends DocTypes = NonNullable<unknown>, R extends DocFragment = T>(\n  sthis: SuperThis,\n  { _crdt }: { _crdt: CRDT<T> | CRDT<NonNullable<unknown>> },\n  name: string,\n  mapFn?: MapFn<T>,\n  meta?: IdxMeta,\n): Index<K, T, R> {\n  if (mapFn && meta) throw _crdt.logger.Error().Msg(\"cannot provide both mapFn and meta\").AsError();\n  if (mapFn && mapFn.constructor.name !== \"Function\") throw _crdt.logger.Error().Msg(\"mapFn must be a function\").AsError();\n  if (_crdt.indexers.has(name)) {\n    const idx = _crdt.indexers.get(name) as unknown as Index<K, T>;\n    idx.applyMapFn(name, mapFn, meta);\n  } else {\n    const idx = new Index<K, T>(sthis, _crdt, name, mapFn, meta);\n    _crdt.indexers.set(name, idx as unknown as Index<K, NonNullable<unknown>, NonNullable<unknown>>);\n  }\n  return _crdt.indexers.get(name) as unknown as Index<K, T, R>;\n}\n\n// interface ByIdIndexIten<K extends IndexKeyType> {\n//   readonly key: K;\n//   readonly value: [K, K];\n// }\n\nexport class Index<K extends IndexKeyType, T extends DocTypes, R extends DocFragment = T> {\n  readonly blockstore: BaseBlockstore;\n  readonly crdt: CRDT<T>;\n  name: string;\n  mapFn?: MapFn<T>;\n  mapFnString = \"\";\n  byKey: IndexTree<K, R> = new IndexTree<K, R>();\n  byId: IndexTree<K, R> = new IndexTree<K, R>();\n  indexHead?: ClockHead;\n  includeDocsDefault = false;\n  initError?: Error;\n\n  ready(): Promise<void> {\n    return Promise.all([this.blockstore.ready(), this.crdt.ready()]).then(() => {\n      /* noop */\n    });\n  }\n\n  close(): Promise<void> {\n    return Promise.all([this.blockstore.close(), this.crdt.close()]).then(() => {\n      /* noop */\n    });\n  }\n  destroy(): Promise<void> {\n    return Promise.all([this.blockstore.destroy(), this.crdt.destroy()]).then(() => {\n      /* noop */\n    });\n  }\n\n  readonly logger: Logger;\n\n  constructor(sthis: SuperThis, crdt: CRDT<T> | CRDT<NonNullable<unknown>>, name: string, mapFn?: MapFn<T>, meta?: IdxMeta) {\n    this.logger = ensureLogger(sthis, \"Index\");\n    this.blockstore = crdt.indexBlockstore;\n    this.crdt = crdt as CRDT<T>;\n    this.applyMapFn(name, mapFn, meta);\n    this.name = name;\n    if (!(this.mapFnString || this.initError)) throw this.logger.Error().Msg(\"missing mapFnString\").AsError();\n    // this.ready = this.blockstore.ready.then(() => {\n    //   return;\n    // });\n    // .then((header: IdxCarHeader) => {\n    //     // @ts-ignore\n    //     if (header.head) throw new Error('cannot have head in idx header')\n    //     if (header.indexes === undefined) throw new Error('missing indexes in idx header')\n    //     // for (const [name, idx] of Object.entries(header.indexes)) {\n    //     //   index({ _crdt: crdt }, name, undefined, idx as IdxMeta)\n    //     // }\n    //   })\n  }\n\n  applyMapFn(name: string, mapFn?: MapFn<T>, meta?: IdxMeta) {\n    if (mapFn && meta) throw this.logger.Error().Msg(\"cannot provide both mapFn and meta\").AsError();\n    if (this.name && this.name !== name) throw this.logger.Error().Msg(\"cannot change name\").AsError();\n    this.name = name;\n    try {\n      if (meta) {\n        // hydrating from header\n        if (this.indexHead && this.indexHead.map((c) => c.toString()).join() !== meta.head.map((c) => c.toString()).join()) {\n          throw this.logger.Error().Msg(\"cannot apply different head meta\").AsError();\n        }\n\n        if (this.mapFnString) {\n          // we already initialized from application code\n          if (this.mapFnString !== meta.map) {\n            this.logger\n              .Warn()\n              .Msg(`cannot apply different mapFn meta: old mapFnString ${this.mapFnString} new mapFnString ${meta.map}`);\n            // throw new Error('cannot apply different mapFn meta')\n          } else {\n            this.byId.cid = meta.byId;\n            this.byKey.cid = meta.byKey;\n            this.indexHead = meta.head;\n          }\n        } else {\n          // we are first\n          this.mapFnString = meta.map;\n          this.byId.cid = meta.byId;\n          this.byKey.cid = meta.byKey;\n          this.indexHead = meta.head;\n        }\n      } else {\n        if (this.mapFn) {\n          // we already initialized from application code\n          if (mapFn) {\n            if (this.mapFn.toString() !== mapFn.toString()) {\n              this.logger.Error().Msg(\"cannot apply different mapFn app2\");\n            }\n          }\n        } else {\n          // application code is creating an index\n          if (!mapFn) {\n            mapFn = ((doc) => (doc as unknown as Record<string, unknown>)[name] ?? undefined) as MapFn<T>;\n          }\n          if (this.mapFnString) {\n            // we already loaded from a header\n            if (this.mapFnString !== mapFn.toString()) {\n              this.logger\n                .Error()\n                .Str(\"mapFnString\", this.mapFnString)\n                .Str(\"mapFn\", mapFn.toString())\n                .Msg(\"cannot apply different mapFn app\");\n            }\n          } else {\n            // we are first\n            this.mapFnString = mapFn.toString();\n          }\n          this.mapFn = mapFn;\n        }\n      }\n      const matches = /=>\\s*(.*)/.test(this.mapFnString);\n      this.includeDocsDefault = matches;\n    } catch (e) {\n      this.initError = e as Error;\n    }\n  }\n\n  async query(opts: QueryOpts<K> = {}): Promise<IndexRows<K, T, R>> {\n    await this.ready();\n    // this._resetIndex();\n    await this._updateIndex();\n    await this._hydrateIndex();\n    if (!this.byKey.root) {\n      return await applyQuery<K, T, R>(this.crdt, { result: [] }, opts);\n    }\n    if (this.includeDocsDefault && opts.includeDocs === undefined) opts.includeDocs = true;\n    if (opts.range) {\n      const eRange = encodeRange(opts.range);\n      return await applyQuery<K, T, R>(this.crdt, await throwFalsy(this.byKey.root).range(eRange[0], eRange[1]), opts);\n    }\n    if (opts.key) {\n      const encodedKey = encodeKey(opts.key);\n      return await applyQuery<K, T, R>(this.crdt, await throwFalsy(this.byKey.root).get(encodedKey), opts);\n    }\n    if (Array.isArray(opts.keys)) {\n      const results = await Promise.all(\n        opts.keys.map(async (key: DocFragment) => {\n          const encodedKey = encodeKey(key);\n          return (await applyQuery<K, T, R>(this.crdt, await throwFalsy(this.byKey.root).get(encodedKey), opts)).rows;\n        }),\n      );\n      return { rows: results.flat() };\n    }\n    if (opts.prefix) {\n      if (!Array.isArray(opts.prefix)) opts.prefix = [opts.prefix];\n      // prefix should be always an array\n      const start = [...opts.prefix, NaN];\n      const end = [...opts.prefix, Infinity];\n      const encodedR = encodeRange([start, end]);\n      return await applyQuery<K, T, R>(this.crdt, await this.byKey.root.range(...encodedR), opts);\n    }\n    const all = await this.byKey.root.getAllEntries(); // funky return type\n    return await applyQuery<K, T, R>(\n      this.crdt,\n      {\n        // @ts-expect-error getAllEntries returns a different type than range\n        result: all.result.map(({ key: [k, id], value }) => ({\n          key: k,\n          id,\n          value,\n        })),\n      },\n      opts,\n    );\n  }\n\n  _resetIndex() {\n    this.byId = new IndexTree();\n    this.byKey = new IndexTree();\n    this.indexHead = undefined;\n  }\n\n  async _hydrateIndex() {\n    if (this.byId.root && this.byKey.root) return;\n    if (!this.byId.cid || !this.byKey.cid) return;\n    this.byId.root = await loadIndex<K, R, K>(this.blockstore, this.byId.cid, byIdOpts);\n    this.byKey.root = await loadIndex<K, R, CompareKey>(this.blockstore, this.byKey.cid, byKeyOpts);\n  }\n\n  async _updateIndex(): Promise<IndexTransactionMeta> {\n    await this.ready();\n    if (this.initError) throw this.initError;\n    if (!this.mapFn) throw this.logger.Error().Msg(\"No map function defined\").AsError();\n    let result: DocUpdate<T>[], head: ClockHead;\n    if (!this.indexHead || this.indexHead.length === 0) {\n      ({ result, head } = await this.crdt.allDocs());\n    } else {\n      ({ result, head } = await this.crdt.changes(this.indexHead));\n    }\n    if (result.length === 0) {\n      this.indexHead = head;\n      // return { byId: this.byId, byKey: this.byKey } as IndexTransactionMeta;\n    }\n    let staleKeyIndexEntries: IndexUpdate<K>[] = [];\n    let removeIdIndexEntries: IndexUpdateString[] = [];\n    if (this.byId.root) {\n      const removeIds = result.map(({ id: key }) => key);\n      const { result: oldChangeEntries } = await this.byId.root.getMany(removeIds);\n      staleKeyIndexEntries = oldChangeEntries.map((key) => ({ key, del: true }));\n      removeIdIndexEntries = oldChangeEntries.map((key) => ({ key: key[1], del: true }));\n    }\n    const indexEntries = indexEntriesForChanges<T, K>(result, this.mapFn); // use a getter to translate from string\n    const byIdIndexEntries: IndexDocString[] = indexEntries.map(({ key }) => ({\n      key: key[1],\n      value: key,\n    }));\n    const indexerMeta: IdxMetaMap = { indexes: new Map() };\n\n    for (const [name, indexer] of this.crdt.indexers) {\n      if (indexer.indexHead) {\n        indexerMeta.indexes?.set(name, {\n          byId: indexer.byId.cid,\n          byKey: indexer.byKey.cid,\n          head: indexer.indexHead,\n          map: indexer.mapFnString,\n          name: indexer.name,\n        } as IdxMeta);\n      }\n    }\n    if (result.length === 0) {\n      return indexerMeta as unknown as IndexTransactionMeta;\n    }\n    const { meta } = await this.blockstore.transaction<IndexTransactionMeta>(async (tblocks): Promise<IndexTransactionMeta> => {\n      this.byId = await bulkIndex<K, R, K>(tblocks, this.byId, removeIdIndexEntries.concat(byIdIndexEntries), byIdOpts);\n      this.byKey = await bulkIndex<K, R, CompareKey>(tblocks, this.byKey, staleKeyIndexEntries.concat(indexEntries), byKeyOpts);\n      this.indexHead = head;\n      if (this.byId.cid && this.byKey.cid) {\n        const idxMeta = {\n          byId: this.byId.cid,\n          byKey: this.byKey.cid,\n          head,\n          map: this.mapFnString,\n          name: this.name,\n        } as IdxMeta;\n        indexerMeta.indexes?.set(this.name, idxMeta);\n      }\n      return indexerMeta as unknown as IndexTransactionMeta;\n    });\n    return meta;\n  }\n}\n","import { advance } from \"@fireproof/vendor/@web3-storage/pail/clock\";\nimport { root } from \"@fireproof/vendor/@web3-storage/pail/crdt\";\nimport { Logger, ResolveOnce } from \"@adviser/cement\";\n\nimport { clockChangesSince } from \"./crdt-helpers.js\";\nimport type { BaseBlockstore, CarTransaction } from \"./blockstore/index.js\";\nimport { type DocUpdate, type ClockHead, type DocTypes, throwFalsy } from \"./types.js\";\nimport { applyHeadQueue, ApplyHeadQueue } from \"./apply-head-queue.js\";\nimport { ensureLogger } from \"./utils.js\";\n\nexport class CRDTClock<T extends DocTypes> {\n  // todo: track local and remote clocks independently, merge on read\n  // that way we can drop the whole remote if we need to\n  // should go with making sure the local clock only references locally available blockstore on write\n  head: ClockHead = [];\n\n  readonly zoomers: Set<() => void> = new Set<() => void>();\n  readonly watchers: Set<(updates: DocUpdate<T>[]) => void> = new Set<(updates: DocUpdate<T>[]) => void>();\n  readonly emptyWatchers: Set<() => void> = new Set<() => void>();\n\n  readonly blockstore: BaseBlockstore;\n\n  readonly applyHeadQueue: ApplyHeadQueue<T>;\n  transaction?: CarTransaction;\n\n  readonly _ready: ResolveOnce<void> = new ResolveOnce<void>();\n  async ready(): Promise<void> {\n    return this._ready.once(async () => {\n      await this.blockstore.ready();\n    });\n  }\n\n  async close() {\n    await this.blockstore.close();\n  }\n\n  readonly logger: Logger;\n  constructor(blockstore: BaseBlockstore) {\n    this.blockstore = blockstore;\n    this.logger = ensureLogger(blockstore.sthis, \"CRDTClock\");\n    this.applyHeadQueue = applyHeadQueue(this.int_applyHead.bind(this), this.logger);\n  }\n\n  setHead(head: ClockHead) {\n    this.head = head;\n  }\n\n  async applyHead(newHead: ClockHead, prevHead: ClockHead, updates?: DocUpdate<T>[]): Promise<void> {\n    for await (const { updates: updatesAcc, all } of this.applyHeadQueue.push({\n      newHead,\n      prevHead,\n      updates,\n    })) {\n      return this.processUpdates(updatesAcc, all, prevHead);\n    }\n  }\n\n  async processUpdates(updatesAcc: DocUpdate<T>[], all: boolean, prevHead: ClockHead) {\n    let internalUpdates = updatesAcc;\n    if (this.watchers.size && !all) {\n      const changes = await clockChangesSince<T>(throwFalsy(this.blockstore), this.head, prevHead, {}, this.logger);\n      internalUpdates = changes.result;\n    }\n    this.zoomers.forEach((fn) => fn());\n    this.notifyWatchers(internalUpdates || []);\n  }\n\n  notifyWatchers(updates: DocUpdate<T>[]) {\n    this.emptyWatchers.forEach((fn) => fn());\n    this.watchers.forEach((fn) => fn(updates || []));\n  }\n\n  onTick(fn: (updates: DocUpdate<T>[]) => void) {\n    this.watchers.add(fn);\n  }\n\n  onTock(fn: () => void) {\n    this.emptyWatchers.add(fn);\n  }\n\n  onZoom(fn: () => void) {\n    this.zoomers.add(fn);\n  }\n\n  async int_applyHead(newHead: ClockHead, prevHead: ClockHead, localUpdates: boolean) {\n    // if (!(this.head && prevHead && newHead)) {\n    //   throw new Error(\"missing head\");\n    // }\n    const noLoader = !localUpdates;\n\n    // console.log(\"int_applyHead\", this.applyHeadQueue.size(), this.head, newHead, prevHead, localUpdates);\n    const ogHead = sortClockHead(this.head);\n    newHead = sortClockHead(newHead);\n    if (compareClockHeads(ogHead, newHead)) {\n      return;\n    }\n    const ogPrev = sortClockHead(prevHead);\n    if (compareClockHeads(ogHead, ogPrev)) {\n      this.setHead(newHead);\n      return;\n    }\n\n    // const noLoader = this.head.length === 1 && !updates?.length\n    if (!this.blockstore) {\n      throw this.logger.Error().Msg(\"missing blockstore\").AsError();\n    }\n    await validateBlocks(this.logger, newHead, this.blockstore);\n    if (!this.transaction) {\n      this.transaction = this.blockstore.openTransaction({ noLoader, add: false });\n    }\n    const tblocks = this.transaction;\n\n    const advancedHead = await advanceBlocks(this.logger, newHead, tblocks, this.head);\n    const result = await root(tblocks, advancedHead);\n    for (const { cid, bytes } of [\n      ...result.additions,\n      // ...result.removals\n    ]) {\n      tblocks.putSync(cid, bytes);\n    }\n    if (!noLoader) {\n      await this.blockstore.commitTransaction(tblocks, { head: advancedHead }, { add: false, noLoader });\n      this.transaction = undefined;\n    }\n    this.setHead(advancedHead);\n  }\n}\n\n// Helper functions\nfunction sortClockHead(clockHead: ClockHead) {\n  return clockHead.sort((a, b) => a.toString().localeCompare(b.toString()));\n}\n\nasync function validateBlocks(logger: Logger, newHead: ClockHead, blockstore?: BaseBlockstore) {\n  if (!blockstore) throw logger.Error().Msg(\"missing blockstore\");\n  newHead.map(async (cid) => {\n    const got = await blockstore.get(cid);\n    if (!got) {\n      throw logger.Error().Str(\"cid\", cid.toString()).Msg(\"int_applyHead missing block\").AsError();\n    }\n  });\n}\n\nfunction compareClockHeads(head1: ClockHead, head2: ClockHead) {\n  return head1.toString() === head2.toString();\n}\n\nasync function advanceBlocks(logger: Logger, newHead: ClockHead, tblocks: CarTransaction, head: ClockHead) {\n  for (const cid of newHead) {\n    try {\n      head = await advance(tblocks, head, cid);\n    } catch (e) {\n      logger.Debug().Err(e).Msg(\"failed to advance head\");\n      // console.log('failed to advance head:', cid.toString(), e)\n      continue;\n    }\n  }\n  return head;\n}\n","import { Logger } from \"@adviser/cement\";\nimport { ClockHead, DocTypes, DocUpdate } from \"./types.js\";\n\ntype ApplyHeadWorkerFunction = (newHead: ClockHead, prevHead: ClockHead, localUpdates: boolean) => Promise<void>;\n\ninterface ApplyHeadTask<T extends DocTypes> {\n  readonly newHead: ClockHead;\n  readonly prevHead: ClockHead;\n  readonly updates?: DocUpdate<T>[];\n}\n\nexport interface ApplyHeadQueue<T extends DocTypes> {\n  push(task: ApplyHeadTask<T>): AsyncGenerator<\n    {\n      readonly updates: DocUpdate<T>[];\n      readonly all: boolean;\n    },\n    void,\n    unknown\n  >;\n  size(): number;\n}\n\nexport function applyHeadQueue<T extends DocTypes>(worker: ApplyHeadWorkerFunction, logger: Logger): ApplyHeadQueue<T> {\n  const queue: ApplyHeadTask<T>[] = [];\n  let isProcessing = false;\n\n  async function* process() {\n    if (isProcessing || queue.length === 0) return;\n    isProcessing = true;\n    const allUpdates: DocUpdate<T>[] = [];\n    try {\n      while (queue.length > 0) {\n        queue.sort((a, b) => (b.updates ? 1 : -1));\n        const task = queue.shift();\n        if (!task) continue;\n\n        await worker(task.newHead, task.prevHead, task.updates !== undefined).catch((e) => {\n          throw logger.Error().Err(e).Msg(\"int_applyHead worker error\").AsError();\n        });\n        // console.timeEnd('int_applyHead worker')\n\n        if (task.updates) {\n          allUpdates.push(...task.updates);\n        }\n        // Yield the updates if there are no tasks with updates left in the queue or the current task has updates\n        if (!queue.some((t) => t.updates) || task.updates) {\n          const allTasksHaveUpdates = queue.every((task) => task.updates !== null);\n          yield { updates: allUpdates, all: allTasksHaveUpdates };\n          allUpdates.length = 0;\n        }\n      }\n    } finally {\n      isProcessing = false;\n      const generator = process();\n      let result = await generator.next();\n      while (!result.done) {\n        result = await generator.next();\n      }\n    }\n  }\n\n  return {\n    push(task: ApplyHeadTask<T>): AsyncGenerator<{ updates: DocUpdate<T>[]; all: boolean }, void, unknown> {\n      queue.push(task);\n      return process();\n    },\n    size() {\n      return queue.length;\n    },\n  };\n}\n","// export * from \"./sys-container.js\";\nexport * from \"./gateways/file/node/utils.js\";\n\n// export * as sql from \"./store-sql/index.js\";\nexport * as files from \"./files.js\";\n\nexport * as kb from \"./key-bag.js\";\nexport * as kc from \"./keyed-crypto.js\";\n\nexport * as mf from \"./wait-pr-multiformats/index.js\";\n\nexport { runtimeFn } from \"@adviser/cement\";\n\nexport { FILESTORE_VERSION } from \"./gateways/file/version.js\";\nexport { INDEXDB_VERSION } from \"./gateways/indexdb/version.js\";\n// export { V0_19SQL_VERSION } from \"./store-sql/v0.19/version.js\";\n","import type { URI } from \"@adviser/cement\";\nimport { getStore } from \"@fireproof/core\";\nimport type { SuperThis } from \"@fireproof/core\";\n\nexport function getPath(url: URI, sthis: SuperThis): string {\n  const basePath = url.pathname;\n  // .toString()\n  // .replace(new RegExp(`^${url.protocol}//`), \"\")\n  // .replace(/\\?.*$/, \"\");\n  const name = url.getParam(\"name\");\n  if (name) {\n    const version = url.getParam(\"version\");\n    if (!version) throw sthis.logger.Error().Url(url).Msg(`version not found`).AsError();\n    return sthis.pathOps.join(basePath, version, name);\n  }\n  return sthis.pathOps.join(basePath);\n}\n\nexport function getFileName(url: URI, sthis: SuperThis): string {\n  const key = url.getParam(\"key\");\n  if (!key) throw sthis.logger.Error().Url(url).Msg(`key not found`).AsError();\n  const res = getStore(url, sthis, (...a: string[]) => a.join(\"-\"));\n  switch (res.store) {\n    case \"data\":\n      return sthis.pathOps.join(res.name, key + \".car\");\n    case \"wal\":\n    case \"meta\":\n      return sthis.pathOps.join(res.name, key + \".json\");\n    default:\n      throw sthis.logger.Error().Url(url).Msg(`unsupported store type`).AsError();\n  }\n}\n","export * as block from \"./block.js\";\nexport * as codec from \"./codec-interface.js\";\n","import type { ArrayBufferView, ByteView } from \"multiformats\";\n\n/**\n * IPLD encoder part of the codec.\n */\nexport interface BlockEncoder<Code extends number, T> {\n  name: string;\n  code: Code;\n  encode(data: T): ByteView<T> | PromiseLike<ByteView<T>>;\n}\n\n/**\n * IPLD decoder part of the codec.\n */\nexport interface BlockDecoder<Code extends number, T> {\n  code: Code;\n  decode(bytes: ByteView<T> | ArrayBufferView<T>): T | PromiseLike<T>;\n}\n\n/**\n * An IPLD codec is a combination of both encoder and decoder.\n */\nexport interface BlockCodec<Code extends number, T> extends BlockEncoder<Code, T>, BlockDecoder<Code, T> {}\n\nexport type { ArrayBufferView, ByteView };\n","export const FILESTORE_VERSION = \"v0.19-file\";\n","export const INDEXDB_VERSION = \"v0.19-indexdb\";\n","export const PACKAGE_VERSION = Object.keys({\n  \"0.19.125\": \"xxxx\",\n})[0] as string;\n"],"mappings":"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","names":["ResolveOnce","index","ResolveOnce","codec","hasher","parse","hasher","KeyedResolvOnce","URI","runtimeFn","format","parse","ResolveOnce","Result","ResolveOnce","toCryptoRuntime","toCryptoRuntime","ResolveOnce","Result","runtimeFn","toCryptoRuntime","URI","base58btc","ResolveOnce","Result","runtimeFn","URI","toCryptoRuntime","hasher","dagCodec","codec","hasher","cid","ResolveOnce","cid","cache","got","batchSize","hasher","base58btc","hasher","Result","base58btc","encode","decode","Result","decode","base58btc","ofs","raw","encode","CID","Result","Result","CID","dbMeta","Result","ResolveOnce","parse","format","URI","KeyedResolvOnce","runtimeFn","hasher","parse","hasher","codec","root","root","ResolveOnce","task","ResolveOnce","root","ResolveOnce","name","ResolveOnce","updates","runtimeFn","getStore","runtimeFn"]}