export const KeyCharsASCII: "ascii";
export const MaxKeySize: 4096;
/**
 * @extends {Block<API.Shard, typeof dagCBOR.code, typeof sha256.code, 1>}
 * @implements {API.ShardBlockView}
 */
export class ShardBlock extends Block<API.Shard, 113, 18, 1> implements API.ShardBlockView {
    /** @param {API.ShardOptions} [options] */
    static create(options?: Partial<API.ShardConfig> | undefined): Promise<API.ShardBlockView>;
    /**
     * @param {object} config
     * @param {API.ShardLink} config.cid
     * @param {API.Shard} config.value
     * @param {Uint8Array} config.bytes
     */
    constructor({ cid, value, bytes }: {
        cid: API.ShardLink;
        value: API.Shard;
        bytes: Uint8Array;
    });
}
export function create(options?: Partial<API.ShardConfig> | undefined): API.Shard;
export function configure(options?: Partial<API.ShardConfig> | undefined): API.ShardConfig;
export function withEntries(entries: API.ShardEntry[], options?: Partial<API.ShardConfig> | undefined): API.Shard;
export function encodeBlock(value: API.Shard): Promise<API.ShardBlockView>;
export function decodeBlock(bytes: Uint8Array): Promise<API.ShardBlockView>;
export function isShard(value: any): value is API.Shard;
export function isShardLink(value: any): value is API.ShardLink;
export class ShardFetcher {
    /** @param {API.BlockFetcher} blocks */
    constructor(blocks: API.BlockFetcher);
    _blocks: API.BlockFetcher;
    /**
     * @param {API.ShardLink} link
     * @returns {Promise<API.ShardBlockView>}
     */
    get(link: API.ShardLink): Promise<API.ShardBlockView>;
}
export function putEntry(target: API.ShardEntry[], newEntry: API.ShardEntry): API.ShardEntry[];
export function isPrintableASCII(s: string): boolean;
import * as API from './api.js';
import { Block } from 'multiformats/block';
//# sourceMappingURL=shard.d.ts.map