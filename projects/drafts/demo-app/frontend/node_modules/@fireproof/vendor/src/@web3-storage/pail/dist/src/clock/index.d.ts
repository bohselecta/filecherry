export function advance<T>(blocks: API.BlockFetcher, head: API.EventLink<T>[], event: API.EventLink<T>): Promise<API.EventLink<T>[]>;
/**
 * @template T
 * @extends {Block<API.EventView<T>, typeof cbor.code, typeof sha256.code, 1>}
 * @implements {API.EventBlockView<T>}
 */
export class EventBlock<T> extends Block<API.EventView<T>, 113, 18, 1> implements API.EventBlockView<T> {
    /**
     * @template T
     * @param {T} data
     * @param {API.EventLink<T>[]} [parents]
     */
    static create<T_1>(data: T_1, parents?: API.EventLink<T_1>[] | undefined): Promise<API.EventBlockView<T_1>>;
    /**
     * @param {object} config
     * @param {API.EventLink<T>} config.cid
     * @param {Event} config.value
     * @param {Uint8Array} config.bytes
     * @param {string} config.prefix
     */
    constructor({ cid, value, bytes, prefix }: {
        cid: API.EventLink<T>;
        value: Event;
        bytes: Uint8Array;
        prefix: string;
    });
    prefix: string;
}
/** @template T */
export class EventFetcher<T> {
    /** @param {API.BlockFetcher} blocks */
    constructor(blocks: API.BlockFetcher);
    /** @private */
    private _blocks;
    /**
     * @param {API.EventLink<T>} link
     * @returns {Promise<API.EventBlockView<T>>}
     */
    get(link: API.EventLink<T>): Promise<API.EventBlockView<T>>;
}
export function encodeEventBlock<T>(value: API.EventView<T>): Promise<API.EventBlockView<T>>;
export function decodeEventBlock<T>(bytes: Uint8Array): Promise<API.EventBlockView<T>>;
export function vis<T>(blocks: API.BlockFetcher, head: API.EventLink<T>[], options?: {
    renderNodeLabel?: ((b: API.EventBlockView<T>) => string) | undefined;
} | undefined): AsyncGenerator<string, void, unknown>;
import * as API from './api.js';
import { Block } from 'multiformats/block';
//# sourceMappingURL=index.d.ts.map