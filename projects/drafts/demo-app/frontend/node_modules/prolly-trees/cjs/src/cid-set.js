'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var base = require('./base.js');
var utils = require('./utils.js');

const compare = ({bytes: a}, {bytes: b}) => utils.binaryCompare(a, b);
class CIDEntry extends base.Entry {
  constructor(cid) {
    super({
      address: cid,
      key: cid
    });
    this.cid = cid;
  }
  encodeNode() {
    return this.cid;
  }
  identity() {
    const buffer = this.cid.multihash.bytes;
    return utils.readUInt32LE(buffer);
  }
}
class CIDNodeEntry extends base.Entry {
  async identity() {
    const {
      multihash: {bytes}
    } = await this.address;
    return utils.readUInt32LE(bytes);
  }
}
class CIDSetBranch extends base.IPLDBranch {
}
class CIDSetLeaf extends base.IPLDLeaf {
}
const createGetNode = (get, cache, chunker, codec, hasher) => {
  const decoder = block => {
    const {value} = block;
    const opts = {
      chunker,
      cache,
      block,
      getNode,
      codec,
      hasher,
      compare
    };
    let entries;
    let CLS;
    if (value.leaf) {
      entries = value.leaf.map(cid => new CIDEntry(cid));
      CLS = CIDSetLeaf;
    } else if (value.branch) {
      const [distance, _entries] = value.branch;
      opts.distance = distance;
      entries = _entries.map(([key, address]) => new CIDNodeEntry({
        key,
        address
      }));
      CLS = CIDSetBranch;
    } else {
      throw new Error('Unknown block data, does not match schema');
    }
    const entryList = new base.EntryList({
      entries,
      closed: value.closed
    });
    const node = new CLS({
      entryList,
      ...opts
    });
    cache.set(node);
    return node;
  };
  const getNode = cid => {
    if (cache.has(cid))
      return cache.get(cid);
    return get(cid).then(block => decoder(block));
  };
  return getNode;
};
const create = ({get, cache, chunker, list, codec, hasher, sorted}) => {
  if (!sorted)
    list = list.sort(compare);
  const getNode = createGetNode(get, cache, chunker, codec, hasher);
  const opts = {
    list,
    codec,
    hasher,
    chunker,
    getNode,
    sorted,
    compare,
    cache,
    LeafClass: CIDSetLeaf,
    LeafEntryClass: CIDEntry,
    BranchClass: CIDSetBranch,
    BranchEntryClass: CIDNodeEntry
  };
  return base.create(opts);
};
const load = ({cid, get, cache, chunker, codec, hasher, ...opts}) => {
  const getNode = createGetNode(get, cache, chunker, codec, hasher, opts);
  return getNode(cid);
};

exports.create = create;
exports.load = load;
