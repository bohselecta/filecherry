'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var map = require('./map.js');
var utils = require('./utils.js');

const compare = (a, b) => {
  const [aKey, aRef] = a;
  const [bKey, bRef] = b;
  const comp = utils.simpleCompare(aKey, bKey);
  if (comp !== 0)
    return comp;
  return refCompare(aRef, bRef);
};
const refCompare = (aRef, bRef) => {
  if (Number.isNaN(aRef))
    return -1;
  if (Number.isNaN(bRef))
    throw new Error('ref may not be Infinity or NaN');
  if (!Number.isFinite(aRef))
    return 1;
  return utils.simpleCompare(aRef, bRef);
};
const getIndex = async (node, key) => {
  const start = [
    key,
    NaN
  ];
  const end = [
    key,
    Infinity
  ];
  const {
    result: entries,
    cids
  } = await node.getRangeEntries(start, end);
  return {
    result: entries.map(entry => {
      const [key, id] = entry.key;
      return {
        id,
        key,
        row: entry.value
      };
    }),
    cids
  };
};
const getRange = async (node, start, end) => {
  start = [
    start,
    NaN
  ];
  end = [
    end,
    Infinity
  ];
  const {
    result: entries,
    cids
  } = await node.getRangeEntries(start, end);
  const result = entries.map(entry => {
    const [key, id] = entry.key;
    return {
      id,
      key,
      row: entry.value
    };
  });
  return {
    result,
    cids
  };
};
class DBIndexLeaf extends map.MapLeaf {
  get(key) {
    return getIndex(this, key);
  }
  range(start, end) {
    return getRange(this, start, end);
  }
  bulk(bulk, opts = {}, isRoot = true) {
    return super.bulk(bulk, {
      ...classes,
      ...opts
    }, isRoot);
  }
}
class DBIndexBranch extends map.MapBranch {
  get(key) {
    return getIndex(this, key);
  }
  range(start, end) {
    return getRange(this, start, end);
  }
  bulk(bulk, opts = {}, isRoot = true) {
    return super.bulk(bulk, {
      ...classes,
      ...opts
    }, isRoot);
  }
}
const LeafClass = DBIndexLeaf;
const BranchClass = DBIndexBranch;
const classes = {
  LeafClass,
  BranchClass,
  LeafEntryClass: map.MapLeafEntry,
  BranchEntryClass: map.MapBranchEntry
};
const defaults = {
  ...classes,
  compare
};
const create = opts => {
  opts = {
    ...defaults,
    ...opts
  };
  return map.create(opts);
};
const load = opts => {
  opts = {
    ...defaults,
    ...opts
  };
  return map.load(opts);
};

exports.DBIndexBranch = DBIndexBranch;
exports.DBIndexLeaf = DBIndexLeaf;
exports.create = create;
exports.load = load;
