'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const readUInt32LE = buffer => {
  const offset = buffer.byteLength - 4;
  return (buffer[offset] | buffer[offset + 1] << 8 | buffer[offset + 2] << 16) + buffer[offset + 3] * 16777216;
};
const MAX_UINT32 = 4294967295;
const bf = factor => {
  const threshold = Math.floor(MAX_UINT32 / factor);
  return async entry => {
    const identity = await entry.identity();
    if (typeof identity !== 'number') {
      throw new Error('Identity must be a number');
    }
    if (identity <= threshold) {
      return true;
    }
    return false;
  };
};
const enc32 = value => {
  value = +value;
  const buff = new Uint8Array(4);
  buff[3] = value >>> 24;
  buff[2] = value >>> 16;
  buff[1] = value >>> 8;
  buff[0] = value & 255;
  return buff;
};
const simpleCompare = (a, b) => {
  if (a === b)
    return 0;
  if (a > b)
    return 1;
  return -1;
};
const binaryCompare = (b1, b2) => {
  for (let i = 0; i < b1.byteLength; i++) {
    if (b2.byteLength === i)
      return 1;
    const c1 = b1[i];
    const c2 = b2[i];
    if (c1 === c2)
      continue;
    if (c1 > c2)
      return 1;
    else
      return -1;
  }
  if (b2.byteLength > b1.byteLength)
    return -1;
  return 0;
};
class CIDCounter {
  constructor() {
    this._cids = new Set();
  }
  add(node) {
    if (!node.address) {
      throw new Error('Cannot add node without address');
    }
    if (node.address.then) {
      const p = node.address.then(cid => this._cids.add(cid.toString()));
      this._cids.add(p);
      p.then(() => this._cids.delete(p));
    } else {
      this._cids.add(node.address.toString());
    }
  }
  async all() {
    await Promise.all([...this._cids]);
    return this._cids;
  }
}

exports.CIDCounter = CIDCounter;
exports.bf = bf;
exports.binaryCompare = binaryCompare;
exports.enc32 = enc32;
exports.readUInt32LE = readUInt32LE;
exports.simpleCompare = simpleCompare;
