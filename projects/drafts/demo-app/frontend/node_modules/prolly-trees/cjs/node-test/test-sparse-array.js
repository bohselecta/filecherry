'use strict';

var assert = require('assert');
var sparseArray = require('../src/sparse-array.js');
var codec = require('@ipld/dag-cbor');
var sha2 = require('multiformats/hashes/sha2');
var cache$1 = require('../src/cache.js');
var utils = require('../src/utils.js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var codec__namespace = /*#__PURE__*/_interopNamespace(codec);

const chunker = utils.bf(3);
const cache = cache$1.nocache;
const storage = () => {
  const blocks = {};
  const put = block => {
    blocks[block.cid.toString()] = block;
  };
  const get = async cid => {
    const block = blocks[cid.toString()];
    if (!block)
      throw new Error('Not found');
    return block;
  };
  return {
    get,
    put,
    blocks
  };
};
const opts = {
  cache,
  chunker,
  codec: codec__namespace,
  hasher: sha2.sha256
};
const verify = (check, node) => {
  assert.deepStrictEqual(check.isLeaf, node.isLeaf);
  assert.deepStrictEqual(check.isBranch, node.isBranch);
  assert.deepStrictEqual(check.entries, node.entryList.entries.length);
  assert.deepStrictEqual(check.closed, node.closed);
};
const createList = entries => entries.map(([key, value]) => ({
  key,
  value
}));
const v = 'value';
const list = createList([
  [
    1,
    v
  ],
  [
    2,
    v
  ],
  [
    10,
    v
  ],
  [
    15,
    v
  ],
  [
    20,
    v
  ],
  [
    200,
    v
  ],
  [
    210,
    v
  ],
  [
    290,
    v
  ],
  [
    300,
    v
  ],
  [
    10000,
    v
  ]
]);
describe('sparse array', () => {
  it('basic create', async () => {
    const {get, put} = storage();
    const checks = [
      [
        true,
        undefined,
        2,
        true
      ],
      [
        true,
        undefined,
        1,
        true
      ],
      [
        true,
        undefined,
        1,
        true
      ],
      [
        true,
        undefined,
        4,
        true
      ],
      [
        true,
        undefined,
        2,
        false
      ],
      [
        undefined,
        true,
        4,
        true
      ],
      [
        undefined,
        true,
        1,
        false
      ],
      [
        undefined,
        true,
        2,
        true
      ]
    ].map(([isLeaf, isBranch, entries, closed]) => ({
      isLeaf,
      isBranch,
      entries,
      closed
    }));
    let root;
    for await (const node of sparseArray.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      const address = await node.address;
      assert.deepStrictEqual(address.asCID, address);
      verify(checks.shift(), node);
      await put(await node.block);
      root = node;
    }
    const cid = await root.address;
    root = await sparseArray.load({
      cid,
      get,
      compare: utils.simpleCompare,
      ...opts
    });
    for (const {key} of list) {
      assert.deepStrictEqual((await root.get(key)).result, v);
    }
  });
  it('getEntries & getMany', async () => {
    const {get, put} = storage();
    let root;
    for await (const node of sparseArray.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      await put(await node.block);
      root = node;
    }
    const {result: entries} = await root.getEntries([
      2,
      10000
    ]);
    assert.deepStrictEqual(entries.length, 2);
    const [a, b] = entries;
    assert.deepStrictEqual(a.key, 2);
    assert.deepStrictEqual(a.value, v);
    assert.deepStrictEqual(b.key, 10000);
    assert.deepStrictEqual(b.value, v);
    const {result: values} = await root.getMany([
      2,
      10000
    ]);
    assert.deepStrictEqual(values, [
      v,
      v
    ]);
  });
  it('getRangeEntries', async () => {
    const {get, put} = storage();
    let root;
    for await (const node of sparseArray.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      await put(await node.block);
      root = node;
    }
    const verify = (entries, start, end) => {
      const keys = entries.map(entry => entry.key);
      const comp = list.slice(start, end).map(({key}) => key);
      assert.deepStrictEqual(keys, comp);
    };
    const range = async (...args) => (await root.getRangeEntries(...args)).result;
    let entries = await range(2, 400);
    verify(entries, 1, 9);
    entries = await range(0, 99999);
    verify(entries);
    entries = await range(1, 10000);
    verify(entries, 0, 9);
    entries = await range(1, 15);
    verify(entries, 0, 3);
    assert.deepStrictEqual(await root.getLength(), 10001);
  });
  it('bulk', async () => {
    const {get, put} = storage();
    let root;
    let leaf;
    for await (const node of sparseArray.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      if (node.isLeaf)
        leaf = node;
      await put(await node.block);
      root = node;
    }
    assert.deepStrictEqual(await leaf.getLength(), 10001);
    assert.deepStrictEqual(await root.getLength(), 10001);
    const {
      blocks,
      root: lRoot
    } = await leaf.bulk([{
        key: 10001,
        value: 'test'
      }], {}, false);
    await Promise.all(blocks.map(put));
    assert.deepStrictEqual((await lRoot.get(10001)).result, 'test');
    const {
      blocks: _blocks,
      root: bRoot
    } = await root.bulk([{
        key: 10001,
        value: 'test2'
      }]);
    await Promise.all(_blocks.map(put));
    assert.deepStrictEqual((await bRoot.get(10001)).result, 'test2');
  });
});
