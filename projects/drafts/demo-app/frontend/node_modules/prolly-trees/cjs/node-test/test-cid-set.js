'use strict';

var assert = require('assert');
var cidSet = require('../src/cid-set.js');
var codec = require('@ipld/dag-cbor');
var sha2 = require('multiformats/hashes/sha2');
var multiformats = require('multiformats');
var cache = require('../src/cache.js');
var utils = require('../src/utils.js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var codec__namespace = /*#__PURE__*/_interopNamespace(codec);

const MAX_UINT32 = 4294967295;
const chunker = utils.bf(30000);
const threshold = Math.floor(MAX_UINT32 / 30000);
const cid = multiformats.CID.parse('zdj7Wd8AMwqnhJGQCbFxBVodGSBG84TM7Hs1rcJuQMwTyfEDS');
const baseBytes = cid.bytes.slice();
const mkcid = (sort, num) => {
  const bytes = baseBytes.slice();
  bytes[bytes.byteLength - 5] = sort;
  num = utils.enc32(num);
  const offset = bytes.byteLength - 4;
  let i = 0;
  while (i < 4) {
    bytes[offset + i] = num[i];
    i++;
  }
  return multiformats.CID.decode(bytes);
};
const mkcids = list => {
  let i = 0;
  const ret = [];
  for (const num of list) {
    const cid = mkcid(i, num);
    ret.push(cid);
    i++;
  }
  return ret;
};
const storage = () => {
  const blocks = {};
  const put = block => {
    blocks[block.cid.toString()] = block;
  };
  const get = async cid => {
    const block = blocks[cid.toString()];
    if (!block)
      throw new Error('Not found');
    return block;
  };
  return {
    get,
    put,
    blocks
  };
};
const opts = {
  chunker,
  codec: codec__namespace,
  hasher: sha2.sha256
};
const verify = (check, node) => {
  assert.deepStrictEqual(check.isLeaf, node.isLeaf);
  assert.deepStrictEqual(check.isBranch, node.isBranch);
  assert.deepStrictEqual(check.entries, node.entryList.entries.length);
  assert.deepStrictEqual(check.closed, node.closed);
};
describe('cid set', () => {
  const mktest = doCache => {
    it(`basic create cache=${ !!doCache }`, async () => {
      const {get, put} = storage();
      const list = mkcids([
        threshold + 1,
        threshold - 2,
        threshold + 2
      ]);
      const checks = [
        {
          isLeaf: true,
          entries: 2,
          closed: true
        },
        {
          isLeaf: true,
          entries: 1,
          closed: false
        },
        {
          isBranch: true,
          entries: 2,
          closed: false
        }
      ];
      let root;
      for await (const node of cidSet.create({
          get,
          list,
          ...opts,
          cache: doCache ? cache.global : cache.nocache
        })) {
        await cache.global.set(node);
        const address = await node.address;
        assert.deepStrictEqual(address.asCID, address);
        verify(checks.shift(), node);
        await put(await node.block);
        const n = await node.getNode(await node.address);
        assert.deepStrictEqual(address.toString(), (await n.address).toString());
        root = node;
      }
      const cid = await root.address;
      root = await root.getNode(cid);
      assert.deepStrictEqual(cid.toString(), (await root.address).toString());
      root = await cidSet.load({
        cid,
        get,
        cache: cache.global,
        ...opts
      });
      assert.deepStrictEqual(cid.toString(), (await root.address).toString());
      for (const cid of list) {
        const {result} = await root.get(cid);
        assert.deepStrictEqual(result, cid);
      }
    });
  };
  mktest(true);
  mktest(false);
});
