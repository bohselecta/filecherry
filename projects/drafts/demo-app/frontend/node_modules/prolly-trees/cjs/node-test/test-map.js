'use strict';

var assert = require('assert');
var map = require('../src/map.js');
var codec = require('@ipld/dag-cbor');
var sha2 = require('multiformats/hashes/sha2');
var cache$1 = require('../src/cache.js');
var utils = require('../src/utils.js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var codec__namespace = /*#__PURE__*/_interopNamespace(codec);

const chunker = utils.bf(3);
const cache = cache$1.nocache;
const storage = () => {
  const blocks = {};
  const put = block => {
    blocks[block.cid.toString()] = block;
  };
  const get = async cid => {
    const block = blocks[cid.toString()];
    if (!block)
      throw new Error('Not found');
    return block;
  };
  return {
    get,
    put,
    blocks
  };
};
const opts = {
  cache,
  chunker,
  codec: codec__namespace,
  hasher: sha2.sha256
};
const verify = (check, node) => {
  assert.deepStrictEqual(check.isLeaf, node.isLeaf);
  assert.deepStrictEqual(check.isBranch, node.isBranch);
  assert.deepStrictEqual(check.entries, node.entryList.entries.length);
  assert.deepStrictEqual(check.closed, node.closed);
};
const createList = entries => entries.map(([key, value]) => ({
  key,
  value
}));
const list = createList([
  [
    'a',
    1
  ],
  [
    'b',
    1
  ],
  [
    'bb',
    2
  ],
  [
    'c',
    1
  ],
  [
    'cc',
    2
  ],
  [
    'd',
    1
  ],
  [
    'ff',
    2
  ],
  [
    'h',
    1
  ],
  [
    'z',
    1
  ],
  [
    'zz',
    2
  ]
]);
describe('map', () => {
  it('basic create', async () => {
    const {get, put} = storage();
    const checks = [
      [
        true,
        undefined,
        1,
        true
      ],
      [
        true,
        undefined,
        3,
        true
      ],
      [
        true,
        undefined,
        1,
        true
      ],
      [
        true,
        undefined,
        2,
        true
      ],
      [
        true,
        undefined,
        2,
        true
      ],
      [
        true,
        undefined,
        1,
        false
      ],
      [
        undefined,
        true,
        5,
        true
      ],
      [
        undefined,
        true,
        1,
        true
      ],
      [
        undefined,
        true,
        2,
        false
      ]
    ].map(([isLeaf, isBranch, entries, closed]) => ({
      isLeaf,
      isBranch,
      entries,
      closed
    }));
    let root;
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      const address = await node.address;
      assert.deepStrictEqual(address.asCID, address);
      verify(checks.shift(), node);
      await put(await node.block);
      root = node;
    }
    const cid = await root.address;
    root = await map.load({
      cid,
      get,
      compare: utils.simpleCompare,
      ...opts
    });
    for (const {key} of list) {
      assert.deepStrictEqual((await root.get(key)).result, key.length);
    }
  });
  it('getEntries & getMany', async () => {
    const {get, put} = storage();
    let root;
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      await put(await node.block);
      root = node;
    }
    const {
      result: entries,
      cids
    } = await root.getEntries([
      'a',
      'zz'
    ]);
    assert.deepStrictEqual((await cids.all()).size, 5);
    assert.deepStrictEqual(entries.length, 2);
    const [a, zz] = entries;
    assert.deepStrictEqual(a.key, 'a');
    assert.deepStrictEqual(a.value, 1);
    assert.deepStrictEqual(zz.key, 'zz');
    assert.deepStrictEqual(zz.value, 2);
    const {result: values} = await root.getMany([
      'a',
      'zz'
    ]);
    assert.deepStrictEqual(values, [
      1,
      2
    ]);
  });
  it('getRangeEntries', async () => {
    const {get, put} = storage();
    let root;
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      await put(await node.block);
      root = node;
    }
    const verify = (entries, start, end) => {
      const keys = entries.map(entry => entry.key);
      const comp = list.slice(start, end).map(({key}) => key);
      assert.deepStrictEqual(keys, comp);
    };
    const range = async (...args) => (await root.getRangeEntries(...args)).result;
    let entries = await range('b', 'z');
    verify(entries, 1, 8);
    entries = await range('', 'zzz');
    verify(entries);
    entries = await range('a', 'zz');
    verify(entries, 0, 9);
    entries = await range('a', 'c');
    verify(entries, 0, 3);
  });
  let getCount = 0;
  const createFaultyStorage = faultCount => {
    const {get, put} = storage();
    const faultyGet = async cid => {
      getCount++;
      if (getCount === faultCount) {
        throw new Error('Faulty CID encountered');
      }
      return await get(cid);
    };
    return {
      get: faultyGet,
      put
    };
  };
  it('getAllEntries', async () => {
    const {get, put} = createFaultyStorage(8);
    let root;
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      await put(await node.block);
      root = node;
    }
    try {
      await root.getAllEntries();
      throw new Error('getAllEntries should have thrown an error');
    } catch (err) {
      assert.deepStrictEqual(err.message, 'Faulty CID encountered', 'Unexpected error thrown');
    }
  });
  it('bulk with delete', async () => {
    const {get, put} = storage();
    let last;
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      await put(await node.block);
      last = node;
    }
    const verify = (entries, start, end) => {
      const keys = entries.map(entry => entry.key);
      const comp = list.slice(start, end).map(({key}) => key);
      assert.deepStrictEqual(keys, comp);
    };
    const {result: entries} = await last.getAllEntries();
    verify(entries);
    const notDeleted = list.map(({key}) => key);
    const deleted = [];
    for (const {key} of list) {
      const bulk = [{
          key,
          del: true
        }];
      const index = notDeleted.indexOf(key);
      notDeleted.splice(index, 1);
      deleted.push(key);
      const {blocks, root} = await last.bulk(bulk);
      await Promise.all(blocks.map(block => put(block)));
      if (notDeleted.length > 0) {
        const _get = async k => (await root.get(k)).result;
        for (const key of notDeleted) {
          assert.deepStrictEqual(await _get(key), list.find(({key: k}) => k === key).value);
        }
        for (const key of deleted) {
          assert.deepStrictEqual(await _get(key).catch(e => e.message), 'Not found');
        }
        last = root;
      }
    }
  });
  it('bulk with missing delete', async () => {
    const {get, put} = storage();
    let last;
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      await put(await node.block);
      last = node;
    }
    const verify = (entries, start, end) => {
      const keys = entries.map(entry => entry.key);
      const comp = list.slice(start, end).map(({key}) => key);
      assert.deepStrictEqual(keys, comp);
    };
    const {result: entries} = await last.getAllEntries();
    verify(entries);
    const notDeleted = list.map(({key}) => key);
    const deleted = [];
    let prevKey = list[0].key;
    for (const {key} of list) {
      const missingKey = 'missing-key';
      const bulk = [
        {
          key,
          del: true
        },
        {
          key: key + 'add',
          value: 'add'
        },
        {
          key: key + 'del',
          del: true
        },
        {
          key: prevKey,
          del: true
        },
        {
          key: key + missingKey,
          value: key + missingKey
        },
        {
          key: prevKey + 'add',
          value: 'add'
        },
        {
          key: key + missingKey,
          del: true
        }
      ];
      prevKey = key;
      const index = notDeleted.indexOf(key);
      notDeleted.splice(index, 1);
      deleted.push(key);
      const {blocks, root} = await last.bulk(bulk);
      await Promise.all(blocks.map(block => put(block)));
      const allres = await root.getAllEntries();
      for (const op of bulk) {
        if (!op.del) {
          const allVal = allres.result.find(({key: k}) => k === op.key).value;
          assert.deepStrictEqual(allVal, op.value);
          assert.deepStrictEqual((await root.get(op.key)).result, op.value);
        } else {
          if (op.key.indexOf('missing-key') === -1) {
            assert.deepStrictEqual(await root.get(op.key).catch(e => e.message), 'Not found');
          }
        }
      }
      if (notDeleted.length > 0) {
        const _get = async k => (await root.get(k)).result;
        for (const key of notDeleted) {
          assert.deepStrictEqual(await _get(key).catch(e => {
            throw e;
          }), list.find(({key: k}) => k === key).value);
        }
        for (const key of deleted) {
          assert.deepStrictEqual(await _get(key).catch(e => e.message), 'Not found');
        }
        last = root;
      }
    }
  });
  it('bulk insert 2', async () => {
    const {get, put} = storage();
    let last;
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      await put(await node.block);
      last = node;
    }
    const verify = (entries, start, end) => {
      const keys = entries.map(entry => entry.key);
      const comp = list.slice(start, end).map(({key}) => key);
      assert.deepStrictEqual(keys, comp);
    };
    const {result: entries} = await last.getAllEntries();
    verify(entries);
    const bulk = [
      {
        key: 'dd',
        value: 2
      },
      {
        key: 'd',
        value: -1
      }
    ];
    const {blocks, root} = await last.bulk(bulk);
    await Promise.all(blocks.map(block => put(block)));
    const _get = async k => (await root.get(k)).result;
    assert.deepStrictEqual(await _get('dd'), 2);
    assert.deepStrictEqual(await _get('d'), -1);
    const expected = [
      [
        'a',
        1
      ],
      [
        'b',
        1
      ],
      [
        'bb',
        2
      ],
      [
        'c',
        1
      ],
      [
        'cc',
        2
      ],
      [
        'ff',
        2
      ],
      [
        'h',
        1
      ],
      [
        'z',
        1
      ],
      [
        'zz',
        2
      ]
    ];
    for (const [key, value] of expected) {
      assert.deepStrictEqual(await _get(key), value);
    }
  });
  it('bulk insert unsorted', async () => {
    const {get, put} = storage();
    let last;
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      await put(await node.block);
      last = node;
    }
    const verify = (entries, start, end) => {
      const keys = entries.map(entry => entry.key);
      const comp = list.slice(start, end).map(({key}) => key);
      assert.deepStrictEqual(keys, comp);
    };
    const {result: entries} = await last.getAllEntries();
    verify(entries);
    const bulk = [
      {
        key: 'dd',
        value: 2
      },
      {
        key: 'd',
        value: -1
      }
    ].sort(() => Math.random() - 0.5);
    const {blocks, root} = await last.bulk(bulk, { sorted: false });
    await Promise.all(blocks.map(block => put(block)));
    const _get = async k => (await root.get(k)).result;
    assert.deepStrictEqual(await _get('dd'), 2);
    assert.deepStrictEqual(await _get('d'), -1);
    const expected = [
      [
        'a',
        1
      ],
      [
        'b',
        1
      ],
      [
        'bb',
        2
      ],
      [
        'c',
        1
      ],
      [
        'cc',
        2
      ],
      [
        'ff',
        2
      ],
      [
        'h',
        1
      ],
      [
        'z',
        1
      ],
      [
        'zz',
        2
      ]
    ];
    for (const [key, value] of expected) {
      assert.deepStrictEqual(await _get(key), value);
    }
    for await (const line of root.vis()) {
      assert.deepStrictEqual(typeof line, 'string');
    }
  });
  it('bulk insert 100 update 1*100', async () => {
    const {get, put} = storage();
    let last;
    const list = [];
    let i = 0;
    let expected = [];
    while (i < 100) {
      list.push({
        key: i.toString(),
        value: true
      });
      expected.push(i.toString());
      i++;
    }
    expected = expected.sort();
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts,
        cache: cache$1.global
      })) {
      await cache$1.global.set(node);
      await put(await node.block);
      last = node;
    }
    i = -1;
    const verify = (entries, start, end) => {
      let count = 0;
      const _expected = [...expected];
      for (const {key, value} of entries) {
        assert.deepStrictEqual(value, i.toString() !== key);
        assert.deepStrictEqual(_expected.shift(), key);
        count++;
      }
      assert.deepStrictEqual(count, 100);
    };
    const {result: entries} = await last.getAllEntries();
    verify(entries);
    const base = last;
    i++;
    while (i < 100) {
      const bulk = [{
          key: i.toString(),
          value: false
        }];
      const {blocks, root} = await base.bulk(bulk);
      await Promise.all(blocks.map(block => put(block)));
      const {result} = await root.getAllEntries();
      verify(result);
      i++;
    }
  });
  it('bulk insert 100 delete 1*100', async () => {
    const {get, put} = storage();
    let last;
    const list = [];
    let i = 0;
    let expected = [];
    while (i < 100) {
      list.push({
        key: i.toString(),
        value: true
      });
      expected.push(i.toString());
      i++;
    }
    expected = expected.sort();
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts,
        cache: cache$1.global
      })) {
      await cache$1.global.set(node);
      await put(await node.block);
      last = node;
    }
    i = -1;
    const verify = (entries, start, end) => {
      let count = 0;
      const _expected = [...expected];
      for (const {key, value} of entries) {
        assert.deepStrictEqual(value, true);
        let exp = _expected.shift();
        if (exp === i.toString())
          exp = _expected.shift();
        assert.deepStrictEqual(exp, key);
        count++;
      }
      assert.deepStrictEqual(count, i === -1 ? 100 : 99);
    };
    const {result: entries} = await last.getAllEntries();
    verify(entries);
    const base = last;
    i++;
    while (i < 100) {
      const bulk = [{
          key: i.toString(),
          del: true
        }];
      const {blocks, root, previous} = await base.bulk(bulk);
      assert.deepStrictEqual(previous.length, 1);
      const [{key, value}] = previous;
      assert.deepStrictEqual(key, i.toString());
      assert.deepStrictEqual(value, true);
      await Promise.all(blocks.map(block => put(block)));
      const {result} = await root.getAllEntries();
      verify(result);
      i++;
    }
  });
  it('brute ranges', async () => {
    const {get, put} = storage();
    let last;
    const list = [];
    let i = 0;
    let expected = [];
    while (i < 100) {
      list.push({
        key: i.toString(),
        value: true
      });
      expected.push(i.toString());
      i++;
    }
    expected = expected.sort();
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts,
        cache: cache$1.global
      })) {
      await cache$1.global.set(node);
      await put(await node.block);
      last = node;
    }
    const front = [...expected];
    const back = [...expected];
    while (front.length) {
      const {result: entries} = await last.getRangeEntries(front[0], front[front.length - 1] + '999');
      assert.deepStrictEqual(entries.map(({key}) => key), front);
      front.shift();
    }
    while (front.length) {
      const {result: entries} = await last.getRangeEntries(back[0], back[back.length - 1] + '.');
      assert.deepStrictEqual(entries.map(({key}) => key), back);
      back.pop();
    }
    let {result: entries} = await last.getRangeEntries('9999999', '9999999999999999');
    assert.deepStrictEqual(entries, []);
    entries = (await last.getRangeEntries('.', '.')).result;
  });
  it('getEntry', async () => {
    const {get, put} = storage();
    let root;
    let leaf;
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      if (node.isLeaf)
        leaf = node;
      await put(await node.block);
      root = node;
    }
    let threw = true;
    try {
      await root.getEntry('.');
      threw = false;
    } catch (e) {
      if (e.message !== 'Not found')
        throw e;
    }
    assert.deepStrictEqual(threw, true);
    try {
      await leaf.getEntry('.');
      threw = false;
    } catch (e) {
      if (e.message !== 'Not found')
        throw e;
    }
    assert.deepStrictEqual(threw, true);
    try {
      await root.getEntry('missing');
      threw = false;
    } catch (e) {
      if (e.message !== 'Not found')
        throw e;
    }
    assert.deepStrictEqual(threw, true);
  });
  it('leaf', async () => {
    const {get, put} = storage();
    let root;
    const chunker = utils.bf(1000);
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts,
        chunker
      })) {
      if (!node.isLeaf)
        throw new Error('Not leaf');
      await put(await node.block);
      root = node;
    }
    const res = await root.get('c');
    assert.deepStrictEqual(res.result, 1);
    const {result} = await root.getMany([
      'c',
      'cc',
      'd'
    ]);
    assert.deepStrictEqual(result, [
      1,
      2,
      1
    ]);
    const bulk = [{
        key: 'aaa',
        value: 3
      }];
    const {
      blocks,
      root: rr
    } = await root.bulk(bulk);
    await Promise.all(blocks.map(block => put(block)));
    assert.deepStrictEqual((await rr.get('aaa')).result, 3);
  });
  it('load non-existent key', async () => {
    const {get, put} = storage();
    let root;
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      await put(await node.block);
      root = node;
    }
    try {
      await root.get('non_existent_key');
      throw new Error('Should not reach this line');
    } catch (error) {
      assert.deepStrictEqual(error.message, 'Not found');
    }
  });
  it('delete multiple entries', async () => {
    const {get, put} = storage();
    let root;
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      await put(await node.block);
      root = node;
    }
    const keysToDelete = [
      'b',
      'cc',
      'z'
    ];
    const bulk = keysToDelete.map(key => ({
      key,
      del: true
    }));
    const {
      blocks,
      root: updatedRoot,
      previous
    } = await root.bulk(bulk);
    await Promise.all(blocks.map(block => put(block)));
    const deletedKeys = previous.map(({key}) => key);
    const deletedValues = previous.map(({value}) => value);
    assert.deepStrictEqual(deletedKeys.sort(), keysToDelete.sort());
    assert.deepStrictEqual(deletedValues, [
      1,
      2,
      1
    ]);
    for (const key of keysToDelete) {
      let threw = false;
      try {
        await updatedRoot.get(key);
      } catch (e) {
        if (e.message === 'Not found')
          threw = true;
      }
      assert.deepStrictEqual(threw, true);
    }
    const {result: entries} = await updatedRoot.getEntries([
      'a',
      'zz'
    ]);
    const remainingKeys = entries.map(({key}) => key);
    remainingKeys.sort();
    assert.deepStrictEqual(remainingKeys.sort(utils.simpleCompare), [
      'a',
      'zz'
    ].sort(utils.simpleCompare));
  });
  it('delete multiple entries within range', async () => {
    const updatedList = [
      {
        key: 'a',
        value: 1
      },
      {
        key: 'b',
        value: 1
      },
      {
        key: 'bb',
        value: 2
      },
      {
        key: 'c',
        value: 1
      },
      {
        key: 'cc',
        value: 2
      },
      {
        key: 'd',
        value: -1
      },
      {
        key: 'ff',
        value: 2
      },
      {
        key: 'h',
        value: 1
      },
      {
        key: 'z',
        value: 1
      },
      {
        key: 'zz',
        value: 2
      }
    ];
    const {get, put} = storage();
    let root;
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list: updatedList,
        ...opts
      })) {
      await put(await node.block);
      root = node;
    }
    const keysToDelete = [
      'b',
      'cc',
      'd',
      'z'
    ];
    const bulk = keysToDelete.map(key => ({
      key,
      del: true
    }));
    const {
      blocks,
      root: updatedRoot,
      previous
    } = await root.bulk(bulk);
    await Promise.all(blocks.map(block => put(block)));
    previous.sort((a, b) => utils.simpleCompare(a.key, b.key));
    const deletedKeys = previous.map(({key}) => key);
    const deletedValues = previous.map(({value}) => value);
    assert.deepStrictEqual(deletedKeys.sort(), keysToDelete.sort());
    assert.deepStrictEqual(deletedValues, [
      1,
      2,
      -1,
      1
    ]);
    for (const key of keysToDelete) {
      let threw = false;
      try {
        await updatedRoot.get(key);
      } catch (e) {
        if (e.message === 'Not found')
          threw = true;
      }
      assert.deepStrictEqual(threw, true);
    }
    const {result: entries} = await updatedRoot.getAllEntries();
    const remainingKeys = entries.map(({key}) => key);
    remainingKeys.sort(utils.simpleCompare);
    assert.deepStrictEqual(remainingKeys, [
      'a',
      'bb',
      'c',
      'ff',
      'h',
      'zz'
    ]);
  });
  it('delete multiple entries with some outside leaf range', async () => {
    const {get, put} = storage();
    let root;
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      await put(await node.block);
      root = node;
    }
    const keysToDelete = [
      'b',
      'cc',
      'z',
      'xxx'
    ];
    const bulk = keysToDelete.map(key => ({
      key,
      del: true
    }));
    const {
      blocks,
      root: updatedRoot,
      previous
    } = await root.bulk(bulk);
    await Promise.all(blocks.map(block => put(block)));
    const deletedKeys = previous.map(({key}) => key);
    const deletedValues = previous.map(({value}) => value);
    assert.deepStrictEqual(deletedKeys.sort(), [
      'b',
      'cc',
      'z'
    ].sort());
    assert.deepStrictEqual(deletedValues, [
      1,
      2,
      1
    ]);
    for (const key of keysToDelete) {
      let threw = false;
      try {
        await updatedRoot.get(key);
      } catch (e) {
        if (e.message === 'Not found')
          threw = true;
      }
      assert.deepStrictEqual(threw, true);
    }
    const {result: entries} = await updatedRoot.getEntries([
      'a',
      'zz'
    ]);
    const remainingKeys = entries.map(({key}) => key);
    remainingKeys.sort();
    assert.deepStrictEqual(remainingKeys.sort(utils.simpleCompare), [
      'a',
      'zz'
    ].sort(utils.simpleCompare));
  });
  it('big map', async () => {
    const {get, put} = storage();
    let mapRoot;
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      await put(await node.block);
      mapRoot = node;
    }
    const {result} = await mapRoot.get('c').catch(e => {
      assert.deepStrictEqual(e.message, 'Failed at key: c');
    });
    assert.deepStrictEqual(result, 1);
    const {
      blocks: blockX,
      root: rootX
    } = await mapRoot.bulk([{
        key: 'ok',
        value: 200
      }]);
    await Promise.all(blockX.map(block => put(block)));
    mapRoot = rootX;
    const {result: result2} = await mapRoot.get('ok').catch(e => {
      assert.deepStrictEqual(e.message, 'Failed at key: ok');
    });
    assert.deepStrictEqual(result2, 200);
    const prefixes = [
      'b',
      'A',
      '0',
      ''
    ];
    for (const prefix of prefixes) {
      for (let index = 30; index > 0; index--) {
        const key = prefix + index.toString();
        const bulk = [{
            key,
            value: index
          }];
        const {blocks, root} = await mapRoot.bulk(bulk);
        await Promise.all(blocks.map(block => put(block)));
        mapRoot = root;
        const {result: result3} = await mapRoot.get(key).catch(e => {
          throw Error('Couldn\'t find key: ' + key);
        });
        assert.deepStrictEqual(result3, index);
      }
    }
  });
  it('inner node splitting', async () => {
    const {get, put} = storage();
    let mapRoot;
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      await put(await node.block);
      mapRoot = node;
    }
    const initialKeys = [
      'a',
      'c',
      'e',
      'g',
      'i',
      'k',
      'm',
      'o',
      'q',
      's'
    ];
    const bulkInsert = initialKeys.map(key => ({
      key,
      value: key.charCodeAt(0)
    }));
    const {blocks, root} = await mapRoot.bulk(bulkInsert);
    await Promise.all(blocks.map(block => put(block)));
    mapRoot = root;
    for (const key of initialKeys) {
      const {result} = await mapRoot.get(key).catch(e => {
        throw Error('Couldn\'t find key: ' + key);
      });
      assert.deepStrictEqual(result, key.charCodeAt(0));
    }
    const additionalKeys = [
      'b',
      'd',
      'f',
      'h',
      'j',
      'l',
      'n',
      'p',
      'r'
    ];
    const bulkInsert2 = additionalKeys.map(key => ({
      key,
      value: key.charCodeAt(0)
    }));
    const {
      blocks: blocks2,
      root: root2
    } = await mapRoot.bulk(bulkInsert2);
    await Promise.all(blocks2.map(block => put(block)));
    mapRoot = root2;
    const allKeys = initialKeys.concat(additionalKeys).sort((a, b) => a.localeCompare(b));
    for (const key of allKeys) {
      const {result} = await mapRoot.get(key).catch(e => {
        throw Error('Couldn\'t find key: ' + key);
      });
      assert.deepStrictEqual(result, key.charCodeAt(0));
    }
    const extraKeys = [
      't',
      'u',
      'v',
      'w',
      'x',
      'y',
      'z'
    ];
    const bulkInsert3 = extraKeys.map(key => ({
      key,
      value: key.charCodeAt(0)
    }));
    const {
      blocks: blocks3,
      root: root3
    } = await mapRoot.bulk(bulkInsert3);
    await Promise.all(blocks3.map(block => put(block)));
    mapRoot = root3;
    const finalKeys = allKeys.concat(extraKeys).sort((a, b) => a.localeCompare(b));
    for (const key of finalKeys) {
      const {result} = await mapRoot.get(key).catch(e => {
        throw Error('Couldn\'t find key: ' + key);
      });
      assert.deepStrictEqual(result, key.charCodeAt(0));
    }
  });
  it.skip('passing, slow. deterministic fuzzer', async () => {
    const {get, put} = storage();
    let mapRoot;
    for await (const node of map.create({
        get,
        compare: utils.simpleCompare,
        list,
        ...opts
      })) {
      await put(await node.block);
      mapRoot = node;
    }
    const {result} = await mapRoot.get('c').catch(e => {
      assert.deepStrictEqual(e.message, 'Failed at key: c');
    });
    assert.deepStrictEqual(result, 1);
    for (let i = 0; i < 30; i = i + 9) {
      const randFun = mulberry32(i);
      for (let rowCount = 0; rowCount < 30; rowCount++) {
        const key = randFun().toString(36).substring(2);
        const value = `${ i }-${ rowCount }-${ key }`;
        const bulk = [{
            key,
            value
          }];
        const {blocks, root} = await mapRoot.bulk(bulk);
        await Promise.all(blocks.map(block => put(block)));
        mapRoot = root;
        const {result: result3} = await mapRoot.get(key).catch(e => {
          assert.deepStrictEqual(e.message, `Failed at key: ${ key } : ${ value }`);
        });
        assert.deepStrictEqual(result3, value);
      }
    }
    const all = await mapRoot.getAllEntries();
    assert.deepStrictEqual(all.length, 30);
  }).timeout(60 * 1000);
});
function mulberry32(a) {
  return function () {
    let t = a += 1831565813;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}
